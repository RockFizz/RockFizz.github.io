<!DOCTYPE HTML>
<html lang="zh-CN">
    


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="Javascript学习, 车舟慢">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="KeoTn_OFy4ndJwXNmm2gMeQfPhd7alqE9vQDwI32KCY">
    <meta name="description" content="js代理模式的使用代理模式包括许多小分类，在JavaScript开发中最常用的是虚拟代理和缓存代理。  
js对象实现图片加载// 创建一个本体对象
var myImage = (function(){
  // 创建标签
  var im">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Javascript学习 | 车舟慢</title>
    <link rel="icon" type="image/png" href="/diary/favicon.png">

    <link rel="stylesheet" type="text/css" href="/diary/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/diary/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/diary/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/diary/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/diary/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/diary/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/diary/css/my.css">
    
    <style type="text/css">
        
    </style>

    <script src="/diary/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

<link rel="stylesheet" href="/diary/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/diary/css/prism-line-numbers.css" type="text/css"></head>

    <body>

        <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/diary/" class="waves-effect waves-light">
                    
                    <img src="/diary/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">车舟慢</span>
                </a>
            </div>
            


<!-- <a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/diary/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/diary/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/diary/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/diary/demo/shuoshuo" class="waves-effect waves-light">
            
            <i class="fa fa-music"></i>
            
            <span>说说</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/diary/galleries" class="waves-effect waves-light">
            
            <i class="fa fa-photo"></i>
            
            <span>相册</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul> -->

<!-- 支持二级菜单特性  -->
<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right nav-menu">
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/diary/" class="waves-effect waves-light">
              
                <i class="fa fa-home"></i>
              
              <span>首页</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/diary/categories" class="waves-effect waves-light">
              
                <i class="fa fa-bookmark"></i>
              
              <span>分类</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/diary/archives" class="waves-effect waves-light">
              
                <i class="fa fa-archive"></i>
              
              <span>归档</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/diary/demo/shuoshuo" class="waves-effect waves-light">
              
                <i class="fa fa-music"></i>
              
              <span>说说</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/diary/galleries" class="waves-effect waves-light">
              
                <i class="fa fa-photo"></i>
              
              <span>相册</span>
            </a>

            
      </li>
    

    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>

</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/diary/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">车舟慢</div>
        <div class="logo-desc">
            
            雁引愁心去，山衔好月来。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/diary/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/diary/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/diary/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/diary/demo/shuoshuo" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-music"></i>
                
                说说
            </a>
        </li>
        
        <li>
            <a href="/diary/galleries" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-photo"></i>
                
                相册
            </a>
        </li>
        
        
    </ul>

   
   
<!-- 支持二级菜单特性   -->
<!-- <ul class="menu-list mobile-menu-list">
    
        <li class="m-nav-item">
                
                    <a href="/diary/" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-home"></i>
                        
                        首页
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/diary/categories" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-bookmark"></i>
                        
                        分类
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/diary/archives" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-archive"></i>
                        
                        归档
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/diary/demo/shuoshuo" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-music"></i>
                        
                        说说
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/diary/galleries" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-photo"></i>
                        
                        相册
                    </a>
              
            </li>
        

        
    </ul> -->

</div>

        </div>

        
    </nav>

</header>

        
<script src="/diary/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/diary/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/diary/medias/featureimages/7.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        Javascript学习
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/diary/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/diary/tags/JavaScript/" target="_blank">
                                <span class="chip bg-color">JavaScript</span>
                            </a>
                        
                            <a href="/diary/tags/eslint/" target="_blank">
                                <span class="chip bg-color">eslint</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>
            
            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-10-11
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                        sean
                    
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        11.9k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        50 分
                    </div>
                    
                
                
                

            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="js代理模式的使用"><a href="#js代理模式的使用" class="headerlink" title="js代理模式的使用"></a>js代理模式的使用</h2><p>代理模式包括许多小分类，在JavaScript开发中最常用的是虚拟代理和缓存代理。  </p>
<h3 id="js对象实现图片加载"><a href="#js对象实现图片加载" class="headerlink" title="js对象实现图片加载"></a>js对象实现图片加载</h3><pre class="line-numbers language-html"><code class="language-html">// 创建一个本体对象
var myImage = (function(){
  // 创建标签
  var imgNode = document.createElement( 'img' );
  // 添加到页面
  document.body.appendChild( imgNode );
  return {
    // 设置图片的src
    setSrc: function( src ){
      // 更改src
      imgNode.src = src;
    }
  }
})();

myImage.setSrc( 'http:// image.qq.com/music/photo/k/000GGDys0yA0Nk.jpg' );
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="js对象结合虚拟代理实现图片预加载"><a href="#js对象结合虚拟代理实现图片预加载" class="headerlink" title="js对象结合虚拟代理实现图片预加载"></a>js对象结合虚拟代理实现图片预加载</h3><pre class="line-numbers language-html"><code class="language-html">// 创建一个本体对象
var myImage = (function(){
  // 创建标签
  var imgNode = document.createElement( 'img' );
  // 添加到页面
  document.body.appendChild( imgNode );
  return {
    // 设置图片的src
    setSrc: function( src ){
      // 更改src
      imgNode.src = src;
    }
  }
})();

// 创建代理对象
var proxyImage = (function(){
  // 创建一个新的img标签
  var img = new Image;
  // img 加载完成事件
  img.onload = function(){
    // 调用 myImage 替换src方法
    myImage.setSrc( this.src );
  }
  return {
    // 代理设置地址
    setSrc: function( src ){
      // 预加载 loading
      myImage.setSrc( 'file:// /C:/Users/svenzeng/Desktop/loading.gif' );
      // 赋值正常图片地址
      img.src = src;
    }
  }
})();

proxyImage.setSrc( 'http:// image.qq.com/music/photo/k/000GGDys0yA0Nk.jpg' );


//现在我们可以通过 proxyImage 间接地访问 MyImage 。proxyImage 控制了客户对 MyImage 的访问，  
并且在此过程中提前把 img 节点的 src 设置为了一张本地的 loading 图片  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>代理和本体接口具有一致性，如果有一天我们不再需要预加载，那么就不再需要代理对象，可以选择直接请求本体。其中关键是代理对象和本体都对外提供了setSrc方法，在客户看来，代理对象和本体是一致的，代理接手请求的过程对于用户来说是透明的，用户并不清楚代理和本体的区别这样做有两个好处：</p>
<ol>
<li>用户可以放心地请求代理，他只关心是否能得到想要的结果。  </li>
<li>在任何使用本体的地方都可以替换成使用代理。  </li>
</ol>
<pre class="line-numbers language-html"><code class="language-html">// 预加载
proxyImage.setSrc( 'http:// image.qq.com/music/photo/k/000GGDys0yA0Nk.jpg' );  
// 不用预加载
myImage.setSrc( 'http:// image.qq.com/music/photo/k/000GGDys0yA0Nk.jpg' );
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="js缓存代理的使用"><a href="#js缓存代理的使用" class="headerlink" title="js缓存代理的使用"></a>js缓存代理的使用</h3><p>乘积函数:  </p>
<pre class="line-numbers language-html"><code class="language-html">var mult = function(){
  console.log( '开始计算乘积' );
  var a = 1;
  for ( var i = 0, l = arguments.length; i &lt; l; i++ ){
    a = a * arguments[i];
  }
  return a;
};
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>缓存代理函数:  </p>
<pre class="line-numbers language-html"><code class="language-html">var proxyMult = (function(){
  // 缓存结果
  var cache = {};
  return function(){
    // 将参数转化为字符串
    var args = Array.prototype.join.call( arguments, ',' );
    // 遍历缓存结果如果存在直接返回结果
    if ( args in cache ){
      return cache[ args ];
    }
    // 不存在进行计算并保存结果
    return cache[ args ] = mult.apply( this, arguments );
  }
})();

proxyMult( 1, 2, 3, 4 ); // 输出：24 
proxyMult( 1, 2, 3, 4 ); // 输出：24
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="缓存代理工厂"><a href="#缓存代理工厂" class="headerlink" title="缓存代理工厂"></a>缓存代理工厂</h3><p>动态创建代理:  </p>
<pre class="line-numbers language-html"><code class="language-html">/**************** 计算乘积 *****************/
var mult = function(){
  var a = 1;
  for ( var i = 0, l = arguments.length; i &lt; l; i++ ){
    a = a * arguments[i];
  }
  return a;
}
/**************** 计算加和 *****************/
var plus = function(){
  var a = 0;
  for ( var i = 0, l = arguments.length; i &lt; l; i++ ){
    a = a + arguments[i];
  }
  return a;
}
/**************** 创建缓存代理的工厂 *****************/
var createProxyFactory = function( fn ){
  // 缓存结果
  var cache = {};
  return function(){
    // 将参数转换成字符串
    var args = Array.prototype.join.call( arguments, ',' );
    // 遍历缓存结果如果存在直接返回结果
    if ( args in cache ){
      return cache[ args ];
    }
    // 不存在进行相应的计算并保存结果
    return cache[ args ] = fn.apply( this, arguments );
  }
};

// 创建乘法和加法
var proxyMult = createProxyFactory( mult ),proxyPlus = createProxyFactory( plus )

alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24 
alert ( proxyMult( 1, 2, 3, 4 ) ); // 输出：24 
alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10 
alert ( proxyPlus( 1, 2, 3, 4 ) ); // 输出：10 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="eslint代码格式化"><a href="#eslint代码格式化" class="headerlink" title="eslint代码格式化"></a>eslint代码格式化</h2><pre class="line-numbers language-html"><code class="language-html">
//使用npm安装ESLint，--save-dev 会把 eslint 安装到 package.json 文件中的 devDependencies 属性中，意思是只是开发阶段用到这个包，上线时就不需要这个包了  

npm install eslint --save-dev
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-html"><code class="language-html">
vscode安装插件ESlint、vetur、Prettier-Code formatter。  

vscode文件-首选项-设置里，搜索eslint，Enable ESLint as a formatter勾选，  
搜索formatonsave关闭勾选。  

选择文档，右键Format Document，选择Prettier格式器格式化  

//检查单个文档代码规范，并尝试修复：  
node_modules/.bin/eslint --fix 'src/views/editor/LayoutContainer/render/LayoutContainer.vue'
node_modules/.bin/eslint --fix 'src/test.js'

//检查eslint规范  
npm run lint
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>prettier格式化规则:</p>
<pre class="line-numbers language-html"><code class="language-html">// @/.prettierrc:  
{
  "eslintIntegration": true,
  "singleQuote": true,
  "semi": false
}

vscode文件-首选项-设置,搜索formatonsave勾选  
每按下ctrl+S是代码会根据你配置的prettierrc规则进行格式化  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="JS判断（Object-Array）是否值相等"><a href="#JS判断（Object-Array）是否值相等" class="headerlink" title="JS判断（Object/Array）是否值相等"></a>JS判断（Object/Array）是否值相等</h2><p>导入Objutils.js<br>简单对象的判断用isObjectChangedSimple<br>复杂对象属性嵌套带Object或Array类型的的使用isObjectChanged  </p>
<pre class="line-numbers language-html"><code class="language-html">class _ObjUtils{
    getDataType(data) {
        const temp = Object.prototype.toString.call(data);
        const type = temp.match(/\b\w+\b/g);
        return (type.length &lt; 2) ? 'Undefined' : type[1];
    }
    iterable(data){
        return ['Object', 'Array'].includes(this.getDataType(data));
    }
    isObjectChangedSimple(source, comparison){
        const _source = JSON.stringify(source)
        const _comparison = JSON.stringify({...source,...comparison})
        return _source !== _comparison
    }
    isObjectChanged(source, comparison) {
        if (!this.iterable(source)) {
        throw new Error(`source should be a Object or Array , but got ${this.getDataType(source)}`);
        }
        if (this.getDataType(source) !== this.getDataType(comparison)) {
        return true;
        }
        const sourceKeys = Object.keys(source);
        const comparisonKeys = Object.keys({...source, ...comparison});
        if (sourceKeys.length !== comparisonKeys.length) {
        return true;
        }
        return comparisonKeys.some(key => {
        if (this.iterable(source[key])) {
            return this.isObjectChanged(source[key], comparison[key]);
        } else {
            return source[key] !== comparison[key];
        }
        });
    }
}

export {_ObjUtils as ObjUtils}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用方法：  </p>
<pre class="line-numbers language-html"><code class="language-html">import { ObjUtils } from './Objutils'

let tar1={a:[4,6],b:13,c:{aa:3,bb:4,cc:5}}
let tar2={a:[4,6],b:13,c:{bb:4,cc:5,aa:3}}
let tar3={a:[6,4],b:13,c:{bb:4,cc:5,aa:3}}

// {}的key排列无顺序区分
console.log(new ObjUtils().isObjectChanged(tar3,tar2))  
// []的key排列有顺序区分
console.log(new ObjUtils().isObjectChanged(tar3,tar2))  

console.log(new ObjUtils().isObjectChanged([22,11],[11,22]))
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>js的数据类型分为简单数据类型和复杂数据类型。简单数据类型包括：Number、String、Boolean、undifined、Null等，复杂数据类型包括：Object、Array、function等。<br>复杂数据类型都会存储在堆内存中，简单数据类型则是存储在栈内存里。我们在定义一个复杂数据类型的时候，会先在堆内存中开辟空间，把数据存进去后，再把内存地址返回给我们所定义的变量。这样看来，我们所进行的对比操作(使用’===’符号)，原来不是值的对比，而是内存地址的对比。<br>js中的Object、Array、Function等复杂数据类型，是无法直接用==和===操作符进行比对的  </p>
<h2 id="js深复制"><a href="#js深复制" class="headerlink" title="js深复制"></a>js深复制</h2><p>utils.js:  </p>
<pre class="line-numbers language-html"><code class="language-html">const deepClone=function(obj){
     // Handle the 3 simple types, and null or undefined or function
     if (null == obj || "object" != typeof obj) return obj;

     // Handle Date
     if (obj instanceof Date) {
         var copy = new Date();
         copy.setTime(obj.getTime());
         return copy;
     }
     // Handle Array or Object
     if (obj instanceof Array | obj instanceof Object) {
         var copy = (obj instanceof Array)?[]:{};
         for (var attr in obj) {
             if (obj.hasOwnProperty(attr))
               copy[attr] = deepClone(obj[attr]);
         }
         return copy;
     }
     throw new Error("Unable to clone obj! Its type isn't supported.");
}
export {
    deepClone as deepClone
}  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用  </p>
<pre class="line-numbers language-html"><code class="language-html">import {deepClone} from "./utils"  

var arr = [1,2,3,5]
var cloneArr = deepClone(arr)
console.log(arr === cloneArr)

var obj = { name: 'ccc', age: 18 }
var cloneObj = deepClone(obj)
console.log(cloneObj)   // --> { name: 'ccc', age: 18 }
console.log(obj === cloneObj)   // false
obj.name = 'www'
console.log(obj)    // --> { name: 'www', age: 18 }
console.log(cloneObj)   // --> { name: 'ccc', age: 18 }
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="代码片段整理"><a href="#代码片段整理" class="headerlink" title="代码片段整理"></a>代码片段整理</h2><h3 id="延时加载vue组件"><a href="#延时加载vue组件" class="headerlink" title="延时加载vue组件"></a>延时加载vue组件</h3><p>通过将import函数包装到箭头函数中，Vue将仅在请求时执行它，并在该时刻加载模块。</p>
<pre class="line-numbers language-html"><code class="language-html">new Vue({
  // ...
  components: {
    AsyncCmp: () => import("./AsyncCmp")
  }
});
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="延时加载vuex模块"><a href="#延时加载vuex模块" class="headerlink" title="延时加载vuex模块"></a>延时加载vuex模块</h3><p>Vuex有一种registerModule方法可以让我们动态创建Vuex模块。如果我们考虑到该import函数返回的Promise上来延迟加载模块：</p>
<pre class="line-numbers language-html"><code class="language-html">const store = new Vuex.Store()
...
// Assume there is a "login" module we wanna load
import('./store/login').then(loginModule => {
  store.registerModule('login', loginModule)
})
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="延时加载vue-router"><a href="#延时加载vue-router" class="headerlink" title="延时加载vue-router"></a>延时加载vue-router</h3><p>Vue路由器内置支持延迟加载。它就像使用该import功能导入组件一样简单</p>
<pre class="line-numbers language-html"><code class="language-html">// 假设我们想在/ login路由中延迟加载一个Login组件：  

// Instead of: import Login from './login'
const Login = () => import("./login");

new VueRouter({
  routes: [{ path: "/login", component: Login }]
});
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="js对象转数组"><a href="#js对象转数组" class="headerlink" title="js对象转数组"></a>js对象转数组</h3><pre class="line-numbers language-html"><code class="language-html">//获取对象里键值对的key或者value
var arr = []
for (let i in obj) {
    arr.push(obj[i]); //属性
    //arr.push(obj[i]); //值
}
console.log(arr);

//获取对象数组，push进去的内容为一个对象  
var arr = []
for (let i in obj) {
    let o = {};
    o[i] = obj[i];
    arr.push(o)
}
console.log(arr);

//我的使用
const eleKeys = []
this.cmdPara.map(item => {
  eleKeys.push(item.id)
})

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="JS将变量作为对象的key"><a href="#JS将变量作为对象的key" class="headerlink" title="JS将变量作为对象的key"></a>JS将变量作为对象的key</h3><pre class="line-numbers language-html"><code class="language-html">var lastWord = 'last word';

var a = {
  'first word': 'hello',
  [lastWord]: 'world'
};

a['first word'] // "hello"
a[lastWord] // "world"
a['last word'] // "world"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Vue通过js延时执行"><a href="#Vue通过js延时执行" class="headerlink" title="Vue通过js延时执行"></a>Vue通过js延时执行</h3><pre class="line-numbers language-html"><code class="language-html">setTimeout(()=>{
  this.$store.dispatch('screen/EXCUTE_COMMAND_TEST', { mytest: 2021 })
},4000)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="js实现watch监听数据变化"><a href="#js实现watch监听数据变化" class="headerlink" title="js实现watch监听数据变化"></a>js实现watch监听数据变化</h3><p>ES6通过Proxy实现,Proxy在目标对象的外层搭建了一层拦截，外界对目标对象的某些操作，必须通过这层拦截  </p>
<pre class="line-numbers language-html"><code class="language-html">
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    <span class="token keyword">var</span> aaa<span class="token operator">=</span><span class="token punctuation">{</span>
        ab<span class="token punctuation">:</span><span class="token number">123</span><span class="token punctuation">,</span>
        cde<span class="token punctuation">:</span><span class="token number">456</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> handler<span class="token operator">=</span><span class="token punctuation">{</span>
        <span class="token keyword">set</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 被设置为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token keyword">get</span><span class="token punctuation">:</span><span class="token keyword">function</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 被读取`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment" spellcheck="true">// es6方法 第一个参数为监听的对象，第二个参数为改写的方法</span>
    <span class="token keyword">let</span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>aaa<span class="token punctuation">,</span>handler<span class="token punctuation">)</span>
    p<span class="token punctuation">.</span>ab<span class="token operator">=</span><span class="token number">32</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>ab<span class="token punctuation">)</span>

</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Object-keys方法之详解"><a href="#Object-keys方法之详解" class="headerlink" title="Object.keys方法之详解"></a>Object.keys方法之详解</h3><blockquote>
<p>Object.keys(obj)<br>参数：要返回其枚举自身属性的对象<br>返回值：一个表示给定对象的所有可枚举属性的字符串数组  </p>
</blockquote>
<p>处理对象，返回可枚举的属性数组  </p>
<pre class="line-numbers language-html"><code class="language-html">let person = {name:"张三",age:25,address:"深圳",getName:function(){}}

Object.keys(person)  
// ["name", "age", "address","getName"]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>处理数组，返回索引值数组  </p>
<pre class="line-numbers language-html"><code class="language-html">let arr = [1,2,3,4,5,6]

Object.keys(arr)  
// ["0", "1", "2", "3", "4", "5"]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>处理字符串，返回索引值数组  </p>
<pre class="line-numbers language-html"><code class="language-html">let str = "saasd字符串"

Object.keys(str)  
// ["0", "1", "2", "3", "4", "5", "6", "7"]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>常用技巧：  </p>
<pre class="line-numbers language-html"><code class="language-html">let person = {name:"张三",age:25,address:"深圳",getName:function(){}}

Object.keys(person).map((key)=>{
　　person[key] // 获取到属性对应的值，做一些处理
}) 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Object-values-方法之详解"><a href="#Object-values-方法之详解" class="headerlink" title="Object.values()方法之详解"></a>Object.values()方法之详解</h3><blockquote>
<p>Object.values()和Object.keys()是相反的操作，把一个对象的值转换为数组<br>返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历属性的值  </p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html">let obj = {
    foo : "bar",
    baz : 20
};
console.log(Object.values(obj));  // ["bar", 20]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Object.values()只会遍历对象自身的可遍历（enumerable）属性  </p>
<pre class="line-numbers language-html"><code class="language-html">const obj = Object.create({},{p : {value : 10}});  

console.log(Object.values(obj));  
//打印[]
console.log(Object.getOwnPropertyDescriptors(obj));  
//打印出{p:{configurable:false,enumerable:false,value:10,writable:false}}
Object.create方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，  
因为p的属性描述对象的enumerable默认是false，Object.values不会返回这个属性。  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>只要把enumerable改成true，Object.values就会返回属性p的值  </p>
<pre class="line-numbers language-html"><code class="language-html">const obj = Object.create({},{p:{
     value : 10,
     enumerable : true,
     configurable : true,
     writable : true,
}})
console.log(Object.values(obj));    //[10]

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Object-entries-方法之详解"><a href="#Object-entries-方法之详解" class="headerlink" title="Object.entries()方法之详解"></a>Object.entries()方法之详解</h3><blockquote>
<p>Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组  </p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html">var obj = { foo: 'bar', baz: 42 };  
console.log(Object.entries(obj));  
//[Array[2],Array[2]]  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>遍历对象的属性  </p>
<pre class="line-numbers language-html"><code class="language-html">let obj = {
    one : 1,
    two : 2,
}
for(let [k , v] of Object.entries(obj)){
     console.log(`${JSON.stringify(k)} : ${JSON.stringify(v)}`);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>将对象转为真正的Map结构  </p>
<pre class="line-numbers language-html"><code class="language-html">const obj = {foo : "bar", baz : 10};
const map = new Map(Object.entries(obj));
console.log(map); 

//Map(2) {'foo'=>'bar','baz'=>10}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="使用默认数据"><a href="#使用默认数据" class="headerlink" title="使用默认数据"></a>使用默认数据</h3><pre class="line-numbers language-html"><code class="language-html">// @/utils/Constant.js:  
export const defaultPageSetting = {
  width: 1920,
  height: 1080,
  backgroundColor: '#091734',
  backgroundRepeat: 'no-repeat',
  backgroundPosition: 'center',
  opacity: 100,
  frameWidth: '0px',
  frameHeight: '0px',
  globalParam: [],
  largeChartSize: '80%',
  isLargeChart: false
}
export const exportType = {
  SCREEN: '0',
  TEMPLATE: '1',
  COMPONENT: '2'
}

// 别处使用数据  
import { defaultPageSetting } from '@/utils/Constant'  
var defaultdb=JSON.parse(JSON.stringify(defaultPageSetting))
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="ES6的展开运算符"><a href="#ES6的展开运算符" class="headerlink" title="ES6的展开运算符"></a>ES6的展开运算符</h3><blockquote>
<p>…展开运算符允许一个表达式在某处展开。展开运算符在多个参数（用于函数调用）或多个元素（用于数组字面量）或者多个变量（用于解构赋值）的地方可以使用。  </p>
</blockquote>
<p>将一个数组转为用逗号分隔的参数序列。  </p>
<pre class="line-numbers language-html"><code class="language-html">console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5
[...document.querySelectorAll('div')]
// [<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>, <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数调用的参数(将数组转为参数序列)  </p>
<pre class="line-numbers language-html"><code class="language-html">function push(array, ...items) {
    array.push(...items);
}
function add(x, y) {
    return x + y;
}
var numbers = [4, 38];
add(...numbers) // 42
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>数组合并  </p>
<pre class="line-numbers language-html"><code class="language-html">// ES5
[1, 2].concat(more)
// ES6
[1, 2, ...more]
var arr1 = ['a', 'b'];
var arr2 = ['c'];
var arr3 = ['d', 'e'];
// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]
// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ 'a', 'b', 'c', 'd', 'e' ]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>数组字面量中使用展开运算符  </p>
<pre class="line-numbers language-html"><code class="language-html">let arr1 = ['a', 'b', 'c']
let arr2 = [...arr1, 'd', 'e']
console.log(arr2)  
// 输出：["a", "b", "c", "d", "e"]  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>解构赋值也是ES6中的一个特性,<br>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。  </p>
<pre class="line-numbers language-html"><code class="language-html">let [arg1, arg2, ...arg3] = [1, 2, 3, 4]
console.log(arg1) // 1
console.log(arg2) // 2
console.log(arg3) // [3, 4]  

// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
下面是另外一些例子。
const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest // [2, 3, 4, 5]
const [first, ...rest] = [];
first // undefined
rest // []:
const [first, ...rest] = ["foo"];
first // "foo"
rest // []

const [...butLast, last] = [1, 2, 3, 4, 5];
//  报错
const [first, ...middle, last] = [1, 2, 3, 4, 5];
//  报错
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。  </p>
<pre class="line-numbers language-html"><code class="language-html">var dateFields = readDateFields(database);
var d = new Date(...dateFields);

上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>字符串转为真正的数组  </p>
<pre class="line-numbers language-html"><code class="language-html">[...'hello']
// [ "h", "e", "l", "l", "o" ]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>将实现Iterator接口的对象转为真正的数组  </p>
<pre class="line-numbers language-html"><code class="language-html">var nodeList = document.querySelectorAll('div');
var array = [...nodeList];

querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。  
这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 接口。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Map和Set结构转为真正的数组<br>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。  </p>
<pre class="line-numbers language-html"><code class="language-html">let map = new Map([
[1, 'one'],
[2, 'two'],
[3, 'three'],
]);
let arr = [...map.keys()]; // [1, 2, 3]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="ES7中…可作为对象展开符"><a href="#ES7中…可作为对象展开符" class="headerlink" title="ES7中…可作为对象展开符"></a>ES7中…可作为对象展开符</h3><p>ES7展开对象<br>将一个对象中的一部分抽取出来，成为一个新对象赋值给展开运算符  </p>
<pre class="line-numbers language-html"><code class="language-html">let {x, y, ...z} = {x: 1, y: 2, a: 3, b: 4}
console.log(x) // 1
console.log(y) // 2
console.log(z) // {a: 3, b: 4}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>像数组中插入数组那样将一个对象插入到另外一个对象中  </p>
<pre class="line-numbers language-html"><code class="language-html">let z = {a: 3, b: 4}
let n = {x: 1, y: 2, ...z}
console.log(n) // {x: 1, y: 2, a: 3, b: 4}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>合并两个对象  </p>
<pre class="line-numbers language-html"><code class="language-html">let a = {x: 1, y: 2}
let b = {z: 3}
let c = {...a, ...b}
console.log(c) // {x: 1, y: 2, z: 3}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="ES6之map方法"><a href="#ES6之map方法" class="headerlink" title="ES6之map方法"></a>ES6之map方法</h3><p>map()方法：map，映射，即原数组映射成一个新的数组；<br>map方法接受一个新参数，这个参数就是将原数组变成新数组的映射关系。  </p>
<pre class="line-numbers language-html"><code class="language-html">function myfun_1(arr){
 var array = [];
  arr.map( item => {
    array.push(item*item);
  });
  console.log(array);
}
function myfun_2(arr){
 var array = [];
  arr.map( function(item){
    array.push(item*item);
 });
  console.log(array);
}

var arr3 = [1,2,3,4,5];
myfun_1(arr3);    //[1,4,9,16,25]
var arr1 = [5,2,1,3,4];
myfun_1(arr1);  //[25,4,1,9,16]
var arr2 = [3,4,5,1,2,6];
myfun_2(arr2);  //[9,16,25,1,4,36]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实际的应用中，我们可以通过map方法得到某一个对象数组中特定属性的值  </p>
<pre class="line-numbers language-html"><code class="language-html">var obj = [
  {name:'小明',age:16,sex:'男'},
  {name:'小红',age:17,sex:'女'},
  {name:'小白',age:18,sex:'女'},
]
function getter(obj){
  obj.map( item => {
    console.log(item.age);
  })
}

getter(obj);
//16
//17
//18
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="ES6之filter方法"><a href="#ES6之filter方法" class="headerlink" title="ES6之filter方法"></a>ES6之filter方法</h3><p>filter是数组过滤方法  </p>
<p>判断数组中是否存在某个值:  </p>
<pre class="line-numbers language-html"><code class="language-html">var newarr = [
  { num: 1, val: 'ceshi', flag: 'aa' },
  { num: 2, val: 'ceshi2', flag: 'aa2'  }
]
console.log(newarr.filter(item => item.num===2 ))
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>去掉空数组空字符串、undefined、null  </p>
<pre class="line-numbers language-html"><code class="language-html">var arr = ['1','2',undefined, '3.jpg',undefined]
var newArr = arr.filter(item => item)
console.log(newArr)

var arr = ['1','2',null, '3.jpg',null]
var newArr = arr.filter(item => item)
console.log(newArr)

//空字符串里面不能包含空格
var arr = ['1','2','', '3.jpg','']
var newArr = arr.filter(item => item)
console.log(newArr)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>去掉数组中不符合要求的项  </p>
<pre class="line-numbers language-html"><code class="language-html">var arr = [20,30,50, 96,50]
var newArr = arr.filter(item => item>40)  
console.log(newArr)
//打印出[50,96,50]  

var arr = ['10','12','23','44','42']
var newArr = arr.filter(item => item.indexOf('2')&lt;0) 
console.log(newArr)
//打印出['10','44']
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>数组去重  </p>
<pre class="line-numbers language-html"><code class="language-html">var arr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7,8,8,0,8,6,3,4,56,2];
var arr2 = arr.filter((x, index,self)=>self.indexOf(x)===index)  
console.log(arr2); //[1, 2, 3, 4, 5, 6, 7, 8, 0, 56]
//打印出[1, 2, 3, 4, 5, 6, 7, 8, 0, 56]  

var arr=[1,2,1,'1',null,null,undefined,undefined,NaN,NaN]
let res=Array.from(new Set(arr));
//or
let newarr=[...new Set(arr)]

//均打印{1,2,"1",null,undefined,NaN}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="JS中数组的slice方法"><a href="#JS中数组的slice方法" class="headerlink" title="JS中数组的slice方法"></a>JS中数组的slice方法</h3><p>slice()方法用新的数组对象，返回原数组中被选中的元素。  </p>
<pre class="line-numbers language-html"><code class="language-html">let arraynew = arrayold.slice(start,end)
//选中原数组start开始，在end结束的元素  
//包括start，不包括end

let fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
let citrus = fruits.slice(1, 3);
console.log(citrus)  
//打印出['Orange', 'Lemon']<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ES6之Map对象"><a href="#ES6之Map对象" class="headerlink" title="ES6之Map对象"></a>ES6之Map对象</h2><p>Map对象保存键值对，任何值(任意类型对象或原始值)都可以作为一个键或一个值。  </p>
<pre class="line-numbers language-html"><code class="language-html">Map与Object的区别：  
一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。  
Map中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。  
Map的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。  
Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Map对象中的key可以是字符串  </p>
<pre class="line-numbers language-html"><code class="language-html">var myMap = new Map();
var keyString = "a string";  
myMap.set(keyString, "和键'a string'关联的值");

myMap.get(keyString);    // "和键'a string'关联的值"
myMap.get("a string");   // "和键'a string'关联的值"
                         // 因为 keyString === 'a string'
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Map对象中的key可以是对象  </p>
<pre class="line-numbers language-html"><code class="language-html">var myMap = new Map();
var keyObj = {},  
myMap.set(keyObj, "和键 keyObj 关联的值");
﻿
myMap.get(keyObj); // "和键 keyObj 关联的值"
myMap.get({}); // undefined, 因为 keyObj !== {}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Map对象中的key可以是函数  </p>
<pre class="line-numbers language-html"><code class="language-html">var myMap = new Map();
var keyFunc = function () {}, // 函数 
myMap.set(keyFunc, "和键 keyFunc 关联的值");

myMap.get(keyFunc); // "和键 keyFunc 关联的值"
myMap.get(function() {}) // undefined, 因为 keyFunc !== function () {}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Map对象中的key可以是NaN  </p>
<pre class="line-numbers language-html"><code class="language-html">var myMap = new Map();
myMap.set(NaN, "not a number"); 
myMap.get(NaN); // "not a number"

var otherNaN = Number("foo");
myMap.get(otherNaN); // "not a number"
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Map对象的遍历,通常用for…of和foreah()  </p>
<pre class="line-numbers language-html"><code class="language-html">var myMap = new Map();
myMap.set(0, "zero");
myMap.set(1, "one");

// 将会显示两个 log。 一个是 "0 = zero" 另一个是 "1 = one"
for (var [key, value] of myMap) {
  console.log(key + " = " + value);
}
for (var [key, value] of myMap.entries()) {
  console.log(key + " = " + value);
}
/* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */

// 将会显示两个log。 一个是 "0" 另一个是 "1"
for (var key of myMap.keys()) {
  console.log(key);
}
/* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */

// 将会显示两个log。 一个是 "zero" 另一个是 "one"
for (var value of myMap.values()) {
  console.log(value);
}
/* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。 */
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-html"><code class="language-html">var myMap = new Map();
myMap.set(0, "zero");
myMap.set(1, "one");

// 将会显示两个 logs。 一个是 "0 = zero" 另一个是 "1 = one"
myMap.forEach(function(value, key) {
  console.log(key + " = " + value);
}, myMap)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Map对象与 Array的转换  </p>
<pre class="line-numbers language-html"><code class="language-html">var kvArray = [["key1", "value1"], ["key2", "value2"]];

// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象
var myMap = new Map(kvArray);
//{'key1'=>'value1','key2'=>'value2'}

// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组
var outArray = Array.from(myMap);
//[["key1", "value1"], ["key2", "value2"]]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Map对象的克隆  </p>
<pre class="line-numbers language-html"><code class="language-html">var myMap1 = new Map([["key1", "value1"], ["key2", "value2"]]);
var myMap2 = new Map(myMap1);

console.log(original === clone); 
// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Map对象的合并  </p>
<pre class="line-numbers language-html"><code class="language-html">var first = new Map([[1, 'one'], [2, 'two'], [3, 'three'],]);
var second = new Map([[1, 'uno'], [2, 'dos']]);

// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three
var merged = new Map([...first, ...second]);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ES6之Set对象"><a href="#ES6之Set对象" class="headerlink" title="ES6之Set对象"></a>ES6之Set对象</h2><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。  </p>
<pre class="line-numbers language-html"><code class="language-html">let mySet = new Set();

mySet.add(1); // Set(1) {1}
mySet.add(5); // Set(2) {1, 5}
mySet.add(5); // Set(2) {1, 5} 这里体现了值的唯一性
mySet.add("some text"); 
// Set(3) {1, 5, "some text"} 这里体现了类型的多样性
var o = {a: 1, b: 2}; 
mySet.add(o);
mySet.add({a: 1, b: 2}); 
// Set(5) {1, 5, "some text", {…}, {…}} 
// 这里体现了对象之间引用不同不恒等，即使值相同，Set 也能存储
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Set对象与Array的转换  </p>
<pre class="line-numbers language-html"><code class="language-html">// Array 转 Set
var mySet = new Set(["value1", "value2", "value3"]);  
// Set(3) {"value1", "value2", "value3"}  

// 用...操作符，将 Set 转 Array
var myArray = [...mySet];
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>String转Set对象  </p>
<pre class="line-numbers language-html"><code class="language-html">var mySet = new Set('hello');  // Set(4) {"h", "e", "l", "o"}
// 注：Set 中 toString 方法是不能将 Set 转换成 String
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="Set对象的作用"><a href="#Set对象的作用" class="headerlink" title="Set对象的作用"></a>Set对象的作用</h3><p>数组去重  </p>
<pre class="line-numbers language-html"><code class="language-html">var mySet = new Set([1, 2, 3, 4, 4]);
[...mySet]; // [1, 2, 3, 4]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>并集  </p>
<pre class="line-numbers language-html"><code class="language-html">var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var union = new Set([...a, ...b]); // {1, 2, 3, 4}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>交集  </p>
<pre class="line-numbers language-html"><code class="language-html">var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var intersect = new Set([...a].filter(x => b.has(x))); // {2, 3}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>差集  </p>
<pre class="line-numbers language-html"><code class="language-html">var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var difference = new Set([...a].filter(x => !b.has(x))); // {1}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="function-自执行与调用分析"><a href="#function-自执行与调用分析" class="headerlink" title="(function(){})()自执行与调用分析"></a>(function(){})()自执行与调用分析</h2><p>以下是两种JavaScript立即执行函数的写法  </p>
<pre class="line-numbers language-html"><code class="language-html">(function(){
......
})()  
和  
(function(){
......
}())
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最初我以为是一个括号包裹匿名函数，再在后面加个括号调用函数，最后达到函数定义后立即执行的目的，后来发现加括号的原因并非如此。要理解立即执行函数，需要先理解一些函数的基本概念。  </p>
<pre class="line-numbers language-html"><code class="language-html">函数声明:使用function关键字声明一个函数，再指定一个函数名，叫函数声明  
function fnName(){
......
}  

函数表达式:使用function关键字声明一个函数，但未给函数命名，最后将匿名函数赋予一个变量，叫函数表达式  
var fnName=function(){
......
}  

匿名函数:使用function关键字声明一个函数，但未给函数命名，所以叫匿名函数  
function(){
......
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>匿名函数属于函数表达式，匿名函数有很多作用，赋予一个变量则创建函数，赋予一个事件则成为事件处理程序或创建闭包等等  </p>
<p>函数表达式后面可以加括号立即调用该函数，函数声明不可以，只能以fnName()形式调用  </p>
<pre class="line-numbers language-html"><code class="language-html">fnName();
function fnName(){
    ...
}
//正常，因为‘提升'了函数声明，函数调用可在函数声明之前  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>函数声明可在声明之前进行函数调用，函数表达式的函数调用必须在函数表达式之后  </p>
<pre class="line-numbers language-html"><code class="language-html">fnName();
var fnName=function(){
    ...
}
//报错，变量fnName还未保存对函数的引用，函数调用必须在函数表达式之后
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>回过头来看两种JavaScript立即执行函数的写法，在函数体后面加括号就能立即调用，则这个函数必须是函数表达式，不能是函数声明。  </p>
<pre class="line-numbers language-html"><code class="language-html">(function(a){
    console.log(a);   
})(123);

开始()里是函数表达式，在函数表达式后跟()就能立即函数调用  

//就是立即console.log(123)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>javascript中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据javascript函数作用域链的特性，可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以(function(){…})()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。  </p>
<h2 id="JS闭包"><a href="#JS闭包" class="headerlink" title="JS闭包"></a>JS闭包</h2><p>“函数”和”函数内部能访问到的变量”的总和，就是一个闭包  </p>
<pre class="line-numbers language-html"><code class="language-html">function foo(){
  var local = 1
  function bar(){
    local++
    return local
  }
  return bar
}

var func = foo()
func()

//local 变量和 bar 函数就组成了一个闭包
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为什么要函数套函数呢？  </p>
<p>是因为需要局部变量，所以才把local放在一个函数里，如果不把local放在一个函数里，local就是一个全局变量了，达不到使用闭包的目的——隐藏变量。所以函数套函数只是为了造出一个局部变量，跟闭包无关。  </p>
<p>为什么要 return bar 呢？  </p>
<p>因为如果不 return，你就无法使用这个闭包。把 return bar 改成 window.bar = bar 也是一样的，只要让外面可以访问到这个 bar 函数就行了。所以 return bar 只是为了 bar 能被使用，也跟闭包无关。  </p>
<p>闭包常常用来间接访问一个变量。换句话说，隐藏一个变量。  </p>
<pre class="line-numbers language-html"><code class="language-html">(function(){
    var lives=50
    window.奖励一条命=function(){
        lives+=1
    }
    window.死一条命=function(){
        lives-=1
    }
})()

在其他的 JS 文件，就可以使用 window.奖励一条命() 来涨命，使用 window.死一条命() 来让角色掉一条命。  

达到了隐藏变量，又能被别人访问的目的  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="JS中的call-和apply-方法和区别"><a href="#JS中的call-和apply-方法和区别" class="headerlink" title="JS中的call()和apply()方法和区别"></a>JS中的call()和apply()方法和区别</h2><blockquote>
<p>这两方法存在的意义：实现继承，实现多重继承。  </p>
</blockquote>
<p>apply：调用一个对象的一个方法，用另一个对象替换当前对象。  </p>
<pre class="line-numbers language-html"><code class="language-html">B.apply(A, arguments);
A对象应用B对象的方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>call：调用一个对象的一个方法，用另一个对象替换当前对象  </p>
<pre class="line-numbers language-html"><code class="language-html">B.call(A, args1,args2)  
A对象调用B对象的方法
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<table>
<tbody><tr>
<th>call与apply的相同点</th>
<th>call与apply的不同点</th>
</tr>
<tr>
<td>方法的含义是一样的，即方法功能是一样的；第一个参数的作用是一样的；</td>
<td>call可以传入多个参数；apply只能传入两个参数，所以其第二个参数往往是作为数组形式传入</td>
</tr>
</tbody></table>

<pre class="line-numbers language-html"><code class="language-html">var name='小张',age=17
var obj={
    name:'小刘',
    objAge:this.age,
    myFun:function(){
        console.log(this.name+'年龄'+this.age)
    }
}
console.log(obj.objAge) // 17  
obj.myFun() // 小刘年龄undefined  
//this指向obj

var fav='盲僧'
function shows(){
    console.log(this.fav)
}
shows() //盲僧  
//全局声明的函数shows()里this指向window
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>call()、 apply()、 bind() 都是用来重定义this這个对象的!!!  </p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html">var name='小张',age=17
var obj={
    name:'小刘',
    objAge:this.age,
    myFun:function(){
        console.log(this.name+'年龄'+this.age)
    }
}
var db={
    name:'德玛',
    age:99
}

obj.myFun() //小刘年龄undefined --> this指向对象obj  
obj.myFun().call() //小张年龄17 --> this指向window  
obj.myFun().call(db) //德玛年龄99 --> this指向对象db  
obj.myFun().apply(db) //德玛年龄99 --> this指向对象db  
obj.myFun().bind(db)() //德玛年龄99 --> bind返回的是一个新函数，必需调用才会被执行  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>call()、 apply()、 bind()的传参  </p>
</blockquote>
<p>call、 bind、 apply 这三个函数的第一个参数都是this的指向对象，第二个参数差别如下：<br>call的参数是直接放进去的，第二第三第n个参数全都用逗号分隔，直接放到后面<br>apply的所有参数都必须放在一个数组里面传进去。<br>bind除了返回函数以外，它的参数和call 一样  </p>
<pre class="line-numbers language-html"><code class="language-html">var name='小张',age=17
var obj={
    name:'小刘',
    objAge:this.age,
    myFun:function(fm,t){
        console.log(this.name+'年龄'+this.age,'来自'+fm+'去往'+t)
    }
}
var db={
    name:'德玛',
    age:99
}

obj.myFun().call(db,'江西','深圳') //德玛年龄99来自江西去往深圳  
obj.myFun().call(db,['江西','深圳']) //德玛年龄99来自江西去往深圳  
obj.myFun().bind(db,'江西','深圳')() //德玛年龄99来自江西去往深圳 
obj.myFun().bind(db,['江西','深圳'])() //德玛年龄99来自江西深圳去往undefined 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="ES6中Promise用法讲解"><a href="#ES6中Promise用法讲解" class="headerlink" title="ES6中Promise用法讲解"></a>ES6中Promise用法讲解</h2><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。  </p>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从pending变为resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从pending变为rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。  </p>
<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。  </p>
<pre class="line-numbers language-html"><code class="language-html">const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
});

promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。  </p>
<p>下面是一个Promise对象的简单例子  </p>
<pre class="line-numbers language-html"><code class="language-html">function timeout(ms) {
  return new Promise((resolve, reject) => {
    setTimeout(resolve, ms, 'done');
  });
}

timeout(100).then((value) => {
  console.log(value);
});

上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。  
过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，  
就会触发then方法绑定的回调函数。  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Promise 新建后就会立即执行。  </p>
<pre class="line-numbers language-html"><code class="language-html">let promise = new Promise(function(resolve, reject) {
  console.log('Promise');
  resolve();
});

promise.then(function() {
  console.log('resolved.');
});

console.log('Hi!');

// Promise
// Hi!
// resolved  

上面代码中，Promise新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面是异步加载图片的例子。  </p>
<pre class="line-numbers language-html"><code class="language-html">function loadImageAsync(url) {
  return new Promise(function(resolve, reject) {
    const image = new Image();

    image.onload = function() {
      resolve(image);
    };

    image.onerror = function() {
      reject(new Error('Could not load image at ' + url));
    };

    image.src = url;
  });
}

上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在举个例子：  </p>
<pre class="line-numbers language-html"><code class="language-html">function runAsync(){
    var p = new Promise(function(resolve, reject){
        //做一些异步操作
        setTimeout(function(){
            console.log('执行完成');
            resolve('随便什么数据');
        }, 2000);
    });
    return p;            
}
runAsync()
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>包装好的函数最后，会return出Promise对象，也就是说，执行这个函数我们得到了一个Promise对象。还记得Promise对象上有then、catch方法吧？这就是强大之处了，看下面的代码  </p>
<pre class="line-numbers language-html"><code class="language-html">runAsync().then(function(data){
    console.log(data);
    //后面可以用传过来的数据做些其他操作
    //......
});
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在runAsync()的返回上直接调用then方法，then接收一个参数，是函数，并且会拿到我们在runAsync中调用resolve时传的的参数。运行这段代码，会在2秒后输出“执行完成”，紧接着输出“随便什么数据”。  </p>
<p>这时候你应该有所领悟了，原来then里面的函数就跟我们平时的回调函数一个意思，能够在runAsync这个异步任务执行完成之后被执行。这就是Promise的作用了，简单来讲，就是能把原来的回调写法分离出来，在异步操作执行完后，用链式调用的方式执行回调函数。  </p>
<p>Promise的优势在于，可以在then方法中继续写Promise对象并返回，然后继续调用then来进行回调操作。  </p>
<p>从表面上看，Promise只是能够简化层层回调的写法，而实质上，Promise的精髓是“状态”，用维护状态、传递状态的方式来使得回调函数能够及时调用  </p>
<p>Promise的正确场景是这样的(链式操作)  </p>
<pre class="line-numbers language-html"><code class="language-html">runAsync1()
.then(function(data){
    console.log(data);
    return runAsync2();
})
.then(function(data){
    console.log(data);
    return runAsync3();
})
.then(function(data){
    console.log(data);
});
或者  
runAsync1()
.then(function(data){
    console.log(data);
    return runAsync2();
})
.then(function(data){
    console.log(data);
    return '直接返回数据';  //这里直接返回数据
})
.then(function(data){
    console.log(data);
});

// 在then方法中，你也可以直接return数据而不是Promise对象，在后面的then中就可以接收到数据了
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>runAsync1、runAsync2、runAsync3这三个函数都是如何定义的？没错，就是下面这样  </p>
<pre class="line-numbers language-html"><code class="language-html">function runAsync1(){
    var p = new Promise(function(resolve, reject){
        //做一些异步操作
        setTimeout(function(){
            console.log('异步任务1执行完成');
            resolve('随便什么数据1');
        }, 1000);
    });
    return p;            
}
function runAsync2(){
    var p = new Promise(function(resolve, reject){
        //做一些异步操作
        setTimeout(function(){
            console.log('异步任务2执行完成');
            resolve('随便什么数据2');
        }, 2000);
    });
    return p;            
}
function runAsync3(){
    var p = new Promise(function(resolve, reject){
        //做一些异步操作
        setTimeout(function(){
            console.log('异步任务3执行完成');
            resolve('随便什么数据3');
        }, 2000);
    });
    return p;            
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么我们接着来看看ES6的Promise还有哪些功能。我们光用了resolve，还没用reject呢，它是做什么的呢？事实上，我们前面的例子都是只有“执行成功”的回调，还没有“失败”的情况，reject的作用就是把Promise的状态置为rejected，这样我们在then中就能捕捉到，然后执行“失败”情况的回调。看下面的代码。  </p>
<pre class="line-numbers language-html"><code class="language-html">function getNumber(){
    var p = new Promise(function(resolve, reject){
        //做一些异步操作
        setTimeout(function(){
            var num = Math.ceil(Math.random()*10); //生成1-10的随机数
            if(num&lt;=5){
                resolve(num);
            }
            else{
                reject('数字太大了');
            }
        }, 2000);
    });
    return p;            
}

getNumber()
.then(
    function(data){
        console.log('resolved');
        console.log(data);
    }, 
    function(reason, data){
        console.log('rejected');
        console.log(reason);
    }
);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>getNumber函数用来异步获取一个数字，2秒后执行完成，如果数字小于等于5，我们认为是“成功”了，调用resolve修改Promise的状态。否则我们认为是“失败”了，调用reject并传递一个参数，作为失败的原因。  </p>
<p>运行getNumber并且在then中传了两个参数，then方法可以接受两个参数，第一个对应resolve的回调，第二个对应reject的回调。所以我们能够分别拿到他们传过来的数据。  </p>
<p>我们知道Promise对象除了then方法，还有一个catch方法，它是做什么用的呢？其实它和then的第二个参数一样，用来指定reject的回调，用法是这样：  </p>
<pre class="line-numbers language-html"><code class="language-html">getNumber()
.then(function(data){
    console.log('resolved');
    console.log(data);
})
.catch(function(reason){
    console.log('rejected');
    console.log(reason);
});
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>效果和写在then的第二个参数里面一样。不过它还有另外一个作用：在执行resolve的回调（也就是上面then中的第一个参数）时，如果抛出异常了（代码出错了），那么并不会报错卡死js，而是会进到这个catch方法中。请看下面的代码：  </p>
<pre class="line-numbers language-html"><code class="language-html">getNumber()
.then(function(data){
    console.log('resolved');
    console.log(data);
    console.log(somedata); //此处的somedata未定义
})
.catch(function(reason){
    console.log('rejected');
    console.log(reason);
});
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>Promise的all方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后才执行回调。我们仍旧使用上面定义好的runAsync1、runAsync2、runAsync3这三个函数，看下面的例子：  </p>
<pre class="line-numbers language-html"><code class="language-html">Promise
.all([runAsync1(), runAsync2(), runAsync3()])
.then(function(results){
    console.log(results);
});
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用Promise.all来执行，all接收一个数组参数，里面的值最终都算返回Promise对象。这样，三个异步操作的并行执行的，等到它们都执行完后才会进到then里面。那么，三个异步操作返回的数据哪里去了呢？都在then里面呢，all会把所有异步操作的结果放进一个数组中传给then，就是上面的results。  </p>
<p>有了all，你就可以并行执行多个异步操作，并且在一个回调中处理所有的返回数据，是不是很酷？有一个场景是很适合用这个的，一些游戏类的素材比较多的应用，打开网页时，预先加载需要用到的各种资源如图片、flash以及各种静态文件。所有的都加载完后，我们再进行页面的初始化。  </p>
<p>all方法的效果实际上是「谁跑的慢，以谁为准执行回调」，那么相对的就有另一个方法「谁跑的快，以谁为准执行回调」，这就是race方法，这个词本来就是赛跑的意思。race的用法与all一样，我们把上面runAsync1的延时改为1秒来看一下：  </p>
<pre class="line-numbers language-html"><code class="language-html">Promise
.race([runAsync1(), runAsync2(), runAsync3()])
.then(function(results){
    console.log(results);
});
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这三个异步操作同样是并行执行的。结果你应该可以猜到，1秒后runAsync1已经执行完了，此时then里面的就执行了。  </p>
<p>在then里面的回调开始执行时，runAsync2()和runAsync3()并没有停止，仍旧再执行。于是再过1秒后，输出了他们结束的标志。  </p>
<p>这个race有什么用呢？使用场景还是很多的，比如我们可以用race给某个异步请求设置超时时间，并且在超时后执行相应的操作，代码如下：  </p>
<pre class="line-numbers language-html"><code class="language-html">//请求某个图片资源
function requestImg(){
    var p = new Promise(function(resolve, reject){
        var img = new Image();
        img.onload = function(){
            resolve(img);
        }
        img.src = 'xxxxxx';
    });
    return p;
}

//延时函数，用于给请求计时
function timeout(){
    var p = new Promise(function(resolve, reject){
        setTimeout(function(){
            reject('图片请求超时');
        }, 5000);
    });
    return p;
}

Promise
.race([requestImg(), timeout()])
.then(function(results){
    console.log(results);
})
.catch(function(reason){
    console.log(reason);
});
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>requestImg函数会异步请求一张图片，我把地址写为”xxxxxx”，所以肯定是无法成功请求到的。timeout函数是一个延时5秒的异步操作。我们把这两个返回Promise对象的函数放进race，于是他俩就会赛跑，如果5秒之内图片请求成功了，那么遍进入then方法，执行正常的流程。如果5秒钟图片还未成功返回，那么timeout就跑赢了，则进入catch，报出“图片请求超时”的信息。  </p>
<h2 id="js正则表达式"><a href="#js正则表达式" class="headerlink" title="js正则表达式"></a>js正则表达式</h2><p>正则表达式是由一个字符序列形成的搜索模式。<br>当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。<br>正则表达式可以是一个简单的字符，或一个更复杂的模式。<br>正则表达式可用于所有文本搜索和文本替换的操作。  </p>
<pre class="line-numbers language-html"><code class="language-html">/正则表达式主体/修饰符(可选)  
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>使用正则表达式搜索 “Runoob” 字符串，且不区分大小写  </p>
<pre class="line-numbers language-html"><code class="language-html">let str = "Visit Runoob!"; 
let n = str.search(/Runoob/i);
// 输出n为6
// runoob 是一个正则表达式主体 (用于检索)。  
// i 是一个修饰符 (搜索不区分大小写)。  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>使用正则表达式且不区分大小写将字符串中的 Microsoft 替换为 Runoob  </p>
<pre class="line-numbers language-html"><code class="language-html">var str = document.getElementById("demo").innerHTML;  
var txt = str.replace(/microsoft/i,"Runoob");  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<table>
<tbody><tr>
    <th>修饰符</th>
    <th>描述</th>
</tr>
<tr>
    <td>/i</td>
    <td>执行对大小写不敏感的匹配</td>
</tr>
<tr>
    <td>/g</td>
    <td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</td>
</tr>
<tr>
    <td>/m</td>
    <td>执行多行匹配</td>
</tr>
</tbody></table>

<table>
<tbody><tr>
    <th>正则表达式主体</th>
    <th>描述</th>
</tr>
<tr>
    <td>[abc]</td>
    <td>查找方括号之间的任何字符</td>
</tr>
<tr>
    <td>[0-9]</td>
    <td>查找任何从0至9的数字</td>
</tr>
<tr>
    <td>(x|y)</td>
    <td>查找任何以 | 分隔的选项</td>
</tr>
</tbody></table>

<table>
<tbody><tr>
    <th>元字符（特殊含义）</th>
    <th>描述</th>
</tr>
<tr>
    <td>/d</td>
    <td>查找数字</td>
</tr>
<tr>
    <td>/s</td>
    <td>查找空白字符</td>
</tr>
<tr>
    <td>/b</td>
    <td>匹配单词边界</td>
</tr>
<tr>
    <td>/uxxxx</td>
    <td>查找以十六进制数 xxxx 规定的 Unicode 字符</td>
</tr>
</tbody></table>  

<table>
<tbody><tr>
    <th>量词</th>
    <th>描述</th>
</tr>
<tr>
    <td>n+</td>
    <td>匹配任何包含至少一个 n 的字符串</td>
</tr>
<tr>
    <td>n*</td>
    <td>匹配任何包含零个或多个 n 的字符串</td>
</tr>
<tr>
    <td>n?</td>
    <td>匹配任何包含零个或一个 n 的字符串</td>
</tr>
</tbody></table>  

<h3 id="RegExp对象"><a href="#RegExp对象" class="headerlink" title="RegExp对象"></a>RegExp对象</h3><p>在JavaScript中，RegExp对象是一个预定义了属性和方法的正则表达式对象  </p>
<h3 id="test-正则表达式方法"><a href="#test-正则表达式方法" class="headerlink" title="test()正则表达式方法"></a>test()正则表达式方法</h3><p>test()方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回true，否则返回false。  </p>
<pre class="line-numbers language-html"><code class="language-html">let patt=/e/  
patt.test('afdfaf') //返回false  
patt.test('afdfeaf') //返回true  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="exec-正则表达式方法"><a href="#exec-正则表达式方法" class="headerlink" title="exec()正则表达式方法"></a>exec()正则表达式方法</h3><p>exec()方法用于检索字符串中的正则表达式的匹配。该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为null。  </p>
<pre class="line-numbers language-html"><code class="language-html">let patt=/e/  
patt.exec('afdfaf') //返回null
patt.exec('afddefaf')  
//返回[0:'e',index:4,input:'afddefaf',length:1,groups:undefined]  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="JS判断字符串是否全部为数字"><a href="#JS判断字符串是否全部为数字" class="headerlink" title="JS判断字符串是否全部为数字"></a>JS判断字符串是否全部为数字</h3><pre class="line-numbers language-html"><code class="language-html">let valtarget='123456'  
let isnum=/^\d+$/  
console.log(isnum.test(valtarget))  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="JS判断字符串是否全部为字母"><a href="#JS判断字符串是否全部为字母" class="headerlink" title="JS判断字符串是否全部为字母"></a>JS判断字符串是否全部为字母</h3><pre class="line-numbers language-html"><code class="language-html">let valtarget='abcdefg'  
let isletter=/^[a-zA-Z]+$/  
console.log(isletter.test(valtarget))  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="JS判断字符串是否为数字、字母、下划线组成"><a href="#JS判断字符串是否为数字、字母、下划线组成" class="headerlink" title="JS判断字符串是否为数字、字母、下划线组成"></a>JS判断字符串是否为数字、字母、下划线组成</h3><pre class="line-numbers language-html"><code class="language-html">let valtarget='ab123_cdefg'  
function isValid(str){
    let patt=/^\w+$/  
    return patt.test(str)  
}
console.log(isValid(valtarget))  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="async关键字"><a href="#async关键字" class="headerlink" title="async关键字"></a>async关键字</h2><p>async是ES7才有的与异步操作有关的关键字，和Promise，Generator有很大关联的。  </p>
<p>async函数返回一个Promise对象，可以使用then方法添加回调函数  </p>
<pre class="line-numbers language-html"><code class="language-html">async function helloAsync(){
    return "helloAsync";
  }

console.log(helloAsync())  // Promise {<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resolved</span><span class="token punctuation">></span></span>: "helloAsync"}

helloAsync().then(v=>{
   console.log(v);         // helloAsync
})
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>async函数中可能会有await表达式，async函数执行时，如果遇到await就会先暂停执行 ，等到触发的异步操作完成后，恢复async函数的执行并返回解析值。  </p>
<p>await关键字仅在async function中有效。如果在async function函数体外使用await ，你只会得到一个语法错误。  </p>
<p>await 操作符用于等待一个 Promise 对象, 它只能在异步函数 async function 内部使用。  </p>
<pre class="line-numbers language-html"><code class="language-html">function testAwait(){
   return new Promise((resolve) => {
       setTimeout(function(){
          console.log("testAwait");
          resolve();
       }, 1000);
   });
}

async function helloAsync(){
   await testAwait();
   console.log("helloAsync");
 }
helloAsync();
// testAwait
// helloAsync
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。  </p>
<p>如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。  </p>
<pre class="line-numbers language-html"><code class="language-html">function testAwait (x) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(x);
    }, 2000);
  });
}

async function helloAsync() {
  var x = await testAwait ("hello world");
  console.log(x); 
}
helloAsync ();
// hello world
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>正常情况下，await 命令后面是一个 Promise 对象，它也可以跟其他值，如字符串，布尔值，数值以及普通函数。  </p>
<pre class="line-numbers language-html"><code class="language-html">function testAwait(){
   console.log("testAwait");
}
async function helloAsync(){
   await testAwait();
   console.log("helloAsync");
}
helloAsync();
// testAwait
// helloAsync
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>await针对所跟不同表达式的处理方式：  </p>
<ul>
<li>Promise 对象：await 会暂停执行，等待 Promise 对象 resolve，然后恢复 async 函数的执行并返回解析值。</li>
<li>非 Promise 对象：直接返回对应的值</li>
</ul>

<h2 id="Vue之this-nextTick"><a href="#Vue之this-nextTick" class="headerlink" title="Vue之this.$nextTick()"></a>Vue之this.$nextTick()</h2><p>用于在下次DOM更新之后执行相应回调，（修改数据后，使用this.$nextTick，等待dom更新后，再执行回调里处理dom）<br>this.$nextTick()在页面交互，尤其是从后台获取数据后重新生成dom对象之后的操作有很大的优势。  </p>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>section</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hello<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Hello World ~<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>el-button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>danger<span class="token punctuation">"</span></span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>get<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点击<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>el-button</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>section</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
  <span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
    methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">333</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">444</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">111</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">222</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$refs<span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>

//结果：  
111  
undefined  
333  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  
222  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  
444  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  

根据打印的顺序看到，在created()钩子函数执行的时候DOM其实并未进行任何渲染，而此时进行DOM操作并无作用，而在created()里使用this.$nextTick()可以等待dom生成以后再来获取dom对象  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Vue之ref和-ref"><a href="#Vue之ref和-ref" class="headerlink" title="Vue之ref和$ref"></a>Vue之ref和$ref</h2><p>vm.$refs是一个对象，包含已注册过ref的所有子组件和dom元素<br>ref属性被用来给dom元素或子组件注册引用信息<br>如果在dom元素上使用ref注册，引用指向的就是dom元素<br>如果在子组件上使用ref注册，引用指向的就是组件实例  </p>
<pre class="line-numbers language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>ppp<span class="token punctuation">'</span></span><span class="token punctuation">></span></span> hello <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>  
//vm.$refs.ppp will be the DOM node  
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>child-comp</span> <span class="token attr-name">ref</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>childz<span class="token punctuation">'</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>child-comp</span><span class="token punctuation">></span></span>  
//vm.$refs.childz will be the child-comp instance  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>ref本身是作为渲染结果被创建的，因此常与this.$nextTick(()=&gt;{})结合使用  </p>
<h2 id="策略模式和命令模式的区别"><a href="#策略模式和命令模式的区别" class="headerlink" title="策略模式和命令模式的区别"></a>策略模式和命令模式的区别</h2><ul>
<li>策略模式：定义算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</li>
<li>命令模式：将请求封装成对象，这可以让你使用不同的请求、队列，或者日志请求来参数化其他对象。命令模式也可以支持撤销操作。</li>
</ul>

<p>策略模式:把易于变化的行为分别封装起来，让它们之间可以互相替换，让这些行为的变化独立于拥有这些行为的客户。策略模式定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。该模式使得算法可独立于它们的客户变化。<br>策略模式是通过不同的算法做同一件事情：例如排序  </p>
<p>命令模式:将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。<br>命令模式则是通过不同的命令做不同的事情，常含有（关联）接收者。  </p>
<p>命令模式是含有不同的命令（含有接收者的请求）：做不同的事情；隐藏接收者执行细节。<br>策略模式含有不同的算法，做相同的事情；  </p>
<p>区别在于是否含有接收者。命令模式含有，策略模式不含有。命令模式中的命令可以单独运行。  </p>
<p>策略模式可能有不同的算法，但是实际工作中，可能在同一环境下只执行一种算法；命令模式可能有不同的命令，实际工作中，可能各个命令是要先后执行的。  </p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><blockquote>
<p>定义：  </p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html">1. 将请求以命令的形式包裹在对象中，这个对象传递给调用者  
2. 调用者寻找可以处理该命令的合适对象，这个对象会处理传过来命令  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>解决了什么问题？  </p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html">解决行为需求的请求方 与 行为实现者 之间的紧密耦合关系  

命令的执行过程较为复杂且可能存在变化，需要对执行命令动作本身进行额外操作，考虑使用命令模式  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>如何解决？  </p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html">调用者，找到接受者，接受者执行命令  
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="../../../../images/command1_20211018010825.jpg" alt="">  </p>
<blockquote>
<p>关键代码  </p>
</blockquote>
<pre class="line-numbers language-html"><code class="language-html">四个角色：  
1. Receiver 真正的命令执行对象  
2. ConcreteCommand* ：封装的请求对象(类似实现了共同的接口从而可被Invoker统一引用)，内部持有Receiver对象。  
3. Invoker ： 请求的调用者，内部持有具体请求的引用。  
4. Client ： 即请求发出者，通过调用Invoker方法发出请求。  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="../../../../images/command2_20211018010825.jpg" alt="">  </p>
<h3 id="html前端自带命令模式效果说明"><a href="#html前端自带命令模式效果说明" class="headerlink" title="html前端自带命令模式效果说明"></a>html前端自带命令模式效果说明</h3><pre class="line-numbers language-html"><code class="language-html">// 需求现在有个刷新菜单目录，增加子菜单，删除子菜单工 ，我们用命令模式实现
var button1 = document.getElementById('button1')
var button2 = document.getElementById('button2')
var button3 = document.getElementById('button3')

// 最开始 所有的方法都属于自己对象的
const MenuBar = {
    refresh () {
        console.log('刷新')
    }
}

const subMenu = {
    add () {
        console.log("增加");
    },
    del () {
        console.log("删除");
    }
}

// 现在需要 将每个对象中的方法 进行拆分成单独类
// 并且 这些拆分后的指令需要 实现统一的方法 才能统一调用
class BaseCommand {
    constructor(receiver) {
        if (new.target === BaseCommand) {
            throw new Error('这个类不能被实例化')
        }
        this._receiver = receiver
    }

    // 需要每个指令重写 这个方法
    execute () { }
}

// MenuBar 对应的方法只有一个因此拆分的指令类一个
class RefershMenuBarCommand extends BaseCommand {
    constructor(receiver) {
        super(receiver)
    }
    execute () {
        this.receiver.refresh()
    }
}
// subMenu 有两个方法这里拆成了两个指令类
class AddSubMenuCommand extends BaseCommand {
    constructor(receiver) {
        super(receiver)
    }
    execute () {
        this.receiver.add()
    }
}

class DeleteSubMenuCommand extends BaseCommand {
    constructor(receiver) {
        super(receiver)
    }
    execute () {
        this.receiver.del()
    }
}

// Invoker调用者 将 指令command 和 received 进行匹配
function setCommand (button, command) {
    button.onclick = function () {
        // 统一收口所有指令的调度方法是 被收口是这个方法调用
        command.execute()
    }
}

// 声明指令 ，将指令 和原始对象进行组合
const refershMenuBarCommand = new RefershMenuBarCommand(MenuBar)

setCommand(button1, refershMenuBarCommand)

之前如果没有采用命令模式 出现的问题就是最开始提出的假设让两个人来写，一个人  
负责按钮的绘制工作，一个人负责写这个按钮点击后的具体行为封装到对象中，两个  
人的耦合性较高，负责按钮绘制的人必须等写按钮逻辑的人写完后才能调用按钮  
具体调用的对象，现在站在命令模式的角度来开，绘制按钮的同学不在用关心你  
按钮逻辑的具体写法，具体配合那个对象，因为所有的方法都被拆分为了指令，最后  
的调用都被收口在'execute' 调用，只需要开发按钮逻辑的同学将指令传递到绘制  
同学写的'setCommand ' 即'Invoker' 统一的调用者即可  
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            
            
            
            <div class="reprint1">
                <p>
                    <span class="reprint1-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="http://127.0.0.1/diary" class="b-link-green">车舟慢</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/diary/2021/10/11/diary-20211011-1/" class="b-link-green">Javascript学习</a>
                </p>
            </div>

        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }
	
	/*zs shuai*/
	#vcomments{
		display:none;
	}
	
    /* valine 评论框增加背景图片 */
    #vcomments textarea {
        box-sizing: border-box;
        background: url("") 100% 100% no-repeat;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    /* 修复评论第一行位置错位 */
    .v .vlist .vcard {
    padding-top: 2.5em !important ;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <link rel="stylesheet" type="text/css" href="/libs//libs/jQuery-emoji/dist/css/jquery.emoji.css">
<script src="/libs//libs/jQuery-emoji/dist/js/jquery.emoji.min.js"></script>
<script src="/libs//libs/jQuery-emoji/dist/js/emoji.list.js"></script> -->
<script>
    new Valine({
        el: '#vcomments',
        appId: '2Kc1yifl00dRA6CYQxICVIe4-MdYXbMMI',
        appKey: 'xni6ILbDL2WVE4HDucMuDtx7',
        notify: 'true' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: '',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go ヾﾉ≧∀≦)o ',

    });

//     function parse_emoji() {
//     jQuery(".vcontent").emojiParse({
//       basePath: '/libs/jQuery-emoji/images/emoji',
//       icons: emojiLists   // 注：详见 js/emoji.list.js
//     });
//   }
  
//   setTimeout(function() {
//     // jQuery emoji 解析
//     parse_emoji();
//     // jquery emoji 初始化
//     jQuery(".veditor").emoji({
//       showTab: true,
//       animation: 'slide',
//       basePath: '/libs/jQuery-emoji/images/emoji',
//       icons: emojiLists  // 注：详见 js/emoji.list.js
//     });
//     jQuery(".vmore").on("click", function() {
//       setTimeout(function() {
//         parse_emoji();
//       }, 500);
//     });
//   }, 800)

</script>
    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/diary/2021/10/31/diary-20211031-1/">
                    <div class="card-image">
                        
                        
                        <img src="/diary/medias/featureimages/24.jpg" class="responsive-img" alt="JS树结构操作">
                        
                        <span class="card-title">JS树结构操作</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            树结构操作：  

树结构遍历： 广度优先;深度优先
列表和树结构的互相转换： 列表转树结构；树结构转列表
树结构查找： 节点查找；路径查找
  

树结构介绍js中树结构一般如下：  
let tree = [
  {
    id: '
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-10-31
                        </span>
                        <span class="publish-author">
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/diary/tags/JavaScript/" target="_blank">
                        <span class="chip bg-color">JavaScript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/diary/2021/10/01/diary-20211001-1/">
                    <div class="card-image">
                        
                        
                        <img src="/diary/medias/featureimages/9.jpg" class="responsive-img" alt="纯js关于撤销和回退的实现思路">
                        
                        <span class="card-title">纯js关于撤销和回退的实现思路</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            纯js关于撤销和回退的实现思路(function() {
    var ctor=function(){};
    var inherits=function(parent,protoProps){
        var child;
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-10-01
                            </span>
                        <span class="publish-author">
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/diary/tags/JavaScript/" target="_blank">
                        <span class="chip bg-color">JavaScript</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 车舟慢<br />'
            + '作者: <br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/diary/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


        <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            

            <br>
            <span id="sitetime"></span><span class="my-face">ღゝ◡╹)ノ♡</span>
            <br>

            

            
            <!--
            
			
                &nbsp; | &nbsp;字数统计:&nbsp;
    <span class="white-color">650.5k</span> 字  
			
            
			
			-->

            
            <br>

        </div>

        <div class="col s12 m4 l4 social-link social-statis">

 
    <a href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=617641594@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>






    <a href="http://wpa.qq.com/msgrd?v=3&uin=617641594&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的QQ空间" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>




<!--

    <a href="/diary/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>

--></div>

    </div>
</footer>

<div class="progress-bar"></div>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();

        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */

        var t1 = Date.UTC(2020, 5, 1, 00, 00, 00); //北京时间2019-8-1 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes *
            minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已坚持运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours +
            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒" ;
    } /*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>






        <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>
<script src="/diary/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/diary/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
        <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


        <script src="/diary/libs/materialize/materialize.min.js"></script>
        <script src="/diary/libs/masonry/masonry.pkgd.min.js"></script>
        <script src="/diary/libs/aos/aos.js"></script>
        <script src="/diary/libs/scrollprogress/scrollProgress.min.js"></script>
        <script src="/diary/libs/lightGallery/js/lightgallery-all.min.js"></script>
        <script src="/diary/js/matery.js"></script>

        <!-- Global site tag (gtag.js) - Google Analytics -->



        
            <script src="/diary/libs/others/clicklove.js"></script>
        

        

        
        <script type="text/javascript">
            var OriginTitile = document.title,
                st;
            document.addEventListener("visibilitychange", function () {
                document.hidden ? (document.title = "看不见我🙈~看不见我🙈~", clearTimeout(st)) : (document.title =
                    "(๑•̀ㅂ•́) ✧被发现了～", st = setTimeout(function () {
                        document.title = OriginTitile
                    }, 3e3))
            })
        </script>

       
        

        
        

    
        

    
        

        

        
        

        
        

        
        
            <script type="text/javascript">
            var windowWidth = $(window).width();
            if (windowWidth > 992) {
                document.write('<script type="text/javascript" src="/diary/libs/background/ribbon-dynamic.js"><\/script>');
            }
            </script>
        

    <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>