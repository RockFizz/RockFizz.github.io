<!DOCTYPE HTML>
<html lang="zh-CN">
    


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="J2SE基础, 车舟慢">
    <meta name="baidu-site-verification" content="fmlEuI34ir">
    <meta name="google-site-verification" content="KeoTn_OFy4ndJwXNmm2gMeQfPhd7alqE9vQDwI32KCY">
    <meta name="description" content="1windows的系统环境变量设置：（我以前安装jdk6时是这样将jdk，jre安装在同一级目录下的）  
JAVA_HOME        C:\Program Files\Java\jdk1.6.0_24（jdk安装路径）  
CLAS">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>J2SE基础 | 车舟慢</title>
    <link rel="icon" type="image/png" href="/diary/favicon.png">

    <link rel="stylesheet" type="text/css" href="/diary/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/diary/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/diary/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/diary/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/diary/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/diary/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/diary/css/my.css">
    
    <style type="text/css">
        
    </style>

    <script src="/diary/libs/jquery/jquery-2.2.0.min.js"></script>
    <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>
    
    <script>
        var _hmt = _hmt || [];
        (function () {
            var hm = document.createElement("script");
            hm.src = "https://hm.baidu.com/hm.js?46e79e71af0709a5b9106bf20cecc493";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();
    </script>

    
    
        <script>
            (function(){
                var bp = document.createElement('script');
                var curProtocol = window.location.protocol.split(':')[0];
                if (curProtocol === 'https') {
                    bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
                }
                else {
                    bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                }
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(bp, s);
            })();
        </script>
    

<link rel="stylesheet" href="/diary/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/diary/css/prism-line-numbers.css" type="text/css"></head>

    <body>

        <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/diary/" class="waves-effect waves-light">
                    
                    <img src="/diary/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">车舟慢</span>
                </a>
            </div>
            


<!-- <a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/diary/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/diary/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/diary/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/diary/demo/shuoshuo" class="waves-effect waves-light">
            
            <i class="fa fa-music"></i>
            
            <span>说说</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/diary/galleries" class="waves-effect waves-light">
            
            <i class="fa fa-photo"></i>
            
            <span>相册</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul> -->

<!-- 支持二级菜单特性  -->
<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right nav-menu">
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/diary/" class="waves-effect waves-light">
              
                <i class="fa fa-home"></i>
              
              <span>首页</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/diary/categories" class="waves-effect waves-light">
              
                <i class="fa fa-bookmark"></i>
              
              <span>分类</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/diary/archives" class="waves-effect waves-light">
              
                <i class="fa fa-archive"></i>
              
              <span>归档</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/diary/demo/shuoshuo" class="waves-effect waves-light">
              
                <i class="fa fa-music"></i>
              
              <span>说说</span>
            </a>

            
      </li>
    
      <li class="hide-on-med-and-down nav-item" >

        
            <a href="/diary/galleries" class="waves-effect waves-light">
              
                <i class="fa fa-photo"></i>
              
              <span>相册</span>
            </a>

            
      </li>
    

    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>

</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/diary/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">车舟慢</div>
        <div class="logo-desc">
            
            雁引愁心去，山衔好月来。
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/diary/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/diary/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/diary/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/diary/demo/shuoshuo" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-music"></i>
                
                说说
            </a>
        </li>
        
        <li>
            <a href="/diary/galleries" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-photo"></i>
                
                相册
            </a>
        </li>
        
        
    </ul>

   
   
<!-- 支持二级菜单特性   -->
<!-- <ul class="menu-list mobile-menu-list">
    
        <li class="m-nav-item">
                
                    <a href="/diary/" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-home"></i>
                        
                        首页
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/diary/categories" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-bookmark"></i>
                        
                        分类
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/diary/archives" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-archive"></i>
                        
                        归档
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/diary/demo/shuoshuo" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-music"></i>
                        
                        说说
                    </a>
              
            </li>
        
        <li class="m-nav-item">
                
                    <a href="/diary/galleries" class="waves-effect waves-light">
                        
                        <i class="fa fa-fw fa-photo"></i>
                        
                        相册
                    </a>
              
            </li>
        

        
    </ul> -->

</div>

        </div>

        
    </nav>

</header>

        
<script src="/diary/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/diary/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/diary/medias/featureimages/0.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        J2SE基础
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/diary/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/diary/tags/Java/" target="_blank">
                                <span class="chip bg-color">Java</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>
            
            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2021-02-01
                </div>

                <div class="post-author info-break-policy">
                    <i class="fa fa-user-o fa-fw"></i>作者:&nbsp;&nbsp;
                    
                        sean
                    
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        10.3k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        42 分
                    </div>
                    
                
                
                

            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>windows的系统环境变量设置：（我以前安装jdk6时是这样将jdk，jre安装在同一级目录下的）  </p>
<pre><code>JAVA_HOME        C:\Program Files\Java\jdk1.6.0_24（jdk安装路径）  
CLASSPATH        添加%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar  
path            添加%JAVA_HOME%\bin和%JAVA_HOME%\jre\bin  

(JDK8或者JDK1.8是由于自从JDK1.5/JDK5命名方式改变后遗留的历史问题。所以JDK8或者JDK1.8是等价的)
这里有个Tip，现在安装的jdk8版本，经实践发现系统变量里有CLASSPATH会导致命令行java运行程序是报错(错误: 找不到或无法加载主类)  
删除classpath变量后，运行正常。  
经测试，JDK8下删除classpath变量后也不影响Unity3d打包安卓apk输出。  
</code></pre><p>java源文件文件名必须和文件内定义class的类名（大小写也要相同）相同。main方法是程序的入口。  </p>
<pre><code>//HelloJava.java  

public class HelloJava{
    public static void main(String[] args){
        System.out.println("Hello world");
    }
}</code></pre><p>java源文件执行前得先编译。编译结束生成HelloJava.class  </p>
<pre><code>javac HelloJava.java  </code></pre><p>执行java程序  </p>
<pre><code>java HelloJava</code></pre><p>上面这个例子是源文件不带package包的，运行时cmd跳转到源文件当前目录即可执行。<br>下面这个例子是源文件带package包的，定义包结构要放在有效代码的第一行。<br>执行时要跳到package包文件的前一个目录，此例是cmd跳转到src目录。  </p>
<pre><code>├──src  
│    └──myproject  
│        └──hello  
│            └──HelloJava.java  

//HelloJava.java  
package myproject.hello;
/**
 * &lt;p&gt;ProjectName: ABC &lt;/p&gt; 
 * &lt;p&gt;FileName: ABC &lt;/p&gt; 
 * &lt;p&gt;Describe: ************ &lt;/p&gt;
 * &lt;p&gt;CreateDate: 2020-02-02 &lt;/p&gt;
 * &lt;p&gt;Company: ************company*********department&lt;/p&gt; 
 * @author author1
 * @version v1.0
 */
public class HelloJava{
    public static void main(String[] args){
        System.out.println("Hello world");
    }

    /**
    * @param a canshu1 
    * @param b canshu2 
    * @return FanHuiLiangShuZhiHe 
    */    
    public int add(int a,int b){
        return a+b;
    }
}</code></pre><p>执行前先编译，cmd跳转到HelloJava.java源代码所在目录（此例是hello目录）</p>
<pre><code>javac HelloJava.java  </code></pre><p>执行时，cmd跳转到src目录,带完整包名执行  </p>
<pre><code>java myproject.hello.HelloJava  </code></pre><p>注释  </p>
<pre><code>单行注释 //......  
多行注释 /* .......*/  
文档注释  
/**  
........&lt;p&gt;(换行标签) 
*/  
文档注释一般写在类定义之前，方法之前，属性之前。  
用javadoc命令可以根据原码中的文档注释生成注释文档（html格式）。文档注释中可以使用html标签。  
javadoc -d 路径 （指定注释文档的保存路径）  
上例中，目录跳转到src/myproject/hello/下执行  
javadoc HelloJava.java -d E:\ChromeDN\1  </code></pre><p><font color="red">如果CMD运行JAVA出现错误：编码GBK的不可映射字符</font><br>一般可能字符编码中文不对造成，cmd运行java系统默认gbk编码。有以下两种方式修正。  </p>
<ul>
<li>
方法1：用编辑器(例如notepad++)打开源代码，全选，复制，用编辑器菜单将编码转为ANSI编码，设置好后删除，粘贴，保存。
</li>
<li>
方法2：编译时为javac添加-encoding指定文件编码。
</li>
</ul>  

<pre><code>javac xxx.java -encoding UTF-8</code></pre><p>在类中定义的方法在返回值前加上static修饰符就可以在main方法中调用了。<br>如果不用static那就需要在main方法中创建对象，使用对象来调用对象的方法。  </p>
<pre><code>public class Test{
    public static void main(String[] args){
        Test t=new Test()；
        int b=1；
        int c=2；
        int[] a=new int[10]；
        t.sqort(a)；
        add(b,c)
    }
    public int[] sqort(int[] a){
        .......
    }
    static int add(b,c){
        .......
    }
}</code></pre><p>一个Java源代码文件就是一个编译单元，每个编译单元最多只能有一个public类，否则编译器就不会接受。<br>如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为他们不是public类，而且他们主要用来为主要public类提供支持。<br>虽然不是很常用，但编译单元内完全不带public类也是可能的。这种情况下，可以随意对文件命名。  </p>
<p>一个.java文件，可以有多个类，但是文件名只能有一个，用哪一个类名来充当文件名呢？其实文件名是无所谓的，因为将来用javac进行编译的时候后，最终会生成多个.class文件，每一个类对应个.class文件。运行时只要运行对应的.class文件就可以了，这时.java文件就显得没什么用了(运行时不需要)，那还管它叫什么名字。  </p>
<ul>
<li>1.Java保存的文件名必须与类名一致；</li>
<li>2.如果文件中只有一个类，文件名必须与类名一致；</li>
<li>3.一个Java文件中只能有一个public类；</li>
<li>4.如果文件中不止一个类，文件名必须与public类名一致；</li>
<li>5.如果文件中不止一个类，而且没有public类，文件名可与任一类名一致。</li>
</ul>  

<p>main方法只是程序的一个入口，所谓”一个程序只能有一个入口”，好象是在说只能有一个main方法，其实，只要你高兴，就可以在所有类里都写上main方法，给程序提供N多个入口，但是最后你运行程序的时候也只能从其中的一个入口进去，这就是main的作用(程序入口)。这也就是为什么你会发现，程序员在做单元测试时，会往自己做的很多类里面添加main方法，因为他要为自己做的东西添加运行入口，从而能方便测试。  </p>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>Java基本构成</p>
<ul>
<li>类(class):类名需与.java文件名相同</li>
<li>方法(method):例如类内定义方法main</li>
<li>语句statement：例如System.out.println("Hello World!");  <p>
语句以分号;结尾，用大括号{}整合语句形成程序块，通过程序块得知程序不同的范围，比如类从何开始在哪结束。  </p></li>
</ul>  

<p>类存在于源文件.java里，方法存在于类里，语句存在于方法里。  </p>
<p>类、方法和变量的命名只能以字符、“_”或“$”开头，类名首字母大写，方法和变量首字母小写，无长度限制。<br>goto和const在java中虽然不再使用但是还作为关键字存在<br>java中没有sizeof这个关键字了，java中的boolean类型的值只能用true和false，且这两值也是关键字。<br>java语言中没有无符号这个关键字（unsigned）  </p>
<p>数据类型：<br>bit就是位，也叫比特位，是计算机表示数据最小的单位<br>byte就是字节，1byte=8bit，一般用两个16进制显示。  </p>
<pre><code>byte[] bs = {(byte)0xff, 0x0F, 0x1F, 0x2F, 0x3F, 0x4F, 0x5F, 0x6F};
for(int i=0;i&lt;bs.length;i++){
    int tempI=(int)(bs[i]&amp;0xff);
    String temp16=Integer.toHexString(tempI);
}</code></pre><p>Java基本类型共有八种，可分为三类:字符类型char，布尔类型boolean以及数值类型byte、short、int、long、float、double。<br>数值类型又可以分为整数类型byte、short、int、long和浮点数类型float、double。  </p>
<ul>
<li>byte：8位，最大存储数据量是255，存放的数据范围是-128~127之间。</li>
<li>short：16位，最大数据存储量是65536，数据范围是-32768~32767之间。</li>
<li>int：32位，最大数据存储容量是2的32次方减1，数据范围是负的2的31次方到正的2的31次方减1。</li>
<li>long：64位，最大数据存储容量是2的64次方减1，数据范围为负的2的63次方到正的2的63次方减1。</li>
<li>float：32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。</li>
<li>double：64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。</li>
<li>boolean：只有true和false两个取值。</li>
<li>char：16位，存储Unicode码，用单引号赋值。</li>
</ul>  
"e+数字"表示E之前的数字要乘以10的多少倍。比如3.14E3就是3.14×1000=3140，3.14E-3就是3.14/1000=0.00314。
基本类型的优势：数据存储相对简单，运算效率比较高  
包装类的优势：有的容易，比如集合的元素必须是对象类型，满足了java一切皆是对象的思想  

<p>所有基本数据类型在使用时会事先分配空间，在传递时，就是值传递(复制传递)，不是引用传递。  </p>
<p>Java中的常量  </p>
<ul>
<li>十六进制整型常量：以十六进制表示时，需以0x或0X开头，如0xff,0X9A。</li>
<li>八进制整型常量：八进制必须以0开头，如0123，034。</li>
<li>长整型：长整型必须以L作结尾，如9L,342L。</li>
<li>浮点数常量：由于小数常量的默认类型是double型，所以float类型的后面一定要加f(F)。同样带小数的变量默认为double类型。</li>
<li>字符常量：字符型常量需用两个单引号括起来（注意字符串常量是用两个双引号括起来）。Java中的字符占两个字节。</li>
</ul>

<p>简单类型数据间的转换<br>1.自动转换：<br>当一个较”小”数据与一个较”大”的数据一起运算时,系统将自动将”小”数据转换成”大”数据,再进行运算。而在方法调用时,实际参数较”小”,而被调用的方法的形式参数数据又较”大”时(若有匹配的,当然会直接调用匹配的方法),系统也将自动将”小”数据转换成”大”数据,再进行方法的调用,自然,对于多个同名的重载方法,会转换成最”接近”的”大”数据并进行调用。<br>类型由”小”到”大”分别为(byte，short，char)–int–long–float—double。<br>这里我们所说的”大”与”小”,并不是指占用字节的多少,而是指表示值的范围的大小。  </p>
<pre><code>byte b;  
int i=b;  
long l=b;  
float f=b;  
double d=b;  
上面这些语句没问题。  

如果低级类型为char型，向高级类型（整型）转换时，会转换为对应ASCII码值，例如  
char c='c';  
int i=c;  
System.out.println("output:"+i);  
输出：output:99;  

对于byte,short,char三种类型而言，他们是平级的，因此不能相互自动转换，可以使用下述的强制类型转换  
short i=99;
char c=(char)i;  
System.out.println("output:"+c);  
输出：output:c;  </code></pre><p>2.强制转换：<br>将”大”数据转换为”小”数据时，你可以使用强制类型转换。即你必须采用下面这种语句格式：<br>int n=(int)3.14159/2;<br>可以想象，这种转换肯定可能会导致溢出或精度的下降。  </p>
<p>关于数据类型的自动提升，注意下面的规则。  </p>
<ul>
<li>所有的byte,short,char型的值将被提升为int型；</li>
<li>如果有一个操作数是long型，计算结果是long型；</li>
<li>如果有一个操作数是float型，计算结果是float型；</li>
<li>如果有一个操作数是double型，计算结果是double型；</li>
</ul>  

<p>3.包装类转换  </p>
<pre><code>简单类型的变量转换为相应的包装类，可以利用包装类的构造函数。即：  
Boolean(boolean value)、  
Character(char value)、  
Integer(int value)、  
Long(long value)、  
Float(float value)、  
Double(double value)  
在各个包装类中，总有形为××Value()的方法，来得到其对应的简单类型数据。利用这种方法，也可以实现不同数值型变量间的转换。  


当希望把float型转换为double型时：  
float f1=100.00f;  
Float F1=new Float(f1);  
double d1=F1.doubleValue();  
//doubleValue()为Float类的返回double值型的方法  

当希望把double型转换为int型时：  
double d1=100.00;  
Double D1=new Double(d1);  
int i1=D1.intValue();  

其它类型向字符串的转换:  
1.调用类的串转换方法:X.toString();  
2.通过X+""，自动转换。  

字符串作为值,向其它类型的转换:  
1.先转换成相应的封装器实例,再调用对应的方法转换成其它类型:如下  
字符中"32.1"转换double型的值的格式为:new Float("32.1").doubleValue()。  
2.静态parseXXX方法：  
String s = "1";  
byte b = Byte.parseByte(s);  
short t = Short.parseShort(s);  
int i = Integer.parseInt(s);  
long l = Long.parseLong(s);  
Float f = Float.parseFloat(s);  
Double d = Double.parseDouble(s);  

日期时间的Date类与其它数据类型的相互转换:  
Date(int year, int month, int date)：                                以int型表示年、月、日  
Date(int year, int month, int date, int hrs, int min)：                以int型表示年、月、日、时、分  
Date(int year, int month, int date, int hrs, int min, int sec)：    以int型表示年、月、日、时、分、秒
</code></pre><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>Java有五种引用类型：类、接口、数组、枚举、标注。  </p>
<p><font color="red">为测试方便，将类放在同一个目录下，不用package导包也能识别。</font>  </p>
<pre><code>//类  

//Phone.java  
public class Phone {
    /*
     * 属性
     */
    String brand;  
    String color;  
    double size;  
}
//Test.java  
public class Test{  
    public static void main(String[] args){  
        Phone p=new Phone();  
        p.brand="Mate30Pro";  
        p.color="黑色";  
        p.size=5.5;  
        System.out.println("手机品牌:"+p.brand);  
        System.out.println("手机颜色:"+p.color);  
        System.out.println("手机品牌:"+p.size);  
    }  
}

Phone.java和Test.java两个文件放在同一个目录下，cmd进入这个目录编译  
javac Test.java -encoding UTF-8  
会自动生成Test.class和Phone.class。  
运行程序执行java Test  
</code></pre><p>抽象类提供了继承的概念，它的出发点就是为了继承，否则它没有存在的任何意义。所以说定义的抽象类一定是用来继承的。  </p>
<ul>
<li>抽象类不能被实例化，实例化的工作应该交由它的子类来完成，它只需要有一个引用即可</li>
<li>抽象方法必须由子类来进行重写</li>
<li>只要包含一个抽象方法的抽象类，该方法必须要定义成抽象类，不管是否还包含有其他方法</li>
<li>抽象类中可以包含具体的方法，当然也可以不包含抽象方法</li>
<li>子类中的抽象方法不能与父类的抽象方法同名</li>
<li>abstract不能与final并列修饰同一个类</li>
<li>abstract不能与private、static、final或native并列修饰同一个方法</li>
</ul>


<pre><code>定义一个抽象动物类Animal，提供抽象方法叫cry()，猫、狗都是动物类的子类。  
由于cry()为抽象方法，所以Cat、Dog必须要实现cry()方法。  

├──测试目录  
    └──Animal.java  
    └──Cat.java  
    └──Dog.java  
    └──TestAb.java  

//Animal.java  
public abstract class Animal {
    public abstract void cry();
}  
//Cat.java  
public class Cat extends Animal{
    @Override
    public void cry() {
        System.out.println("猫叫：喵喵...");
    }
}  
//Dog.java  
public class Dog extends Animal{
    @Override
    public void cry() {
        System.out.println("狗叫:汪汪...");
    }
}  
//TestAb.java  
public class TestAb {
    public static void main(String[] args) {
        Animal a1 = new Cat();
        Animal a2 = new Dog();        
        a1.cry();
        a2.cry();
    }
}  </code></pre><p>接口是用来建立类与类之间的协议，接口本身不是类，不能实例化，只能实例化实现接口的类。<br>抽象类就是用来继承的，java的继承只能有一个父类，但接口不同，一个类可以同时实现多个接口。<br>接口弥补了java抽象类不能多重继承的缺陷。  </p>
<ul>
<li>接口内方法访问权限自动被声明为public。确切的说只能为public，当然你可以显示的声明为protected、private，但是编译会出错！</li>
<li>接口中可以定义“成员变量”，或者说是不可变的常量，因为接口中的“成员变量”会自动变为为public static final。可以通过类命名直接访问：ImplementClass.name。</li>
<li>接口中不存在实现的方法</li>
<li><font color="red">实现接口的非抽象类</font>必须要实现该接口的所有方法。<font color="red">实现接口的抽象类</font>可以不用实现接口的方法</li>
<li>不能使用new操作符实例化一个接口，但可以声明一个接口变量，该变量必须引用一个实现该接口的类的对象。可以使用 instanceof 检查一个对象是否实现了某个特定的接口。例如：if(anObject instanceof Comparable){}。</li>
<li>在实现多接口的时候一定要避免方法名的重复</li>
</ul>  


<p>抽象类可以拥有任意范围的成员数据，同时也可以拥有自己的非抽象方法。但是接口方式中，它仅能够有静态、不能修改的成员数据，同时它所有的方法都必须是抽象的。<br>对子类而言，它只能继承一个抽象类（这是java为了数据安全而考虑的），但是却可以实现多个接口。  </p>
<pre><code>//抽象类  
public abstract class Demo {
    abstract void method1();    
    void method2(){
        //实现
    }
}
public class DemoAbs extends Demo{
    void method1(){
        //实现
    }
}

//接口  
interface IDemo {
    void method1();
    void method2();
}
public class DemoInt implements IDemo{
    void method1(){
        //实现
    }  
    void method2(){
        //实现
    }
}
</code></pre><p>抽象类是对类抽象，跨域的是具有相似特点的类。(从子类中发现公共部分，然后泛化成抽象类，子类继承该父类即可)<br>而接口是对行为的抽象。实现接口的类之间可以没有任何相同点，仅仅是相同行为的契约。<br>抽象类自下而上设计，需要知道子类才能抽象出父类，而接口不同，接口根本不需要知道子类的存在，只需定义行为规则即可。接口自顶向下设计。  </p>
<p>类是对象的抽象，而对象是类的具体实例。类是抽象的，不占用内存，而对象是具体的，占用存储空间。类是用于创建对象的蓝图，它是一个定义包括在特定类型的对象中的方法和变量的软件模板。  </p>
<p>Java中，类的实例化方法一共有四种途径:  </p>
<ul>
<li>(1)使用new操作符</li>
<li>(2)调用Class对象的newInstance()方法</li>
<li>(3)调用clone()方法，对现有实例的拷贝</li>
<li>(4)通过ObjectInputStream的readObject()方法反序列化类</li>
</ul>  

<pre><code>//new是创造，点.是使用。  

//java.lang.Class  

String str = “ABCDEFG” ; //创建一个字符串  
Class t = Class.forName(str); //获取到str这个变量的类 相当于String t  
t.newInstance(); // 相当于 t = new String 
</code></pre><p>Object类的clone()方法是Object类的一个native方法。<br>new出来的对象的属性都还是初始化时候的值，所以当需要一个新的对象来保存当前对象的“状态”就靠克隆方法clone()了。  </p>
<p>拷贝的前提：实现一个Cloneable接口，该接口只是一个标记接口，里面并没有具体的方法。<br>实现Cloneable接口的方式：实现Cloneable接口并重写Object类中的clone()方法。  </p>
<pre><code>//Worker.java
//克隆的对象必须实现Cloneable这个接口，而且需要重写clone方法  

class Worker implements Cloneable{
    private String name;

    public Worker(String name) {
        super();
        this.name = name;
    }

    public Worker() {
        super();
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "Worker [name=" + name + "]";
    }
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

}

//Test.java
public class TestAb {

    public static void main(String[] args) throws Exception {
        Worker worker1 = new Worker("张三");
        Worker worker2 = (Worker) worker1.clone();
        System.out.println(worker1.toString());
        System.out.println(worker2.toString());
        System.out.println("==============");
        //克隆后得到的是一个新的对象，所以重新写的是student2这个对象的值
        worker2.setName("李四");
        System.out.println(worker1.toString());
        System.out.println(worker2.toString());
    }
}

运行结果：
Worker [name=张三]
Worker [name=张三]
==============
Worker [name=张三]
Worker [name=李四]
</code></pre><p>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。类的clone方法默认对引用类型的成员变量是浅拷贝(浅复制)。<br>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。<br>深拷贝(深复制)的实现方式有以下两种：  </p>
<p>方式一：手动依次实现对应引用类型变量的clone()方法  </p>
<pre><code>//克隆的对象必须实现Cloneable这个接口，而且需要重写clone方法
class Worker3 implements Cloneable{
    private String name;

    private Address3 addr;


    public Worker3(String name, Address3 addr) {
        super();
        this.name = name;
        this.addr = addr;
    }

    public Worker3() {
        super();
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }


    public Address3 getAddr() {
        return addr;
    }

    public void setAddr(Address3 addr) {
        this.addr = addr;
    }



    @Override
    public String toString() {
        return "Worker3 [name=" + name + ", addr=" + addr + "]";
    }

//    @Override
//    protected Object clone() throws CloneNotSupportedException {
//
//        Worker3 worker3 = (Worker3) super.clone();   //浅复制
//
//        Address3 addr3 = (Address3) worker3.getAddr().clone(); //深复制
//
//        worker3.setAddr(addr3);
//
//        return worker3;
//    }

    @Override
    protected Object clone() throws CloneNotSupportedException {

        Worker3 worker3 = null;

        worker3 = (Worker3) super.clone();   //浅复制

        //worker3.addr = (Address3) worker3.getAddr().clone(); //深复制
        worker3.addr = (Address3) addr.clone(); //深复制

        return worker3;
    }



}

class Address3 implements Cloneable{
    private String city;


    public Address3() {
        super();
    }

    public Address3(String city) {
        super();
        this.city = city;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    @Override
    public String toString() {
        return "Address3 [city=" + city + "]";
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

}
//主方法
public static void main(String[] args) throws Exception {

        Address3 addr = new Address3("北京");
        Worker3 worker1 = new Worker3("张三", addr);

        Worker3 worker2 = (Worker3) worker1.clone();

        System.out.println(worker1.toString());
        System.out.println(worker2.toString());

        System.out.println("==============");
        //克隆后得到的是一个新的对象，所以重新写的是worker2这个对象的值
        worker2.setName("李四");

        addr.setCity("上海");

        System.out.println(worker1.toString());
        System.out.println(worker2.toString());

    }

 运行结果：
Worker3 [name=张三, addr=Address3 [city=北京]]
Worker3 [name=张三, addr=Address3 [city=北京]]
==============
Worker3 [name=张三, addr=Address3 [city=上海]]
Worker3 [name=李四, addr=Address3 [city=北京]]</code></pre><p>方式二：实现 Serializable 接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。  </p>
<pre><code>class Student implements Serializable {

    private static final long serialVersionUID = 1L;

    private int age;
    private String name;
    private Teacher teacher;

    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Teacher getTeacher() {
        return teacher;
    }
    public void setTeacher(Teacher teacher) {
        this.teacher = teacher;
    }
    @Override
    public String toString() {
        return "Student [age=" + age + ", name=" + name + ", teacher=" + teacher + "]";
    }

    //使得序列化student3的时候也会将teacher序列化
    public Object deepCopt()throws Exception {

        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        ObjectOutputStream  oos = new ObjectOutputStream(bos);
        oos.writeObject(this);
        //将当前这个对象写到一个输出流当中，，因为这个对象的类实现了Serializable这个接口，所以在这个类中
        //有一个引用，这个引用如果实现了序列化，那么这个也会写到这个输出流当中

        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bis);
        return ois.readObject();
        //这个就是将流中的东西读出类，读到一个对象流当中，这样就可以返回这两个对象的东西，实现深克隆
    }

}

class Teacher implements Serializable {

    private int age;
    private String name;

    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    @Override
    public String toString() {
        return "Teacher [age=" + age + ", name=" + name + "]";
    }

}
//主方法
public static void main(String[] args) throws Exception {
        Teacher t1 = new Teacher();
        t1.setAge(33);
        t1.setName("王老师");

        Student stu1 = new Student();
        stu1.setAge(22);
        stu1.setName("张三");
        stu1.setTeacher(t1);

        Student stu2 = (Student) stu1.deepCopt();
        System.out.println(stu1);
        System.out.println(stu2);

        System.out.println("===============");

        stu2.getTeacher().setAge(44);
        stu2.getTeacher().setName("李老师");

        stu2.setAge(23);
        stu2.setName("李四");

        System.out.println(stu1);
        System.out.println(stu2);

    }

运行结果：
Student [age=22, name=张三, teacher=Teacher [age=33, name=王老师]]
Student [age=22, name=张三, teacher=Teacher [age=33, name=王老师]]
===============
Student [age=22, name=张三, teacher=Teacher [age=33, name=王老师]]
Student [age=23, name=李四, teacher=Teacher [age=44, name=李老师]]</code></pre><p>将对象克隆封装成一个工具类  </p>
<pre><code>import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

public class CloneUtil {

    @SuppressWarnings("unchecked")
    public static &lt;T extends Serializable&gt; T clone(T object) throws Exception{
        //写入字节流
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        ObjectOutputStream oos = new ObjectOutputStream(bout);
        oos.writeObject(object);

        //分配内存，写入原始对象，生成新对象
        ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bin);
        // 此处不需要释放资源，说明：调用ByteArrayInputStream或ByteArrayOutputStream对象的close方法没有任何意义
        // 这两个基于内存的流只要垃圾回收器清理对象就能够释放资源，这一点不同于对外部资源（如文件流）的释放
        return (T) ois.readObject();
    }
}</code></pre><p>java数组声明定义有两种。  </p>
<pre><code>type arrayName[];  
type[] arrayName;  
type为Java中的任意数据类型，包括基本类型和组bai合类型  
arrayName为数组名，[ ] 指明该变量是一个数组类型变量  

两种形式没有区别，使用效果完全一样，  
Java在定义数组时并不为数组元素分配内存，因此[]中无需指定数组元素的个数，即数组长度。  
对于如上定义的一个数组是不能访问它的任何元素的，必须要为它分配内存空间，这时要用到运算符new  

arrayName=new type[arraySize];  
其中，arraySize为数组的长度，type为数组的类型。  
demoArray=new int[3];  
//为一个整型数组分配3个int型整数所占据的内存空间。  
</code></pre><p>Java数组初始化可以在声明数组的同时进行初始化（静态初始化），也可以在声明以后进行初始化（动态初始化）。  </p>
<pre><code>//静态初始化，声明同时就为数组元素分配空间并赋值  
int intArray[] = {1,2,3,4};  
String stringArray[] = {"zhidao", "baidu", "百度知道"};  
//动态初始化，声明以后进行初始化  
float floatArray[] = new float[3];  
floatArray[0] = 1.0f;  
floatArray[1] = 132.63f;  
floatArray[2] = 100F;  
</code></pre><p>Java数组的使用  </p>
<pre><code>int intArray[] = new int[5];  
int len = intArray.length;  
for(int i=0; i&lt;len; i++){
    intArray[i] = i;
}
long total=0;
for(int i=0; i&lt;len; i++){
    total += intArray[i];
}</code></pre><p>枚举类不能多重继承，可以实现接口。  </p>
<p>简单枚举  </p>
<pre><code>/**
 * 简单枚举
 */
enum Fruit{
    APPLE,ORANGE,BANANA
}
public static void main(String[] args) throws Exception{
    //测试简单枚举
    LOGGER.info("获取一个枚举值" + Fruit.APPLE.getClass().toString() + " : " + Fruit.APPLE);
    //通过Fruit.values()获取枚举值数组
    for (Fruit fruit : Fruit.values()) {
        LOGGER.info("遍历枚举--" + fruit.getClass().toString() + " : " + fruit);
    }
}</code></pre><p>自定义枚举  </p>
<pre><code>/**
 * 自定义枚举
 */
public enum CodeAndMessage {
    /**
     * 设置枚举值，注意与后面的field字段对应
     */
      SUCCESS(1,"成功"),
      WARNING(0,"警告"),
      ERROR(-1,"报错");

    private int code;
    private String message;

    @Override  
    public String toString() {  
        return this.name() + "(" + this.code + "," + this.message + ")";
    }

    /**
     * 根据code获取message
     * @param code
     * @return
     */
    public static String getMessage(int code){
        //通过enum.values()获取所有的枚举值
        for(CodeAndMessage codeAndMessage : CodeAndMessage.values()){
            //通过enum.get获取字段值
            if(codeAndMessage.getCode() == code){
                return codeAndMessage.message;
            }
        }
        return null;
    }

    /**
     * 根据code获取CodeAndMessage
     * @param code
     * @return
     */
    public static CodeAndMessage getCodeAndMessage(int code){
        for(CodeAndMessage codeAndMessage : CodeAndMessage.values()){
            if(codeAndMessage.getCode() == code){
                return codeAndMessage;
            }
        }
        return null;
    }

    private CodeAndMessage(int code, String message) {
        this.code = code;
        this.message = message;
    }

    // setter and getter
}

public static void main(String[] args) throws Exception{
    //测试自定义枚举
    System.out.println();
    LOGGER.info("测试自定义枚举");
    LOGGER.info("获取一个枚举值" + CodeAndMessage.SUCCESS.getClass().toString() + " : " + CodeAndMessage.SUCCESS);
    //通过CodeAndMessage.values()获取枚举值数组
    for (CodeAndMessage codeAndMessage : CodeAndMessage.values()) {
        LOGGER.info("遍历枚举--" + codeAndMessage.getClass().toString() + " : " + codeAndMessage);
    }
    //通过code获取message
    LOGGER.info("通过code获取message: " + CodeAndMessage.getMessage(1));
    //通过code获取枚举对象CodeAndMessage
    LOGGER.info("通过code获取枚举对象CodeAndMessage: " + CodeAndMessage.getCodeAndMessage(-1));
    //通过枚举值获取枚举对象
    LOGGER.info("通过enum.valueOf(name)获取枚举对象: " + CodeAndMessage.valueOf("SUCCESS"));
    LOGGER.info("通过Enum.valueOf(enumClass,name)获取枚举对象: " + Enum.valueOf(CodeAndMessage.class, "SUCCESS"));
}</code></pre><ul>
<li>通过enum.values()获取枚举数组。</li>
<li>通过enum.valueOf(name)获取枚举对象。</li>
<li>通过Enum.valueOf(enumClass,name)获取枚举对象。</li>
<li>设置枚举值其实调用的是全参数的构造函数。</li>
<li>建议重写toString()方法，以便打印信息。</li>
<li>建议手动编写根据某个字段获取枚举值的方法。</li>
</ul>  

<p>标注，也叫注解、元数据。是jdk1.5后产生的一个特性，与类、接口、枚举同一个档次，他可以在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明、注释；  </p>
<p>注解分类  </p>
<ul>
<li>编写文档：通过代码里的标识的注解生成文档（生成word文档）</li>
<li>编译检查：通过代码里的标识的注解让编译器能够实现基本的编译检查</li>
<li>代码分析：通过代码里标识的注解对代码进行分析（使用反射）[重点] </li>
</ul>

<p>JDK内置注解  </p>
<ul>
<li>@Deprecated:用来修饰已经过时的方法。编译期注解，提示该方法或者该成员变量已经过期，不建议使用，但是还是能使用的,能用到（类、变量、方法）</li>
<li>@Override：用来修饰此方法重写了父类的方法 只能在方法上</li>
<li>@SuppressWarnings:用来通知java编译器禁止特定的编译警告</li>
</ul>  

<p>自定义注解，通过@interface 关键字进行定义  </p>
<pre><code>public @interface 注解名称{
​
}

public @interface TestA {
    //这里定义了一个空的注解，它能干什么呢。我也不知道，但他能用。
}
然后使用这个注解  

@TestA    //使用了类注解
public class UserAnnotation {

    @TestA //使用了类成员注解
    private Integer age;

    @TestA //使用了构造方法注解
    public UserAnnotation(){

    }
    @TestA //使用了类方法注解
    public void a(){
        @TestA //使用了局部变量注解
        Map m = new HashMap(0);
    }

    public void b(@TestA Integer a){ //使用了方法参数注解

    }
}</code></pre><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其他的注解上面。<br>元注解有@Retention、@Documented、@Target、@Inherited、@Repeatable这5个,两个类型一样的注解不能同时用<br>四大元注解分别是：</p>
<ul>
<li>@Target表示该注解用于什么地方，可能的值在枚举类 ElemenetType 中</li>
<li>@Retention表示在什么级别保存该注解信息</li>
<li>@Documented将此注解包含在 javadoc 中，它代表着此注解会被javadoc工具提取成文档。</li>
<li>@Inherited允许子类继承父类中的注解</li>
</ul>  

<p>@Target指定注解运用的地方，ElementType是枚举类。  </p>
<ul>
<li>ElementType.ANNOTATION_TYPE：可以给注解进行注释</li>
<li>ElementType.CONSTRUCTOR：可以给构造方法注解</li>
<li>ElementType.FIELD：可以给属性进行注解</li>
<li>ElementType.LOCAL_VARIABLE：可以给局部变量进行注解</li>
<li>ElementType.METHOD：可以给方法进行注解不能用在构造方法上</li>
<li>ElementType.PACKAGE：可以给包进行注解</li>
<li>ElementType.PARAMETER：可以给一个方法内的参数进行注解</li>
<li>ElementType.TYPE：可以给一个类型进行注解，比如类、接口、枚举</li>
</ul>  


<p>Retention意思是保留期的意思，当@Retention应用到一个注解上的时候，它解释说明了这个注解的存活时间，表示在什么级别保存该注解信息。可选的参数值在枚举类型 RetentionPolicy中  </p>
<ul>
<li>RetentionPolicy.SOURCE:注解只在源代码阶段博保留，在编译器进行编译时将会被丢弃忽视</li>
<li>RetentionPolicy.CLASS:只被保留在编译进行的时候，并不会加载到JVM中</li>
<li>RetentionPolicy.RUNTIME:可以保留到程序运行时，它会被加载到JVM中，所以可以获取到他们</li>
</ul>  

<pre><code>@Retention(RetentionPolicy.RUNTIME)//定义一个运行期有效的注解
public @interface MyAnnotation {
}</code></pre><pre><code>//该注解可在 类 接口、枚举、方法、成员变量使用
@Target({ElementType.TYPE,ElementType.FIELD,ElementType.METHOD})  
public @interface MyAnnotation {
}


@MyAnnotation
public class Student {
    @MyAnnotation
    int age;
    @MyAnnotation
    public void test() {
    }
}</code></pre><p>@Inherited表示该注解能被子类使用（继承）<br>注解MyAnnotation被@Inherited修饰，如果有个类A使用了@MyAnnotation注解，又有一个子类b继承了A，在b中也能使用@MyAnnotation注解  </p>
<p>@Documented和文档有关，能将注解中的元素包含到Javadoc中。<br>在需要对同一个注解多次使用在一个类、接口、方法、属性等上面的时候，需要用@Repeatable  </p>
<p>注解的属性也叫成员变量，注解中只有成员变量，无成员方法  </p>
<p>注解的成员变量在注解的定义以无参数的方法的形式来声明。其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型  </p>
<p>@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。  </p>
<pre><code>@Target({TYPE,METHOD,FIELD,CONSTRUCTOR})
@Retention(RetentionPolicy.RUNTIME)
public @interface TestA {
    String name();
    int id() default 0;
    Class gid();
}  

使用这个注解

package com.tmser.annotation;
import java.util.HashMap;
import java.util.Map;

@TestA(name="type",gid=Long.class) //类成员注解
public class UserAnnotation {
@TestA(name="param",id=1,gid=Long.class) //类成员注解
private Integer age;
@TestA (name="construct",id=2,gid=Long.class)//构造方法注解
public UserAnnotation(){
}
@TestA(name="public method",id=3,gid=Long.class) //类方法注解
public void a(){
Map m = new HashMap(0);
}
@TestA(name="protected method",id=4,gid=Long.class) //类方法注解
protected void b(){
Map m = new HashMap(0);
}
@TestA(name="private method",id=5,gid=Long.class) //类方法注解
private void c(){
Map m = new HashMap(0);
}
public void b(Integer a){ 
}
}  


读取我们在类中定义的注解  
package com.tmser.annotation;
import java.lang.annotation.Annotation;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
public class ParseAnnotation {

public static void parseTypeAnnotation() throws ClassNotFoundException {  
        Class clazz = Class.forName("com.tmser.annotation.UserAnnotation"); 

        Annotation[] annotations = clazz.getAnnotations();  
        for (Annotation annotation : annotations) {  
        TestA testA = (TestA)annotation;
            System.out.println("id= ""+testA.id()+""; name= ""+testA.name()+""; gid = "+testA.gid());  
        }  
    } 

public static void parseMethodAnnotation(){
Method[] methods = UserAnnotation.class.getDeclaredMethods();  
        for (Method method : methods) {  

            boolean hasAnnotation = method.isAnnotationPresent(TestA.class);  
            if (hasAnnotation) {  

            TestA annotation = method.getAnnotation(TestA.class);  
                System.out.println("method = " + method.getName()  
                        + " ; id = " + annotation.id() + " ; description = "  
                        + annotation.name() + "; gid= "+annotation.gid());  
            }  
        }  
}

public static void parseConstructAnnotation(){
Constructor[] constructors = UserAnnotation.class.getConstructors();  
        for (Constructor constructor : constructors) { 

            boolean hasAnnotation = constructor.isAnnotationPresent(TestA.class);  
            if (hasAnnotation) {  

            TestA annotation =(TestA) constructor.getAnnotation(TestA.class);  
                System.out.println("constructor = " + constructor.getName()  
                        + " ; id = " + annotation.id() + " ; description = "  
                        + annotation.name() + "; gid= "+annotation.gid());  
            }  
        }  
}
public static void main(String[] args) throws ClassNotFoundException {
parseTypeAnnotation();
parseMethodAnnotation();
parseConstructAnnotation();
}
}
运行结果：  

id= "0"; name= "type"; gid = class java.lang.Long
method = c ; id = 5 ; description = private method; gid= class java.lang.Long
method = a ; id = 3 ; description = public method; gid= class java.lang.Long
method = b ; id = 4 ; description = protected method; gid= class java.lang.Long
constructor = com.tmser.annotation.UserAnnotation ; id = 2 ; description = construct; gid= class java.lang.Long

</code></pre><pre><code>@Target({ElementType.TYPE,ElementType.FIELD,ElementType.METHOD})
public @interface MyAnnotation {
    //注解中只有成员变量，无成员方法
    int id() default 0;
    String username() default " ";
}

//这里的default给该变量id和username设置了默认值

在Student类中用了该注解的方法可以给该注解中的变量赋值，  
如果注解没有设置默认值，则在引用该注解的时候必须给该注解赋值  

public class Student {
    @MyAnnotation(id = 12, username ="小飞龙" )
    int age;
    @MyAnnotation
    public void test01() {
    }
    @MyAnnotation(id = 55)
    public void test02() {
    }
​
}  
</code></pre><p>当注解中只有一个变量的时候（也就是只有一个无参方法的时候）可以这样写  </p>
<pre><code>public @interface MyAnnotation {
    //注解中只有成员变量，无成员方法
    String value() default " ";
}  


public class Student {
    @MyAnnotation("张三")
    public void test01() {
    }
  //  @MyAnnotation(value = "李四")等价    @MyAnnotation("张三")
  @MyAnnotation(value = "李四")
    public void test02() {
    }
}

//在这里@MyAnnotation(value = "李四")等价  
//@MyAnnotation("张三")，都是给value赋值

</code></pre><ol>
<li><p>要用好注解，必须熟悉java 的反射机制，从上面的例子可以看出，注解的解析完全依赖于反射。  </p>
</li>
<li><p>不要滥用注解。平常我们编程过程很少接触和使用注解，只有做设计，且不想让设计有过多的配置时  </p>
</li>
</ol>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>JAVA反射机制是在运行状态中，<br>对于任意一个类，都能够知道这个类的所有属性和方法；<br>对于任意一个对象，都能够调用它的任意一个方法和属性；<br>这种动态获取信息以及动态调用对象的方法的功能称为java语言的反射机制  </p>
<ul>
<li>强引用:通过new创建的对象的引用都是强引用，强引用只有在从根节点不可达的情况下才会被垃圾回收器回收，所以可能产生内存溢出。</li>
<li>软引用:使用SoftReference创建，弱于强引用，在内存紧张的时候会被回收，不会产生内存溢出。</li>
<li>弱引用:使用WeakReference创建，弱于软引用，在系统gc时只要发现弱引用直接回收，不会产生内存溢出。</li>
<li>虚引用:使用PhantomReference创建，最弱的引用类型，随时都可以被垃圾回收器回收，配合引用队列使用可以跟踪对象的回收，因此可以将一些资源的释放放在虚引用中执行和记录。</li>
</ul>  

<pre><code>package com.winwill.reference;

import org.junit.Test;

import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;

public class TestReference {
    public static class User {
        private String name;
        private int id;

        public User(String name, int id) {
            this.name = name;
            this.id = id;
        }

        @Override
        public String toString() {
            return id + ":" + name;
        }
    }

    @Test
    public void testReference() throws Exception {
        /** 创建强引用对象*/
        User u = new User("winwill", 1);

        /**使用强引用对象创建软引用对象*/
        SoftReference&lt;User&gt; userSoftReference = new SoftReference&lt;User&gt;(u);
        /**使用强引用对象创建弱引用对象*/
        WeakReference&lt;User&gt; userWeakReference = new WeakReference&lt;User&gt;(u);

        /**使用强引用对象创建虚引用对象*/
        ReferenceQueue&lt;User&gt; referenceQueue = new ReferenceQueue&lt;User&gt;();
        PhantomReference&lt;User&gt; userPhantomReference = new PhantomReference&lt;User&gt;(u, referenceQueue);
        /**删除强引用*/
        u = null;

        /**通过软引用获取*/
        System.out.println(userSoftReference.get());
        /**通过虚引用获取*/
        System.out.println(userWeakReference.get());
        /**通过虚引用获取*/
        System.out.println(userPhantomReference.get());
    }
}</code></pre><p>String类常用方法：  </p>
<ul>
<li>String trim()，该方法返回一个新字符串，新的字符串删除了原始串中首尾的空格</li>
<li>String substring(int beginIndex,int endIndex)，该方法返回一个新字符串，新的字符串包含原来字符串中从beginIndex到endIndex-1的所有内容。</li>
<li>boolean equals(Object other)，该方法用于比较两个字符串，如果原字符串与other相等，则返回true</li>
<li>toLowerCase()和toUpperCase()方法是一个字符串大小写转换</li>
<li>charAt(index)表示根据索引查找字符串的字符</li>
<li>int length()，该方法返回一个字符串的长度</li>
</ul>  

<p>double和Double的区别，前者是基本的数据类型，后者是引用类型，即包装类，直接使用普通运算符“==”对基本数据类型进行比较，但如果将“==”用于比较引用类型的话，只会判断其内存地址是否相同，并且结果通常是否定的。</p>
<p>ArrayList定义了一些用于插入和删除元素的方法  </p>
<ul>
<li>add(E e) 将指定的元素添加到此列表的尾部</li>
<li>clear() 移除此列表中的所有元素</li>
<li>contains(Object o) 如果此列表中包含指定的元素，则返回 true</li>
<li>get(int index) 返回此列表中指定位置上的元素</li>
<li>remove(int index) 移除此列表中指定位置上的元素</li>
<li>toArray() 按从第一个到最后一个元素的顺序返回包含此列表中所有元素的数组</li>
</ul>  

<p>Java自带了各种Map类，这些Map类可归为三种类型</p>
<ul>
<li>通用MapHashMap、Hashtable、Properties、LinkedHashMap、IdentityHashMap等）</li>
<li>专用Mapjava.util.jar.Attributes、javax.print.attribute.standard.PrinterStateReasons等）</li>
<li>一个用于帮助实现您自己的 Map 类的抽象类</li>
</ul>  

<p>其中，通用Map用于在应用程序中管理映射，通常在 java.util 程序包中实现，可以直接使用。<br>Map定义了几个用于插入和删除元素的方法，通过这些方法可以更改Map中的内容  </p>
<ul>
<li>clear() 从Map中删除所有映射</li>
<li>remove(Object key) 从Map中删除键和关联的值</li>
<li>put(Object key, Object value) 将指定值与指定键相关联</li>
<li>get(Object key) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null</li>
<li>putAll(Map t) 将指定 Map 中的所有映射复制到此 map</li>
</ul>  

<p>HashMap是基于哈希表的 Map 接口的实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。这里的键值对（key - value）  </p>
<p>Servlet（Server Applet），全称 Java Servlet 。它是用 Java 编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态 Web 内容。狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是指任何实现了这个 Servlet 接口的类，一般情况下，人们将 Servlet 理解为后者。 Servlet 运行于支持 Java 的应用服务器中。从原理上讲，Servlet 可以响应任何类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服务器。  </p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>jar命令用于输出一个xxx.jar文件  </p>
<pre><code>用法：jar {ctxu}[vfm0Mi] [jar-文件] [manifest-文件] [-C 目录] 文件名 ...  
选项：  
    -c  创建新的存档  
    -t  列出存档内容的列表  
    -x  展开存档中的命名的（或所有的〕文件  
    -u  更新已存在的存档  
    -v  生成详细输出到标准输出上  
    -f  指定存档文件名  
    -m  包含来自标明文件的标明信息  
    -0  只存储方式；未用ZIP压缩格式  
    -M  不产生所有项的清单（manifest〕文件  
    -i  为指定的jar文件产生索引信息  
    -C  改变到指定的目录，并且包含下列文件：  

如果一个文件名是一个目录，它将被递归处理。  
清单（manifest〕文件名和存档文件名都需要被指定，按'm' 和 'f'标志指定的相同顺序  

示例1，将两个class文件存档到一个名为 'classes.jar' 的存档文件中：
jar cvf classes.jar Foo.class Bar.class  

示例2，用一个存在的清单（manifest）文件'mymanifest'将foo/目录下的所有文件存档到一个名为 'classes.jar'的存档文件中：
jar cvfm classes.jar mymanifest -C foo/  

一般在使用使用jar cvf 文件名.jar 文件所在路径（xxx/xxx/xxx.class）也可以压缩一个目录,只要在制定路径是指定为文件夹，jar命令的命令行参数在使用时可以以“-”开头，也可以不用。</code></pre><p>java程序的运行过程，首先是启动java虚拟机，然后就是去找.class文件，先是从系统的类库中找（系统之会在跟目录下查找，所以需要完整类名），如果找不到的话会去CLASSPATH所设置的目录去找。然后加载到java虚拟机中。  </p>
<p>系统会在每个java程序中隐含导入了java.lang这个包，import 包名，导入包中的类文件。<br>java.lang包，这是一个基础包。<br>java.util包,这个包是工具类的包。<br>java.io包,这个包是用于输入输出操作的<br>java.net包,这个包是用于网络编程。<br>java.awt，java.swing，javax.swing，java.event等包用于图形编程用的包。<br>java应用程序中必须有一个main()方法。  </p>
<p><a href="https://pan.baidu.com/s/1yiRKc1_aItFCYMHVFiCShg" target="_blank">JDK 1.8 API查询手册chm格式-英文版.rar</a><br><a href="https://pan.baidu.com/s/1mXe3DS2Zal2J1E4qHpyc4g" target="_blank">Intellij idea2020.1.1永久破解安装包及步骤说明(亲测可用).rar</a>  </p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            
            
            
            <div class="reprint1">
                <p>
                    <span class="reprint1-tip">
                        <i class="fa fa-exclamation-circle"></i>&nbsp;&nbsp;转载请注明:
                    </span>
                    <a href="http://127.0.0.1/diary" class="b-link-green">车舟慢</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/diary/2021/02/01/diary-20210201-1/" class="b-link-green">J2SE基础</a>
                </p>
            </div>

        </div>
    </div>

    

    

    

    

    
        <style>
    .valine-card {
        margin: 1.5rem auto;
    }

    .valine-card .card-content {
        padding: 20px 20px 5px 20px;
    }
	
	/*zs shuai*/
	#vcomments{
		display:none;
	}
	
    /* valine 评论框增加背景图片 */
    #vcomments textarea {
        box-sizing: border-box;
        background: url("") 100% 100% no-repeat;
    }

    #vcomments input[type=text],
    #vcomments input[type=email],
    #vcomments input[type=url],
    #vcomments textarea {
        box-sizing: border-box;
    }

    #vcomments p {
        margin: 2px 2px 10px;
        font-size: 1.05rem;
        line-height: 1.78rem;
    }

    #vcomments blockquote p {
        text-indent: 0.2rem;
    }

    #vcomments a {
        padding: 0 2px;
        color: #42b983;
        font-weight: 500;
        text-decoration: underline;
    }

    #vcomments img {
        max-width: 100%;
        height: auto;
        cursor: pointer;
    }

    #vcomments ol li {
        list-style-type: decimal;
    }

    #vcomments ol,
    ul {
        display: block;
        padding-left: 2em;
        word-spacing: 0.05rem;
    }

    #vcomments ul li,
    ol li {
        display: list-item;
        line-height: 1.8rem;
        font-size: 1rem;
    }

    #vcomments ul li {
        list-style-type: disc;
    }

    #vcomments ul ul li {
        list-style-type: circle;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    #vcomments table, th, td {
        border: 0;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments h1 {
        font-size: 1.85rem;
        font-weight: bold;
        line-height: 2.2rem;
    }

    #vcomments h2 {
        font-size: 1.65rem;
        font-weight: bold;
        line-height: 1.9rem;
    }

    #vcomments h3 {
        font-size: 1.45rem;
        font-weight: bold;
        line-height: 1.7rem;
    }

    #vcomments h4 {
        font-size: 1.25rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    #vcomments h5 {
        font-size: 1.1rem;
        font-weight: bold;
        line-height: 1.4rem;
    }

    #vcomments h6 {
        font-size: 1rem;
        line-height: 1.3rem;
    }

    #vcomments p {
        font-size: 1rem;
        line-height: 1.5rem;
    }

    #vcomments hr {
        margin: 12px 0;
        border: 0;
        border-top: 1px solid #ccc;
    }

    #vcomments blockquote {
        margin: 15px 0;
        border-left: 5px solid #42b983;
        padding: 1rem 0.8rem 0.3rem 0.8rem;
        color: #666;
        background-color: rgba(66, 185, 131, .1);
    }

    #vcomments pre {
        font-family: monospace, monospace;
        padding: 1.2em;
        margin: .5em 0;
        background: #272822;
        overflow: auto;
        border-radius: 0.3em;
        tab-size: 4;
    }

    #vcomments code {
        font-family: monospace, monospace;
        padding: 1px 3px;
        font-size: 0.92rem;
        color: #e96900;
        background-color: #f8f8f8;
        border-radius: 2px;
    }

    #vcomments pre code {
        font-family: monospace, monospace;
        padding: 0;
        color: #e8eaf6;
        background-color: #272822;
    }

    #vcomments pre[class*="language-"] {
        padding: 1.2em;
        margin: .5em 0;
    }

    #vcomments code[class*="language-"],
    pre[class*="language-"] {
        color: #e8eaf6;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    #vcomments b,
    strong {
        font-weight: bold;
    }

    #vcomments dfn {
        font-style: italic;
    }

    #vcomments small {
        font-size: 85%;
    }

    #vcomments cite {
        font-style: normal;
    }

    #vcomments mark {
        background-color: #fcf8e3;
        padding: .2em;
    }

    #vcomments table, th, td {
        padding: 12px 13px;
        border: 1px solid #dfe2e5;
    }

    table tr:nth-child(2n), thead {
        background-color: #fafafa;
    }

    #vcomments table th {
        background-color: #f2f2f2;
        min-width: 80px;
    }

    #vcomments table td {
        min-width: 80px;
    }

    #vcomments [type="checkbox"]:not(:checked), [type="checkbox"]:checked {
        position: inherit;
        margin-left: -1.3rem;
        margin-right: 0.4rem;
        margin-top: -1px;
        vertical-align: middle;
        left: unset;
        visibility: visible;
    }

    /* 修复评论第一行位置错位 */
    .v .vlist .vcard {
    padding-top: 2.5em !important ;
    }
</style>

<div class="card valine-card" data-aos="fade-up">
    <div id="vcomments" class="card-content"></div>
</div>

<script src="/libs/valine/av-min.js"></script>
<script src="/libs/valine/Valine.min.js"></script>
<!-- <link rel="stylesheet" type="text/css" href="/libs//libs/jQuery-emoji/dist/css/jquery.emoji.css">
<script src="/libs//libs/jQuery-emoji/dist/js/jquery.emoji.min.js"></script>
<script src="/libs//libs/jQuery-emoji/dist/js/emoji.list.js"></script> -->
<script>
    new Valine({
        el: '#vcomments',
        appId: '2Kc1yifl00dRA6CYQxICVIe4-MdYXbMMI',
        appKey: 'xni6ILbDL2WVE4HDucMuDtx7',
        notify: 'true' === 'true',
        verify: 'true' === 'true',
        visitor: 'true' === 'true',
        avatar: '',
        pageSize: '10',
        lang: 'zh-cn',
        placeholder: 'just go go ヾﾉ≧∀≦)o ',

    });

//     function parse_emoji() {
//     jQuery(".vcontent").emojiParse({
//       basePath: '/libs/jQuery-emoji/images/emoji',
//       icons: emojiLists   // 注：详见 js/emoji.list.js
//     });
//   }
  
//   setTimeout(function() {
//     // jQuery emoji 解析
//     parse_emoji();
//     // jquery emoji 初始化
//     jQuery(".veditor").emoji({
//       showTab: true,
//       animation: 'slide',
//       basePath: '/libs/jQuery-emoji/images/emoji',
//       icons: emojiLists  // 注：详见 js/emoji.list.js
//     });
//     jQuery(".vmore").on("click", function() {
//       setTimeout(function() {
//         parse_emoji();
//       }, 500);
//     });
//   }, 800)

</script>
    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/diary/2021/02/08/diary-20210208-1/">
                    <div class="card-image">
                        
                        
                        <img src="/diary/medias/featureimages/28.jpg" class="responsive-img" alt="HeadFirstJava阅读笔记">
                        
                        <span class="card-title">HeadFirstJava阅读笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            第一章Java中所有东西都会属于某个类，建立源文件(.java)，编译成类文件(.class)。真正被执行的是类。编辑保存源文件源文件编译成类(.class字节码)调用Java虚拟机运行类执行程序就是命令Java虚拟机(JVM)加载某个类，
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2021-02-08
                        </span>
                        <span class="publish-author">
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/diary/tags/Java/" target="_blank">
                        <span class="chip bg-color">Java</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/diary/2021/01/25/diary-20210125-1/">
                    <div class="card-image">
                        
                        
                        <img src="/diary/medias/featureimages/12.jpg" class="responsive-img" alt="Linux系统的使用实践">
                        
                        <span class="card-title">Linux系统的使用实践</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            纯Python创建服务器不安装任何软件实现局域网快速共享文件,只利用python创建一个简易的单线程服务器。  
windows的命令行模式下检查python版本。  
python -V  命令行进入想分享的目录，输入以下命令，即可创建以
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2021-01-25
                            </span>
                        <span class="publish-author">
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/diary/tags/Python/" target="_blank">
                        <span class="chip bg-color">Python</span>
                    </a>
                    
                    <a href="/diary/tags/Linux/" target="_blank">
                        <span class="chip bg-color">Linux</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: 车舟慢<br />'
            + '作者: <br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/diary/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h1, h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h1, h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


        <footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            

            <br>
            <span id="sitetime"></span><span class="my-face">ღゝ◡╹)ノ♡</span>
            <br>

            

            
            <!--
            
			
                &nbsp; | &nbsp;字数统计:&nbsp;
    <span class="white-color">650.5k</span> 字  
			
            
			
			-->

            
            <br>

        </div>

        <div class="col s12 m4 l4 social-link social-statis">

 
    <a href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&email=617641594@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>






    <a href="http://wpa.qq.com/msgrd?v=3&uin=617641594&site=qq&menu=yes" class="tooltipped" target="_blank" data-tooltip="访问我的QQ空间" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>




<!--

    <a href="/diary/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>

--></div>

    </div>
</footer>

<div class="progress-bar"></div>

<script language=javascript>
    function siteTime() {
        window.setTimeout("siteTime()", 1000);
        var seconds = 1000;
        var minutes = seconds * 60;
        var hours = minutes * 60;
        var days = hours * 24;
        var years = days * 365;
        var today = new Date();
        var todayYear = today.getFullYear();
        var todayMonth = today.getMonth() + 1;
        var todayDate = today.getDate();
        var todayHour = today.getHours();
        var todayMinute = today.getMinutes();
        var todaySecond = today.getSeconds();

        /* Date.UTC() -- 返回date对象距世界标准时间(UTC)1970年1月1日午夜之间的毫秒数(时间戳)
        year - 作为date对象的年份，为4位年份值
        month - 0-11之间的整数，做为date对象的月份
        day - 1-31之间的整数，做为date对象的天数
        hours - 0(午夜24点)-23之间的整数，做为date对象的小时数
        minutes - 0-59之间的整数，做为date对象的分钟数
        seconds - 0-59之间的整数，做为date对象的秒数
        microseconds - 0-999之间的整数，做为date对象的毫秒数 */

        var t1 = Date.UTC(2020, 5, 1, 00, 00, 00); //北京时间2019-8-1 00:00:00
        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
        var diff = t2 - t1;
        var diffYears = Math.floor(diff / years);
        var diffDays = Math.floor((diff / days) - diffYears * 365);
        var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
        var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) / minutes);
        var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours - diffMinutes *
            minutes) / seconds);
        document.getElementById("sitetime").innerHTML = "本站已坚持运行 " + diffYears + " 年 " + diffDays + " 天 " + diffHours +
            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒" ;
    } /*因为建站时间还没有一年，就将之注释掉了。需要的可以取消*/
    siteTime();
</script>






        <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>
<script src="/diary/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/diary/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
        <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


        <script src="/diary/libs/materialize/materialize.min.js"></script>
        <script src="/diary/libs/masonry/masonry.pkgd.min.js"></script>
        <script src="/diary/libs/aos/aos.js"></script>
        <script src="/diary/libs/scrollprogress/scrollProgress.min.js"></script>
        <script src="/diary/libs/lightGallery/js/lightgallery-all.min.js"></script>
        <script src="/diary/js/matery.js"></script>

        <!-- Global site tag (gtag.js) - Google Analytics -->



        
            <script src="/diary/libs/others/clicklove.js"></script>
        

        

        
        <script type="text/javascript">
            var OriginTitile = document.title,
                st;
            document.addEventListener("visibilitychange", function () {
                document.hidden ? (document.title = "看不见我🙈~看不见我🙈~", clearTimeout(st)) : (document.title =
                    "(๑•̀ㅂ•́) ✧被发现了～", st = setTimeout(function () {
                        document.title = OriginTitile
                    }, 3e3))
            })
        </script>

       
        

        
        

    
        

    
        

        

        
        

        
        

        
        
            <script type="text/javascript">
            var windowWidth = $(window).width();
            if (windowWidth > 992) {
                document.write('<script type="text/javascript" src="/diary/libs/background/ribbon-dynamic.js"><\/script>');
            }
            </script>
        

    <script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                preloadRatio: 1,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var e=n.imageLazyLoadSetting.isSPA,i=n.imageLazyLoadSetting.preloadRatio||1,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){e&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,a=0;a<r.length;a++)0<=(t=(t=r[a]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(n.innerHeight*i||document.documentElement.clientHeight*i)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},t.src!==i&&(n.src=i)}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body>
</html>