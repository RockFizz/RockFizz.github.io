<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Quasar安装测试</title>
      <link href="/2020/10/23/diary-20201023-1/"/>
      <url>/2020/10/23/diary-20201023-1/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍Quasar"><a href="#介绍Quasar" class="headerlink" title="介绍Quasar"></a>介绍Quasar</h2><h2 id="1-安装Quasar-CLI"><a href="#1-安装Quasar-CLI" class="headerlink" title="(*)1.安装Quasar CLI"></a>(*)1.安装Quasar CLI</h2><p>Before we install Quasar CLI, we need to make sure we have the right versions of node (&gt;= 8 at the time of writing) and npm (&gt;= 5). If not, we need to either install or update it. Then we can install Quasar CLI:</p><pre><code>npm install -g @quasar/cli </code></pre><h2 id="2-安装yarn"><a href="#2-安装yarn" class="headerlink" title="(*)2.安装yarn"></a>(*)2.安装yarn</h2><p>双击安装yarn-1.22.5.msi文件。<a href="https://pan.baidu.com/s/1EWXutw07RA8L9lmeUEhQSg" target="_blank" rel="noopener">点我下载yarn安装包</a></p><h2 id="基于quasar创建项目"><a href="#基于quasar创建项目" class="headerlink" title="基于quasar创建项目"></a>基于quasar创建项目</h2><p>Then we create a project folder with Quasar CLI:</p><pre><code>quasar create helloworld</code></pre><p>Once the CLI has successfully created the application, it will give you the command to change into the newly created directory and the command you will need to run to start your application: </p><pre><code>cd helloworldquasar dev </code></pre><p>开发模式的一些常用命令</p><pre><code>quasar dev                        #运行开发服务器(使用默认主题)quasar dev -p 9090                #运行在特定端口quasar dev -m ssr                #SSR quasar dev -m pwa                #PWA quasar dev -m electron            #Electron应用</code></pre><p><a href="https://pan.baidu.com/s/1sZzVH_Myr2natDE6Xi9i5g" target="_blank" rel="noopener">初始化好的空quasar项目demo下载</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> Quasar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue实现响应式设计的一种思路</title>
      <link href="/2020/10/21/diary-20201021-3/"/>
      <url>/2020/10/21/diary-20201021-3/</url>
      
        <content type="html"><![CDATA[<p>响应式就是根据当前屏幕大小，设置个性化样式。</p><h2 id="Vue原生功能"><a href="#Vue原生功能" class="headerlink" title="Vue原生功能"></a>Vue原生功能</h2><p>除了vue利用类似element-UI框架自带响应式布局等以外 ，利用Vue原生功能实现响应式设计，就是利用<br>一个生命周期钩子——mounted：挂载时操作；<br>几条条指令——v-show等（本例中采用，非绝对）：根据条件显示；<br>一套js判断语句：if/else或者switch/case。</p><pre><code>&lt;div v-show="this.show"&gt;fdsafdf&lt;/div&gt;......var head = new Vue({    el : "#head",    data : {        //此处省略一千字        show : true        },    mounted : function(){        //可用于设置自适应屏幕，根据获得的可视宽度（兼容性）判断是否显示        let w = document.documentElement.offsetWidth || document.body.offsetWidth;        if(w &lt; 1000){            this.show = false;        }})</code></pre><h2 id="Vue监听窗口变化"><a href="#Vue监听窗口变化" class="headerlink" title="Vue监听窗口变化"></a>Vue监听窗口变化</h2><p>先回顾JS里获得浏览器窗口大小的方法。</p><pre><code>监听窗口变化    window.onresize 网页可见区域宽        document.body.clientWidth网页可见区域高        document.body.clientHeight网页可见区域宽        document.body.offsetWidth    (包括边线的宽)网页可见区域高        document.body.offsetHeight    (包括边线的宽)</code></pre><p>在vue的data中定义变量screenWidth，在页面mounted时挂载window.onresize方法，监听screenWidth属性值变化并处理。</p><pre><code>data:{    screenWidth:document.body.clientWidth,    timer:false}.........mounted:function(){    const that =this;    window.onresize=()=&gt;{        return (()=&gt;{            that.screenWidth=document.body.clientWidth;        })    };}.........watch:{    screenWidth(val){        //为避免频繁触发resize函数导致页面卡顿，使用定时器。        if(!this.timer){            this.screenWidth=val;            this.timer=true;            let that =this;            setTimeout(function(){                console.log(that.screenWidth);                that.timer=false;            },400);        }    }}</code></pre><h2 id="实践demo"><a href="#实践demo" class="headerlink" title="实践demo"></a>实践demo</h2><p>既然已经可以监听窗口宽度的变化，就可以根据这个值设定不同的自适应方案了。<br>下面举个例子。（div或img的宽度自适应很简单，设置css的width属性为百分比即可），但父级元素的高度并不固定，通常由子级元素撑开决定。<br>一个类似图片库功能，当屏幕缩小放大时，我们可以设置外层边框的宽度为100%，以达到宽度自适应。但高度不行，我们需要：<br>1、数据加载完后，获取图片（外层框）的宽度。<br>2、根据宽度，设置外层框的高度。（如宽度的60%）<br>3、监听窗口宽度变化，每次变化重新获取宽度，重新设置高度</p><pre><code>mounted:function(){    //1.数据首次加载完之后，获取宽度，设置高度为宽度的60%    this.$nextTick(()=&gt;{        let imgBox=this.$refs.imgBox;        let wImgBox=imgBox[0].getBoundingClientRect().width;        this.imgBox.height=0.6*wImgBox+'px';    });    //2.挂载resize事件，屏幕缩放时监听宽度变化，改变设置高度    const that =this;    window.onresize=()=&gt;{        return(()=&gt;{            this.$nextTick(()=&gt;{                let imgBox=this.$refs.imgBox;                let wImgBox=imgBox[0].getBoundingClientRect().width;                this.imgBox.height=0.6*wImgBox+'px';            });        })    };}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孩子要经历什么，才能懂得学业的重要、父母的不易</title>
      <link href="/2020/10/21/diary-20201021-2/"/>
      <url>/2020/10/21/diary-20201021-2/</url>
      
        <content type="html"><![CDATA[<p>文章开始之前，我们先来看两个关于环卫工人的事例。</p><p>每个周末的清晨，这个小男孩都要帮做环卫工的母亲打扫街道。</p><p>打扫完了，母子俩还会一起歇一歇，说说话，温情的画面令人感动。</p><p>一名体型较胖的年轻女子，用手狠狠地拽着一个环卫工人拖行数米，旁边其他环卫工急忙上前拦架。</p><p>原来是女儿在向母亲要钱！</p><p>这位母亲已经快50岁了，做环卫工10多年，一个月才几千块钱。</p><p>她的女儿也已做了母亲，还隔三差五伸手向母亲要钱，不给钱就辱骂、吵架、打架…..</p><p>同是环卫工的子女，为什么这个小男孩这么体恤母亲，而那个年轻女子却成了“白眼狼”呢？</p><h2 id="蜜里泡大的少年，如何懂得愁滋味。"><a href="#蜜里泡大的少年，如何懂得愁滋味。" class="headerlink" title="蜜里泡大的少年，如何懂得愁滋味。"></a>蜜里泡大的少年，如何懂得愁滋味。</h2><p>有人问小男孩的母亲：“你家孩子真懂事，是怎么教育的？”</p><p>这位女环卫工不善言辞，说不出太多的教育道理来，有些不好意思地说：</p><p>“我们穷人的孩子早当家嘛！”</p><p>穷人的孩子中，有很多很懂事，也有很多很任性。</p><p>我相信，一定存在某种因素造成了这种区别。</p><p>这种因素究竟是什么呢？</p><p>看到下面的故事后，我恍然大悟。</p><p>某君高中时沉迷网络，时常半夜翻墙出校上网。</p><p>一日他照例翻墙，翻到一半即拔足狂奔而归，面色古怪，问之不语。</p><p>从此认真读书，不再上网，学校盛传他见鬼了。</p><p>后来他考上名校，昔日同学问及此事，他沉默良久说，那天父亲来送生活费，舍不得住旅馆，在墙下坐了一夜。</p><p>有没有被这个父亲感动到？</p><p>可是假如这个父亲的艰辛，没有被调皮捣蛋的儿子意外发现，儿子会洗心革面吗？</p><p>孩子都不是天生就懂得体恤父母。</p><p>他们只有切切实实感受到了父母的艰辛和苦难后，才会对父母心生感激。</p><p>进而对自己严格要求，不辜负父母的一片苦心。 </p><h2 id="父母的过度呵护，是一味毒药。"><a href="#父母的过度呵护，是一味毒药。" class="headerlink" title="父母的过度呵护，是一味毒药。"></a>父母的过度呵护，是一味毒药。</h2><p>当下的中国，有一个很可怕的现象——全民富二代。</p><p>富人家的孩子当富二代养，穷人家的孩子也当富二代养，所谓“再穷不能穷教育，再苦不能苦孩子”。</p><p>有不少父母，不顾家庭资源禀赋差异，百般努力、倾尽所有，让孩子享受最好的生活条件。</p><p>夫妻俩加上四个老人，六个人照顾一个孩子，衣来伸手、饭来张口，真是捧在手里怕摔了，含在嘴里怕化了。</p><p>“穷人的孩子早当家”，这句话放在过去的确是成立的。</p><p>上学时，我拼命地努力，想通过学习，去争取更好的生活。</p><p>我从来不大手大脚地花钱，因为我知道，父母供我读书的每一分钱，都来之不易。</p><p>不仅是我，那个时候，我身边大多数的孩子都是这样。</p><p>现在，一些条件并不宽裕的家庭，觉得亏欠了孩子，担心孩子被别人家孩子比下去，产生自卑心理，反而更加娇惯、宠溺孩子。</p><p>大多数的孩子都过着一种享乐的生活，热了有空调，冷了有暖气，家家都有零食吃，人人都有新衣服穿。</p><p>父母再苦再累，也舍不得孩子吃苦受罪。</p><p>当父母恨不得把全世界所有的好东西和所有的爱都给孩子时，却忘了告诉孩子一件事：生活的艰辛，是难以想象的。</p><p>父母的过度呵护，对于孩子们来说，无疑是一味毒药。</p><p>孩子们心安理得享受着一切，根本不知道知足、感恩和体贴父母，更不知道生活的不容易。</p><p>相反，还滋生了很多虚荣、懒惰的坏毛病。 </p><h2 id="所谓富贵病、不适应，都是矫情。"><a href="#所谓富贵病、不适应，都是矫情。" class="headerlink" title="所谓富贵病、不适应，都是矫情。"></a>所谓富贵病、不适应，都是矫情。</h2><p>知乎上曾有一个很热的帖子。</p><p>说的是在外留学的富二代，不学无术、不能适应，对在国外学习和生活都产生了极其严重的排斥感，勉强混完一个学期后，意图退学。</p><p>他爸爸二话不说，让他假期不要回国，不能在家呆着，必须出去打工。</p><p>找到一份在中餐馆的工作，少年开始了“水深火热”、“暗无天日”的日子。</p><pre><code>“餐馆的老板极其苛刻，什么脏话累活都扔给我，我的主要任务就是洗碗，拖地，剁菜，搬饮料，以及频繁地炒饭，有一段时间我连做梦都梦见自己在炒饭。还要听命于其他店员的指使，哪里垃圾该倒了，哪里厕所堵了，他们上嘴唇一碰下嘴唇，我就得屁颠屁颠地去解决。店里打工的人都没有文化，没有绿卡，不会英文，但我是新来的，而且职位最低，自然没有地位。到了晚上下了班一群人合住在一个房间里，完全没有隐私。他们睡觉打呼，这对睡眠极浅的我来说又是一种折磨，常常整夜整夜地睡不着，第二天起来干活根本没精神又要被人骂。”</code></pre><p>一个月后，拿着辛苦赚来的血汗钱，他灰溜溜地回到了学校。</p><p>爸爸意味深长地说了一番话：</p><p>不是每个人都得循规蹈矩地上完高中上大学，上完大学去公司当上班族的。</p><p>只不过如果不走这条相对轻松的路，那摆在大多数人眼前的就只有干粗活苦活累活。</p><p>可是干粗活也是分人的，有的人干得了，有的人就干不了。</p><p>有的人没有条件也没有选择，只能干粗活，那没什么好说的；可有的人如果明明有好的条件和机会却任性地放弃错过了，将来可是要后悔莫及的。</p><p>当然，要是有人天赋异禀，3岁识谱、5岁编曲或者18岁就能打NBA，那这些话不适用他。</p><p>否则，好好读书永远不会让人吃亏。</p><p>从此少年认真学习，再无不适应。</p><p>原来所谓的富贵病、难适应，都是矫情，吃一吃苦就好了。 </p><h2 id="勤奋和努力，是给孩子最好的馈赠。"><a href="#勤奋和努力，是给孩子最好的馈赠。" class="headerlink" title="勤奋和努力，是给孩子最好的馈赠。"></a>勤奋和努力，是给孩子最好的馈赠。</h2><p>或许我们没有让孩子去国外留学的条件，但依然可以在日常中让孩子有更多体验，提供机会让孩子收获磨练。</p><p>我一侄子参加完中考，接下来就是一个长长的假期。</p><p>他爸妈让我帮忙，介绍到我家附近的奶茶店打工，体验生活。</p><p>每天回来，都有新的话题，要么告诉我们一天做了些什么，要么就是店里来了些什么人，还知道了一些送快餐的骑手和一些业务员的事儿，说的头头是道的。</p><p>有一天我问他：“上班容易不？”</p><p>他说：“也容易也不容易，我上班这几天，把一辈子的哥姐都给叫了，脸都笑僵了。”</p><p>我把这话转告给他爸妈，他们倍感欣慰。</p><p>给孩子再好的教育，都不如让他亲自去感受一下，成人世界的不容易。</p><p>正如曾国藩所说：</p><p>“子侄除读书外，教之扫屋、抹桌凳、收粪、锄草，是极好之事，切不可以为有损架子而不为也。”</p><p>今天的父母，总想着把最好的条件给孩子，这其实是在害孩子。</p><p>成长过程中，物质越充裕，精神越疲敝；精神疲敝时，创造物质的脚步自然会停歇。</p><p>反之，给孩子真实的成长，让孩子懂得困难与艰辛，教孩子珍惜馈赠与财富，引导孩子依靠勤奋和努力，才是对孩子最深邃的馈赠。 </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 文摘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>人到中年，有水平的处世方式</title>
      <link href="/2020/10/21/diary-20201021-1/"/>
      <url>/2020/10/21/diary-20201021-1/</url>
      
        <content type="html"><![CDATA[<h2 id="学会沉默"><a href="#学会沉默" class="headerlink" title="学会沉默"></a>学会沉默</h2><p>说话是银，沉默是金。<br>人到中年，慢慢发现，50%的话不必说，50%的话说了也没用。<br>懂的人自然会懂，面对不懂的人，要学会沉默。<br>宋代吕蒙正，因为出身不好，经常被人看不起。<br>承蒙皇帝赏识，他出仕不久就升任参政。<br>从前看不起他的人心里不平衡，就开始在背后嚼舌头。<br>有一天下朝，有人在背后讥讽他：“就这样的货色，也配参政吗？”<br>他却像没听到一样，头也不回往前走。<br>朋友愤愤不平，想要回头理论。<br>他拉住朋友说：“不必理会，让他说去吧。”<br>围观的人说他很有胸襟，将来必能当宰相！<br>后来，他果然做到了宰相。<br>说话固然是一种表达，沉默也是一种态度。<br>面对那些和自己不同路的人，不必争辩，努力做好自己的事，保持沉默就是最好的蔑视。 </p><h2 id="不拒绝新事物"><a href="#不拒绝新事物" class="headerlink" title="不拒绝新事物"></a>不拒绝新事物</h2><p>季羡林曾说：中年之后，最忌讳的就是思维僵化。<br>所谓思维僵化，就是一个人不再有能力吸收新的东西。<br>这样的人很容易和社会脱节，把自己困在过去的小天地里。<br>曾国藩是传统的儒家知识分子。<br>他从小学的是四书五经，接受的是夷夏之防。<br>但是他的头脑却一直保持开放的状态，积极学习，从未老去。<br>别的士大夫把洋人当成蛮夷，只有他说：洋人也懂信义，洋人的技术我们也要学习。<br>年过五旬，曾国藩积极学习西方的数理化，推动洋务运动。<br>曾国藩创办的安庆内军械所，是中国第一所兵工厂。<br>他让儿子去学英文，给他请最好的英文老师，让孩子去见更广阔的天地。<br>他送出了中国第一批留学生，开办了中国第一所翻译馆。<br>正是曾国藩的不懈努力，让古老的中国开始慢慢了解外面的世界。<br>李南老师曾说：一个人只要不拒绝新鲜事物，那么他的世界就可以每天增长一点点。<br>这个人的视野和格局也会变得越来越大。<br>一个人在不断尝试新鲜事物之后，日子也会变得越来越充实有趣。 </p><h2 id="收住脾气"><a href="#收住脾气" class="headerlink" title="收住脾气"></a>收住脾气</h2><p>人发脾气是天性，收住脾气则是修养。<br>一个人的修养越好，越能控制好自己的情绪。<br>从前有个将军，千里迢迢去找禅师求道。<br>到了寺庙，他问禅师：何为天堂，何为地狱。<br>禅师说：“你一个武夫，也配和我论道？”<br>将军大怒，拔出剑来架在禅师脖子上，吼道：“如此无礼，我杀了你！”<br>禅师平静地回答：此为地狱。<br>将军一愣，随即恍然，放刀入鞘，向禅师鞠躬，感谢指点。<br>老子说：“胜人者力，自胜者强”。<br>一个人能够真正掌控自己，才是真正的强者。<br>不能控制情绪的人，只能沦为情绪的奴隶，肆意发泄，害人害己。<br>当情绪上涌的时候，人是失去理智的野兽。<br>这时候无论做什么都是错的。<br>静下心来，离开现场，听听音乐，跑跑步，多换位思考一下。<br>等情绪平复，再作打算。<br>这样的人，才能真正掌控自己的生活，主导自己的人生。 </p><h2 id="善于麻烦别人"><a href="#善于麻烦别人" class="headerlink" title="善于麻烦别人"></a>善于麻烦别人</h2><p>很多人都觉得，多帮助别人才能多交朋友。<br>而实际上，多麻烦别人，也能建立牢固的友谊。<br>胡适十几岁的时候被送往上海读书，母亲不放心，送他到车站的时候说：你要去到更大的世界了，我再也帮不了你，自己去闯荡吧，送你四个字——学会求助。<br>多年以后，回想起这四个字，胡适才开始明白母亲的睿智。<br>每个人都渴望被需要，只要不是太过分的要求，别人一定乐意帮你一把，对帮助者而言，这也是一种快乐。<br>18世纪的富兰克林曾有一个难缠的对手。<br>每次他演讲，这个议员都会给他唱反调。<br>他一直对这个议员很礼貌，但是议员就是不愿跟他合作。<br>直到有一天，他知道这个议员有一套绝版图书。<br>他赶忙去借，没想到议员同意了，从那次之后，两人关系明显缓和。<br>最后俩人还成了好友。<br>富兰克林说：“相比那些被你帮助过的人，那些曾经帮助过你的人会更愿意再帮你一次。”<br>很多人怕麻烦别人，但是，不麻烦彼此，关系也就无从建立。<br>只有懂得麻烦别人，一来二去，才能慢慢熟络，成为朋友。 </p><h2 id="慢慢来，别着急"><a href="#慢慢来，别着急" class="headerlink" title="慢慢来，别着急"></a>慢慢来，别着急</h2><p>王阳明曾言：<br>“我辈致知，只是各随分限所及。今日良知见在如此，只随今日所知扩充到底。明日良知又有开悟，便从明日所知扩充到底。”<br>这句话的意思是说：每个人每天学习的东西是有限的，不要想一口吃成大胖子，做学问，必须一步一步来。<br>就像是浇树一样，刚开始萌芽的树苗，只能浇一点点水。<br>等树长大了一点了，再多浇一点。<br>如果初生的树苗用一桶水去浇灌它，就会把它泡坏了。<br>从前纪昌拜射箭高手飞卫为师学习射箭。<br>飞卫让他练好眼的基本功，再教他射箭。<br>他回去睁着眼看妻子织布，看着梭子眼睛一点不眨。<br>再后来，飞卫让他把小的东西看成大的东西。<br>他就天天盯着远处的小虫子看，直到他把虫子看成车轮大小，飞卫才开始教他射箭。<br>后来，纪昌果然成为当世有名的射箭高手。<br>饭要一口一口吃，路要一步一步走，欲速则不达。<br>在日益浮躁的今天，千万不要着急。<br>找准方向，一步一个脚印。<br>只要坚持住，所有的美好都会如约而至，属于你的一切，终将到来。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 文摘 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue项目部署到非根目录</title>
      <link href="/2020/10/14/diary-20201014-2/"/>
      <url>/2020/10/14/diary-20201014-2/</url>
      
        <content type="html"><![CDATA[<p>Vue项目部署到非根目录需要修改的地方有两处。<br>例如需要向项目部署到8080端口下子目录 :8080/xlwj2020/处。</p><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>config目录下的index.js内，build标签下</p><pre><code>build{    ...    assetsPublicPath: '/xlwj2020/',    ...}</code></pre><h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>路由router下的index.js内，添加base字段</p><pre><code>var base=process.env.NODE_DEV == 'development' ? '/' : 'xlwj2020'export default new Router({  mode: 'hash',  ...  base: base,  ...})</code></pre><h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p>npm run build</p><p>发布后部署在8080端口下xlwj2020目录,访问地址为 :8080/xlwj2020/</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下操作Mysql数据库(增删查改)和Kbengine编译成功后的运行</title>
      <link href="/2020/10/14/diary-20201014-1/"/>
      <url>/2020/10/14/diary-20201014-1/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql服务操作"><a href="#mysql服务操作" class="headerlink" title="mysql服务操作"></a>mysql服务操作</h2><pre><code>```sudo cat /etc/mysql/debian.cnf                     #查看安装mysql时的初始账号密码    mysql -u账号名 -p密码                            #进入mysql数据库mysql-&gt;status;                                    #查看数据库版本mysql-&gt;quit;                                        #退出当前账号mysql登陆mysql-&gt;show databases;                    #显示所有数据库mysql-&gt;use database_name;                #使用database_name数据库mysql-&gt;create database data_name;        #创建名为data_name的数据库mysql-&gt;drop database data_name;            #删除一个名为data_name的数据库mysql-&gt; show tables;                        #显示所有表mysql-&gt; drop table tab_name;            #删除名为tab_name的数据表mysql-&gt; describe tab_name;                #显示名为tab_name的表的数据结构mysql-&gt; show columns from tab_name;        #显示名为tab_name的表的数据结构mysql-&gt; delete from tab_name;            #将表tab_name中的记录清空mysql-&gt; select * from tab_name;            #显示表tab_name中的记录mysql-&gt; mysqldump -uUSER -pPASSWORD --no-data DATABASE TABLE &gt; table.sql;#复制表结构mysql-&gt; create table tab_name( id int(10) not null auto_increment primary key, name varchar(40), pwd varchar(40) ) charset=gb2312;                         #创建一个名为tab_name的新表mysql-&gt; ALTER TABLE tab_name ADD PRIMARY KEY (col_name)        #更改表得的定义把某个栏位设为主键。mysql-&gt; ALTER TABLE tab_name DROP PRIMARY KEY (col_name)     #把主键的定义删除mysql-&gt; alter table tab_name add col_name varchar(20);         #在tab_name表中增加一个名为col_name的字段且类型为varchar(20)mysql-&gt; alter table tab_name drop col_name;                    #在tab_name中将col_name字段删除执行外部sql脚本当前数据库上执行:mysql &lt; input.sql 指定数据库上执行:mysql [表名] &lt; input.sqlmysql-&gt;service mysql start;                #启动mysql服务mysql-&gt;service mysql stop;                #停止mysql服务```</code></pre><h2 id="Kbengine编译成功后的运行"><a href="#Kbengine编译成功后的运行" class="headerlink" title="Kbengine编译成功后的运行"></a>Kbengine编译成功后的运行</h2><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><pre><code>sudo useradd kbesudo passwd kbe  </code></pre><h3 id="mysql数据库配置"><a href="#mysql数据库配置" class="headerlink" title="mysql数据库配置"></a>mysql数据库配置</h3><pre><code>mysql -u默认账号名 -p默认密码            #先用系统默认账号登陆mysqlmysql&gt; use mysql mysql&gt; delete from user where user=''; mysql&gt; FLUSH PRIVILEGES;mysql&gt; grant all privileges on *.* to kbe@'%' identified by 'pwd123456';mysql&gt; grant select,insert,update,delete,create,drop on *.* to kbe@'%' identified by 'pwd123456';mysql&gt; FLUSH PRIVILEGES;mysql&gt; create database kbe;                #创建数据库</code></pre><p>上面创建的数据库名和用户名密码都是引擎的默认值，如果你按照自己的想法用了别的名字，则需要进入引擎配置文件做相应修改：</p><pre><code>vim &lt;引擎根目录&gt;/kbe/res/server/kbengine_defaults.xml</code></pre><h3 id="启动及关闭服务器"><a href="#启动及关闭服务器" class="headerlink" title="启动及关闭服务器"></a>启动及关闭服务器</h3><p>kbengine_demos_assets文件夹是服务端资产库是后来另外下载复制进来的，一般放在&lt;引擎根目录&gt;下<br>assets下载地址： <a href="https://github.com/kbengine/kbengine_demos_assets/tree/v1.3.1" target="_blank" rel="noopener">https://github.com/kbengine/kbengine_demos_assets/tree/v1.3.1</a> </p><pre><code>cd &lt;引擎根目录&gt;/kbengine_demos_assetssh start_server.sh                        # 启动服务器，成功后会有9个进程ps -aux | grep &lt;引擎根目录&gt;                # 查看是否启动成功cd &lt;引擎根目录&gt;/kbengine_demos_assetssh kill_server.sh                         # 停止服务器</code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/ubuntuKBErunningServer.jpg" alt=""></p><p>客户端连接时，服务端这边报not found dbmgr，数据库里没有表。查看loggeryibubu检查哪里有错吧。。。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity线程操作时报错解决方案</title>
      <link href="/2020/09/28/diary-20200928-1/"/>
      <url>/2020/09/28/diary-20200928-1/</url>
      
        <content type="html"><![CDATA[<p>unity3d报这个错误get_isPlaying can only be called from the main thread。<br>原因就是多线程服务中，非主线程操作，ui界面等的一些操作，就会报这个错误。<br>解决方案就是：写在Update()中监听进行修改，这样就没有错误了。</p><pre><code>参考代码：private bool rideFrontBack = false;private void DorideFrontBack() {//要做的事    Event_custom e1 = new Event_custom(Custom_Event_Type.EventCircleRide.ToString());    e1.arguments.Add("GetSign", rideSymbol);    EventManager_Custom.instance.dispatchEvent(e1);    rideFrontBack = false;}void Update(){    if (rideFrontBack) {        DorideFrontBack();    }}public void UseFun(){//欲调用的地方    rideFrontBack = true;}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Unity3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask快速搭建你需要的Web接口</title>
      <link href="/2020/09/16/diary-20200916-2/"/>
      <url>/2020/09/16/diary-20200916-2/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>cmd里先通过python -m pip install flask 安装flask<br>cmd里在通过python helloflask.py 即可运行起这个简易服务端接口 </p><pre><code>from flask import Flaskimport jsonapp = Flask(__name__)@app.route('/')def index():    return "Hello World, I am chinese."@app.route('/json')def do_json():    hello = {"name":"stranger", "say":"hello"}    return json.dumps(hello)if __name__ == "__main__":    app.run(host='127.0.0.1',port=5001,debug=True)</code></pre><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p><a href="https://pan.baidu.com/s/1HDeXgU3n_QxHMrvEeybXOw" target="_blank">带flask的Python3.6环境包下载(20200916)</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python图像处理之4_Pillow</title>
      <link href="/2020/09/16/diary-20200916-3/"/>
      <url>/2020/09/16/diary-20200916-3/</url>
      
        <content type="html"><![CDATA[<p>Pillow是Python中的一个图形处理库。</p><h2 id="获取图像信息"><a href="#获取图像信息" class="headerlink" title="获取图像信息"></a>获取图像信息</h2><pre><code>from PIL import Image im = Image.open('12.jpg')im.save('red.png') print('图像的格式：', im.format)print('图像的大小：', im.size)print('图像的宽度：', im.width)print('图像的高度：', im.height) print('获取某个像素点的颜色值：', im.getpixel((100, 100))) im.show() </code></pre><h2 id="创建一个简单的图像"><a href="#创建一个简单的图像" class="headerlink" title="创建一个简单的图像"></a>创建一个简单的图像</h2><pre><code>from PIL import Image im=Image.new('RGB',(150,150),'red') im.save('red.png')</code></pre><h2 id="blend图像混合"><a href="#blend图像混合" class="headerlink" title="blend图像混合"></a>blend图像混合</h2><p>透明度混合主要是使用Image中的blend(im1, im2, alpha)方法，<br>im1：Image对象，在混合的过程中，透明度设置为（1-apha）<br>im2：Image对象，在混合的过程中，透明度设置为（apha）<br>alpha：透明度，取值是0-1。当透明度为0是，显示im1对象；当透明度为1时，显示im2对象<br>注意：im1和im2的大小必须一样，且mode都为RGB</p><pre><code>from PIL import Image# 打开im1im1 = Image.open('21.jpg').convert(mode='RGB')# 创建一个和im1大小一样的图像im2 = Image.new('RGB', im1.size, 'red')# 混合图片，并显示Image.blend(im1, im2, 0.2).show() </code></pre><h2 id="遮罩图像混合"><a href="#遮罩图像混合" class="headerlink" title="遮罩图像混合"></a>遮罩图像混合</h2><p>我们可以通过Image.composite(im1, im2, mask) 方法实现遮罩混合。三个参数都是Image对象，该方法的作用就是使用mask来混合im1和im2。<br>注意：im1、im2和mask的大小必须一样 </p><pre><code>from PIL import Imageim1 = Image.open('1.jpg')                # 打开图像1 im2 = Image.open('2.jpg')                # 打开图像2 im2.resize(im1.size)                    # 重新设置im2的大小 r, g, b = im2.split()                    # 将图像2的三个色道分离，其中r、g、b都为Image对象 Image.composite(im1, im2, b).show()     # 遮罩混合</code></pre><h2 id="图像缩放"><a href="#图像缩放" class="headerlink" title="图像缩放"></a>图像缩放</h2><p>按像素缩放通过Image.eval(im1,fun)方法实现，其中im1为我们老生常谈的Image对象了；第二个为一个方法（函数），该函数传入一个参数，即像素点。该函数会对图片中每个像素点进行函数内的操作 </p><pre><code>from PIL import Imageim = Image.open('21.jpg')                # 打开一张图像Image.eval(im, lambda x:x*2).show()        # 对该图像每个像素点进行*2处理</code></pre><p>按尺寸缩放是通过Image对象的thumbnail()方法实现 </p><pre><code>from PIL import Image im1 = Image.open('1.jpg') im2 = im1.copy() im2.thumbnail((50, 50))im2.save('result.png')print("im1的大小", im1.size)print('im2的大小', im2.size)</code></pre><h2 id="复制、剪切、粘贴"><a href="#复制、剪切、粘贴" class="headerlink" title="复制、剪切、粘贴"></a>复制、剪切、粘贴</h2><p>粘贴的实现主要是通过Image对象的paste(im,box,mask)方法，其中im为Image对象；box为要粘贴到的区域；mask为遮罩（我也不知道啥是遮罩）。其中box的参数有三种形式：<br>(x1, y1)：将im左上角对齐(x1,y1)点，其余部分粘贴，超出部分抛弃<br>(x1, x2, y1, y2)：将im粘贴至此区域<br>None：此时im必须与源图像大小一致</p><pre><code>from PIL import Imageim = Image.open('1.jpg')im1 = im.copy()                                    # 复制两份im2 = im.copy()im_crop = im1.crop((200, 200, 300, 300))        # 剪切图片im2.paste(im_crop, (30, 30))                    # 粘贴图片im2.show()im2.rotate(90).show()                            # 旋转图片</code></pre><h2 id="图像的分离和合并"><a href="#图像的分离和合并" class="headerlink" title="图像的分离和合并"></a>图像的分离和合并</h2><p>Image对象的split()方法，将图像的RGB三个通道分离，并返回三个Image对象 </p><pre><code>from PIL import Imageim = Image.open('1.jpg')r, g, b = im.split()        # 分离通道，返回3个Image对象r.show()g.show()b.show()</code></pre><p>合并是通过Image.merge(mode, bands)方法实现的，其中mode为模式，bands为通道列表，传入一个列表类型数据。 </p><pre><code>from PIL import Imageim1 = Image.open('1.jpg')im2 = Image.open('2.jpg')im2.resize(im1.size)             # 让im2大小和im1一样r1, g1, b1 = im1.split()        # 将两个图像分别分离r2, g2, b2 = im2.split() im3 = Image.merge('RGB', [r1, g2, b1])    # 合并图像im3.show()</code></pre><h2 id="几个常用图像滤镜"><a href="#几个常用图像滤镜" class="headerlink" title="几个常用图像滤镜"></a>几个常用图像滤镜</h2><p>高斯模糊也叫高斯平滑，是通常用它来减少图像噪声以及降低细节层次。这种模糊技术生成的图像，其视觉效果就像是经过一个毛玻璃在观察图像，这与镜头焦外成像效果散景以及普通照明阴影中的效果都明显不同</p><pre><code>from PIL import Image, ImageFilterim1 = Image.open('12.jpg')                                    # 打开图像img = Image.new('RGB', (im1.width*2, im1.height), 'red')    # 创建一个im1两倍宽的图像im2 = im1.filter(ImageFilter.GaussianBlur)                    # 高斯模糊滤镜#im2 = im1.filter(ImageFilter.CONTOUR)                        # 轮廓滤镜#im2 = im1.filter(ImageFilter.DETAIL)                        # 细节滤镜#im2 = im1.filter(ImageFilter.EDGE_ENHANCE)                    # 边缘增强滤镜#im2 = im1.filter(ImageFilter.EDGE_ENHANCE_MORE)            # 边缘增强plus滤镜#im2 = im1.filter(ImageFilter.EMBOSS)                        # 浮雕滤镜#im2 = im1.filter(ImageFilter.FIND_EDGES)                    # 寻找边缘滤镜 #im2 = im1.filter(ImageFilter.SMOOTH)                        # 平滑滤镜img.paste(im1, (0, 0))                                        # 将im1粘贴到img上img.paste(im2, (im1.width, 0))                                # 将im2（高斯模糊后的图像）粘贴到img上img.show()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pillow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV图像处理之3</title>
      <link href="/2020/09/15/diary-20200915-1/"/>
      <url>/2020/09/15/diary-20200915-1/</url>
      
        <content type="html"><![CDATA[<h2 id="dlib的安装"><a href="#dlib的安装" class="headerlink" title="dlib的安装"></a>dlib的安装</h2><p>环境：python3.6.8 </p><ol><li>配置cmake </li></ol><p>去<a href="https://cmake.org/download/" target="_blank" rel="noopener">https://cmake.org/download/</a> 下载cmake-3.18.2-win64-x64.zip绿色解压版。解压后将”D:\cmake-3.18.2-win64-x64\bin”添加进系统的环境变量-&gt;系统变量-&gt;path变量。 </p><ol start="2"><li>通过源码安装dlib </li></ol><p>去<a href="https://pypi.org/project/dlib/#files" target="_blank" rel="noopener">https://pypi.org/project/dlib/#files</a> 下载dlib-19.21.0.tar.gz，解压。</p><pre><code> 打开cmd  进入dlib-19.21.0.tar.gz解压的目录  运行 python setup.py build  运行 python setup.py install</code></pre><h2 id="OpenCv-dlib实现人脸68个关键点检测并标注"><a href="#OpenCv-dlib实现人脸68个关键点检测并标注" class="headerlink" title="OpenCv+dlib实现人脸68个关键点检测并标注"></a>OpenCv+dlib实现人脸68个关键点检测并标注</h2><p>思路:内容主要以下两大块：68点标定和OpenCv绘点。其中68点的标定借助于官方的训练模型实现，OpenCv绘点用到的画圆函数cv2.circle()和输出字符串函数cv2.putText()。 </p><p><a href="http://dlib.net/files/shape_predictor_68_face_landmarks.dat.bz2" target="_blank">官方的训练模型shape_predictor_68_face_landmarks.dat下载</a></p><pre><code>1. 调用dlib库来进行人脸识别，调用预测器shape_predictor_68_face_landmarks.dat进行68点标定 2. 存入68个点坐标 3. 利用 cv2.circle 来画68个点 4. 利用 cv2.putText() 函数来画数字1-68</code></pre><p>程序：</p><pre><code>import numpy as npimport cv2 import dlib detector = dlib.get_frontal_face_detector()predictor = dlib.shape_predictor('shape_predictor_68_face_landmarks.dat')img = cv2.imread("test3.jpg")img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)rects = detector(img_gray, 0)for i in range(len(rects)):    landmarks = np.matrix([[p.x, p.y] for p in predictor(img,rects[i]).parts()])    for idx, point in enumerate(landmarks):        # 68点的坐标        pos = (point[0, 0], point[0, 1])        print(idx,pos)        # 利用cv2.circle给每个特征点画一个圈，共68个        cv2.circle(img, pos, 5, color=(0, 255, 0))        # 利用cv2.putText输出1-68        font = cv2.FONT_HERSHEY_SIMPLEX        cv2.putText(img, str(idx+1), pos, font, 0.8, (0, 0, 255), 1,cv2.LINE_AA)print('end')cv2.namedWindow("img", 2)cv2.imshow("img", img)cv2.waitKey(0)</code></pre><h2 id="使用dlib正向人脸检测器"><a href="#使用dlib正向人脸检测器" class="headerlink" title="使用dlib正向人脸检测器"></a>使用dlib正向人脸检测器</h2><p>截取保存人脸</p><pre><code>import dlibimport cv2 import timeimport randomdef random_letters(n):        return time.strftime("%Y-%m-%d-%H-%M-%S",time.localtime())+"_"+''.join((random.sample('zyxwvutsrqponmlkjihgfedcbaZYXWVUTSRQPONMLKJIHGFEDCBA',n))) + ".jpg"def recognition(img_rd):    k = cv2.waitKey(1)    img_gray = cv2.cvtColor(img_rd, cv2.COLOR_RGB2GRAY)    faces = detector(img_gray, 0)    if len(faces) != 0:        faces_start_width = 0        for face in faces:            cv2.rectangle(img_rd, tuple([face.left(), face.top()]), tuple([face.right(), face.bottom()]),(0, 255, 255), 2)            height = face.bottom() - face.top()            width = face.right() - face.left()            if (face.bottom() &lt; 480) and (face.right() &lt; 640) and ((face.top() + height) &lt; 480) and ((face.left() + width) &lt; 640):            #    for i in range(height):            #        for j in range(width):                        #img_rd[i][faces_start_width + j] =img_rd[face.top() + i][face.left() + j]                #faces_start_width += width                            image_clip=img_rd[face.top():(face.top() + height),face.left():(face.left() + width)]                if image_clip is not None:                    try:                        cv2.imwrite(random_letters(5),image_clip)                    except Exception as e:                        print(e)    cv2.imshow('image', img_rd)detector=dlib.get_frontal_face_detector()cap = cv2.VideoCapture(0,cv2.CAP_DSHOW)size = (640,480)while(1):    ret, frame = cap.read()    if ret:        recognition(frame)    if cv2.waitKey(1) &amp; 0xFF == ord('q'):        breakcap.release()cv2.destroyAllWindows()</code></pre><h2 id="使用dlib中的深度残差网络-ResNet-实现实时人脸识别"><a href="#使用dlib中的深度残差网络-ResNet-实现实时人脸识别" class="headerlink" title="使用dlib中的深度残差网络(ResNet)实现实时人脸识别"></a>使用dlib中的深度残差网络(ResNet)实现实时人脸识别</h2><p>opencv中提供的基于haar特征级联进行人脸检测的方法效果非常不好，本文使用dlib中提供的人脸检测方法（使用HOG特征或卷积神经网方法），并使用提供的深度残差网络（ResNet）实现实时人脸识别。 </p><p>人脸识别分为人脸检测和识别两个阶段，人脸检测会找到人脸区域的矩形窗口，识别则通过ResNet返回人脸特征向量，并进行匹配。 </p><p>（1）人脸检测阶段。人脸检测算法需要用大小位置不同的窗口在图像中进行滑动，然后判断窗口中是否存在人脸。在深度学习之前的主流方法是特征提取+集成学习分类器，比如以前火热的haar特征+adaboost级联分类器，opencv中实现的人脸检测方法就采用了这种，不过实验结果来看，这种检测方法效果很不好，经常误检测人脸，或者检测不到真实的人脸；dlib中使用的是HOG+回归树的方法，使用dlib训练好的模型进行检测效果要好很多。dlib也使用了卷积神经网络来进行人脸检测，效果好于HOG的集成学习方法，不过需要使用GPU加速，不然程序会卡爆了，一张图片可能几秒甚至几十秒。 </p><p>（2）识别阶段。识别也就是我们常说的“分类”，摄像头采集到这个人脸时，让机器判断是张三还是其他人。分类分为特征向量抽取和距离匹配两个部分。<br>特征向量抽取。本文用到的是dlib中已经训练好的ResNet模型的接口，此接口会返回一个128维的人脸特征向量。<br>距离匹配。在获取特征向量之后可以使用欧式距离和本地的人脸特征向量进行匹配，使用最近邻分类器返回样本的标签。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/shibieface12020.jpg" alt="人脸识别分类过程"><br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/shibieface22020.jpg" alt="获取人脸特征向量过程"> </p><p>用简单的话总结，整个过程分为两个阶段，本地存储已标记人脸数据；识别阶段把从摄像头读取的人脸和本地进行匹配，得到分类结果。</p><h3 id="获取本地的人脸特征向量库和标签"><a href="#获取本地的人脸特征向量库和标签" class="headerlink" title="获取本地的人脸特征向量库和标签"></a>获取本地的人脸特征向量库和标签</h3><pre><code>import numpy as npimport cv2 import dlib import osimport jsondetector = dlib.cnn_face_detection_model_v1('mmod_human_face_detector.dat')sp = dlib.shape_predictor('shape_predictor_68_face_landmarks.dat')facerec = dlib.face_recognition_model_v1('dlib_face_recognition_resnet_model_v1.dat')# 上面的模型可在这里下载：http://dlib.net/files/imagePath = 'img/'                                                                                         #图像的目录data = np.zeros((1,128))                                                                                 #定义一个128维的空向量datalabel = []                                                                                                 #定义空的list存放人脸的标签for file in os.listdir(imagePath):                                                                         #开始一张一张索引目录中的图像    if '.jpg' in file or '.png' in file:        fileName = file        labelName = file.split('_')[0]                                                                     #获取标签名        print('current image: ', file)        print('current label: ', labelName)        img = cv2.imread(imagePath + file)                                                                #使用opencv读取图像数据        if img.shape[0]*img.shape[1] &gt; 500000:                                                            #如果图太大的话需要压缩，这里像素的阈值可以自己设置            img = cv2.resize(img, (0,0), fx=0.5, fy=0.5)        img = cv2.resize(img, (0,0), fx=0.5, fy=0.5)                                                    #我16g的内存都不够，所以索性所有图片都压缩一遍。        dets = detector(img, 1)                                                                            #使用检测算子检测人脸，返回的是所有的检测到的人脸区域        for k, d in enumerate(dets):            rec = dlib.rectangle(d.rect.left(),d.rect.top(),d.rect.right(),d.rect.bottom())            shape = sp(img, rec)                                                                        #获取landmark            face_descriptor = facerec.compute_face_descriptor(img, shape)                                #使用resNet获取128维的人脸特征向量            faceArray = np.array(face_descriptor).reshape((1, 128))                                        #转换成numpy中的数据结构            data = np.concatenate((data, faceArray))                                                    #拼接到事先准备好的data当中去            label.append(labelName)                                                                        #保存标签            cv2.rectangle(img, (rec.left(), rec.top()), (rec.right(), rec.bottom()), (0, 255, 0), 2)    #显示人脸区域        cv2.waitKey(2)        cv2.imshow('image', img)data = data[1:, :]                                                                                        #因为data的第一行是空的128维向量，所以实际存储的时候从第二行开始np.savetxt('faceData.txt', data, fmt='%f')                                                                #保存人脸特征向量合成的矩阵到本地labelFile=open('label.txt','w')json.dump(label, labelFile)                                                                                #使用json保存list到本地labelFile.close()cv2.destroyAllWindows()                                                                                    #关闭所有的窗口print('end success')</code></pre><p>这里使用的是CNN进行人脸检测，如果你没有GPU，或者你有GPU但没有进行GPU的配置，那么速度巨慢，此时你可以使用传统的HOG特征+级联分类的方法，不过效果没有CNN的好。这时代码的第7行中模型需要替换成：</p><pre><code>detector = dlib.get_frontal_face_detector() </code></pre><p>其余的基本保持不变。<br>运行之后会检测文件夹img下所有的图像，得到本地的人脸特征向量库和标签。 </p><h3 id="实时读取摄像头进行人脸识别"><a href="#实时读取摄像头进行人脸识别" class="headerlink" title="实时读取摄像头进行人脸识别"></a>实时读取摄像头进行人脸识别</h3><pre><code>import dlibimport numpy as npimport cv2import json detector = dlib.get_frontal_face_detector()sp = dlib.shape_predictor('shape_predictor_68_face_landmarks.dat')facerec = dlib.face_recognition_model_v1('dlib_face_recognition_resnet_model_v1.dat')threshold = 0.54 def findNearestClassForImage(face_descriptor, faceLabel):    temp =  face_descriptor - data    e = np.linalg.norm(temp,axis=1,keepdims=True)    min_distance = e.min()     print('distance: ', min_distance)    if min_distance &gt; threshold:        return 'other'    index = np.argmin(e)    return faceLabel[index]def recognition(img):    dets = detector(img, 1)    for k,d in enumerate(dets):        #print("Detection {}: Left: {} Top: {} Right: {} Bottom: {}".format(k, d.left(), d.top(), d.right(), d.bottom()))        rec = dlib.rectangle(d.left(),d.top(),d.right(),d.bottom())        print(rec.left(),rec.top(),rec.right(),rec.bottom())        shape = sp(img, rec)        face_descriptor = facerec.compute_face_descriptor(img, shape)        class_pre = findNearestClassForImage(face_descriptor, label)        print(class_pre)        cv2.rectangle(img, (rec.left(), rec.top()+10), (rec.right(), rec.bottom()), (0, 255, 0), 2)        cv2.putText(img, class_pre , (rec.left(),rec.top()), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0,255,0), 2, cv2.LINE_AA)    cv2.imshow('image', img)labelFile=open('label.txt','r')label = json.load(labelFile)                                                   #载入本地人脸库的标签labelFile.close()data = np.loadtxt('faceData.txt',dtype=float)                                  #载入本地人脸特征向量cap = cv2.VideoCapture(0,cv2.CAP_DSHOW)fps = 20size = (640,480)#fourcc = cv2.VideoWriter_fourcc(*'XVID')#videoWriter = cv2.VideoWriter('video.MP4', fourcc, fps, size)while(1):    ret, frame = cap.read()    #frame = cv2.resize(frame, (0,0), fx=0.5, fy=0.5)    if ret:        recognition(frame)        #videoWriter.write(frame)    if cv2.waitKey(1) &amp; 0xFF == ord('q'):        breakcap.release()#videoWriter.release()cv2.destroyAllWindows()</code></pre><h2 id="实验环境下载"><a href="#实验环境下载" class="headerlink" title="实验环境下载"></a>实验环境下载</h2><p><a href="https://pan.baidu.com/s/1yYDED8S_yvL9LAi9Gmaibg" target="_blank">带dlib的Python3.6环境包下载</a><br><br><br><a href="https://pan.baidu.com/s/1K9asN51nsEfQUMd3RkxkHA" target="_blank">基于dlib的人脸库训练和实时摄像头人脸识别</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> dlib </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyinstaller输出exe文件</title>
      <link href="/2020/09/11/diary-20200911/"/>
      <url>/2020/09/11/diary-20200911/</url>
      
        <content type="html"><![CDATA[<h2 id="Pyinstaller安装"><a href="#Pyinstaller安装" class="headerlink" title="Pyinstaller安装"></a>Pyinstaller安装</h2><p>我的python版本时3.6.8<br>下载pyinstaller-4.0.tar.gz，解压缩，进入相关目录。</p><pre><code>python setup.py install</code></pre><p>安装后，将相应Scripts目录(比如C:\HealthCenter\Apache24\Python\Scripts)添加加入系统path变量。</p><h2 id="Pyinstaller使用"><a href="#Pyinstaller使用" class="headerlink" title="Pyinstaller使用"></a>Pyinstaller使用</h2><p>安装配置完成后后进入目标py文件目录下，<br>可使用命令打包输出exe文件，路径不要有中文。</p><pre><code>pyinstaller -F test_1.py --noconsolepyinstaller -F -i panda.ico test_1.py --noconsole </code></pre><p>在代码里面尽量不要用import，能from…..import….就尽量用这个，因为如果是import的话，在打包的时候，会将整个包都打包到exe里面，没有意义的增大了工具的大小！ </p><pre><code>-F                打包一个单个文件，如果你的代码都写在一个.py文件的话，可以用这个，如果是多个.py文件就别用-D                打包多个文件，在dist中生成很多依赖文件，适合以框架形式编写工具代码-K, –tk            在部署时包含 TCL/TK-i ico路径         将file.ico添加为可执行文件的资源(只对Windows系统有效)，改变程序的图标</code></pre><h2 id="参考python文件"><a href="#参考python文件" class="headerlink" title="参考python文件"></a>参考python文件</h2><pre><code>import tkinterdef fun():    l='666'    return ldef main():    top=tkinter.Tk()    top.iconbitmap("panda.ico")    top.title('hello tkinter')    top.geometry('400x600')    top.resizable(False,False)    l0 = tkinter.Label(top, text='测试空间宽高度', width=20, height=15).pack(side='top')    var = tkinter.StringVar()    entry = tkinter.Entry(top, textvariable=var)    var.set('hello tk')    t = var.get()    label = tkinter.Label(text=t).pack()    entry.pack()    bt = tkinter.Button(top, text='获取文本内容', command=fun).pack()    top.mainloop()    passif __name__ == "__main__":    main()</code></pre><p><a href="https://pan.baidu.com/s/1tC7KEGoq1bZOcf4Yt4WdTw" target="_blank">带pyinstaller的Python环境包下载</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV图像处理之2</title>
      <link href="/2020/09/11/diary-20200914-1/"/>
      <url>/2020/09/11/diary-20200914-1/</url>
      
        <content type="html"><![CDATA[<h2 id="素描化风格"><a href="#素描化风格" class="headerlink" title="素描化风格"></a>素描化风格</h2><pre><code>import cv2def rgb_to_sketch_v2(src_image_name):    img_gray = cv2.imread(src_image_name, 0)    img_blur = cv2.GaussianBlur(img_gray, (21, 21), 0, 0)    img_blend = cv2.divide(img_gray, img_blur, scale=256)    img_result = cv2.cvtColor(img_blend, cv2.COLOR_GRAY2BGR)    cv2.imshow("imshow",img_result)    cv2.imwrite('test-sumiao.jpg',img_result)    cv2.waitKey(0) #防止图片窗口闪退if __name__ =='__main__':    src_image_name="test.jpg"    rgb_to_sketch_v2(src_image_name)</code></pre><h2 id="浮雕风格"><a href="#浮雕风格" class="headerlink" title="浮雕风格"></a>浮雕风格</h2><pre><code>import cv2import numpy as npdef Filter_Fudiao(src_img):    # filter=np.array([[-1,0,0],[0,0,0],[0,0,1]])    filter = np.array([[-1, 0], [0, 1]])    row=src_img.shape[0]    col=src_img.shape[1]    new_img=np.zeros([row,col],dtype=np.uint8)    for i in range(row-1):        for j in range(col-1):            new_value = np.sum(src_img[i:i + 2, j:j + 2] * filter) + 128  # point multiply            if new_value &gt; 255:                new_value = 255            elif new_value &lt; 0:                new_value = 0            else:                pass            new_img[i, j]=new_value    return new_imgsrc_img_name='test.jpg'src_img=cv2.imread(src_img_name)gray_img = cv2.cvtColor(src_img, cv2.COLOR_BGR2GRAY)new_img=Filter_Fudiao(gray_img)cv2.imshow('src',src_img)cv2.imshow('fudiao',new_img)cv2.imwrite('test-fudiao.jpg',new_img)cv2.waitKey(0)</code></pre><h2 id="模糊滤镜"><a href="#模糊滤镜" class="headerlink" title="模糊滤镜"></a>模糊滤镜</h2><pre><code>import cv2im = cv2.imread('test2.jpg')dst = cv2.GaussianBlur(im,(5,5),cv2.BORDER_DEFAULT)cv2.imshow('Blur image', dst)cv2.waitKey(0)</code></pre><h2 id="边缘检测滤镜"><a href="#边缘检测滤镜" class="headerlink" title="边缘检测滤镜"></a>边缘检测滤镜</h2><pre><code>import cv2im = cv2.imread('test2.jpg')edges = cv2.Canny(im,100,300)cv2.imshow('Canny', edges)cv2.waitKey(0)</code></pre><h2 id="复古风滤镜"><a href="#复古风滤镜" class="headerlink" title="复古风滤镜"></a>复古风滤镜</h2><pre><code>import cv2import numpy as npim = cv2.imread('test2.jpg')rows, cols = im.shape[:2]kernel_x = cv2.getGaussianKernel(cols,200)kernel_y = cv2.getGaussianKernel(rows,200)kernel = kernel_y * kernel_x.Tfilter = 255 * kernel / np.linalg.norm(kernel)vintage_im = np.copy(im)for i in range(3):    vintage_im[:,:,i] = vintage_im[:,:,i] * filtercv2.imshow('FuGuFeng image', vintage_im)cv2.waitKey(0) </code></pre><h2 id="将图片转化成手绘水墨风格的滤镜"><a href="#将图片转化成手绘水墨风格的滤镜" class="headerlink" title="将图片转化成手绘水墨风格的滤镜"></a>将图片转化成手绘水墨风格的滤镜</h2><pre><code>from PIL import Imageimport numpy as npa=np.asarray(Image.open("home2.jpg").convert("L")).astype("float")depth=10#深度的范围为0~100，我们先取10这个数grad = np.gradient(a) #取图像灰度的梯度值，有两个grad_x, grad_y = grad               #分别取横纵图像梯度值#将高度融入纵横梯度当中，也可以理解让梯度变化不那么明显grad_x = grad_x*depth/100.grad_y = grad_y*depth/100.#A = np.sqrt(grad_x**2 + grad_y**2 + 1.)uni_x = grad_x/Auni_y = grad_y/Auni_z = 1./A#设定了一个光源点，知道角度，来算出单位的x,y,z的长度vec_el = np.pi/2.2                   # 光源的俯视角度，弧度值vec_az = np.pi/4.                    # 光源的方位角度，弧度值dx = np.cos(vec_el)*np.cos(vec_az)   #光源对x 轴的影响dy = np.cos(vec_el)*np.sin(vec_az)   #光源对y 轴的影响dz = np.sin(vec_el)              #光源对z 轴的影响#光源归一化b = 255*(dx*uni_x + dy*uni_y + dz*uni_z)   b = b.clip(0,255)im = Image.fromarray(b.astype('uint8'))  #重构图像im.save('test5.jpg')</code></pre><h2 id="九种名画风格"><a href="#九种名画风格" class="headerlink" title="九种名画风格"></a>九种名画风格</h2><pre><code>import cv2net = cv2.dnn.readNetFromTorch('starry_night.t7')net.setPreferableBackend(cv2.dnn.DNN_BACKEND_OPENCV);image = cv2.imread('home2.jpg')(h,w)=image.shape[:2]blob=cv2.dnn.blobFromImage(image, 1.0, (w, h), (103.939, 116.779, 123.680), swapRB=False, crop=False)net.setInput(blob)out = net.forward()out = out.reshape(3, out.shape[2], out.shape[3])out[0] += 103.939out[1] += 116.779out[2] += 123.68#由于imshow、imwrite两个函数的范围期望不同，使用imshow需除以255，imwrite则不需要#out /= 255out = out.transpose(1, 2, 0)cv2.imwrite('home/home2-starry_night.jpg',out)#cv2.imshow('Styled image', out)cv2.waitKey(0)</code></pre><p>根据九种名画训练好的神经网络模型下载地址为，下载后可以直接使用<br>加载模型 -&gt; 读取图片 -&gt; 进行计算 -&gt; 输出图片</p><pre><code>http://cs.stanford.edu/people/jcjohns/fast-neural-style/models/instance_norm/candy.t7 http://cs.stanford.edu/people/jcjohns/fast-neural-style/models/instance_norm/mosaic.t7 http://cs.stanford.edu/people/jcjohns/fast-neural-style/models/instance_norm/la_muse.t7 http://cs.stanford.edu/people/jcjohns/fast-neural-style/models/instance_norm/feathers.t7 http://cs.stanford.edu/people/jcjohns/fast-neural-style/models/instance_norm/the_scream.t7 http://cs.stanford.edu/people/jcjohns/fast-neural-style/models/instance_norm/udnie.t7 http://cs.stanford.edu/people/jcjohns/fast-neural-style/models/eccv16/starry_night.t7 http://cs.stanford.edu/people/jcjohns/fast-neural-style/models/eccv16/the_wave.t7 http://cs.stanford.edu/people/jcjohns/fast-neural-style/models/eccv16/composition_vii.t7 </code></pre><h2 id="视频风格迁移"><a href="#视频风格迁移" class="headerlink" title="视频风格迁移"></a>视频风格迁移</h2><ul><li>将视频逐帧读取成图片 </li><li>处理图片干扰数据 </li><li>逐帧图片进行风格迁移 </li><li>将图片合成视频，将原视频的音频输出并整合到新视频。 </li></ul><p><a href="https://pan.baidu.com/s/1tC7KEGoq1bZOcf4Yt4WdTw" target="_blank">带pyinstaller的Python环境包下载</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenCV图像处理之1</title>
      <link href="/2020/09/10/diary-20200910-1/"/>
      <url>/2020/09/10/diary-20200910-1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>OpenCV全称Open Source Computer Vision Library。是一个基于BSD许可（开源）发行的跨平台计算机视觉库，可以运行在Linux、Windows和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供了Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。</p><p>OpenCV在Python中有两个类库，opencv-python和opencv-contrib-python，前者只包含主要模块的包。后者包含主要模块以及一些扩展模块，带一些收费或专利算法。 </p><p>安装完成后查看版本信息</p><pre><code>import cv2print(cv2.getVersionString())</code></pre><h2 id="opencv-python的安装"><a href="#opencv-python的安装" class="headerlink" title="opencv-python的安装"></a>opencv-python的安装</h2><pre><code>    python -m pip install opencv_python-4.4.0.42-cp36-cp36m-win32.whl</code></pre><p>安装numpy</p><pre><code>    python -m pip install numpy-1.16.3-cp36-cp36m-win32.whl</code></pre><p>安装opencv_contrib_python</p><pre><code>    python -m pip install opencv_contrib_python-4.4.0.42-cp36-cp36m-win32.whl</code></pre><p>安装Pillow</p><pre><code>    python -m pip install Pillow-7.2.0-cp36-cp36m-win32.whl</code></pre><h2 id="图像的基础知识"><a href="#图像的基础知识" class="headerlink" title="图像的基础知识"></a>图像的基础知识</h2><p>图像都是由像素（ pixel ）构成的，每一个都有自己明确的位置和被分配的色彩值，而这些小方格的颜色和位置就决定了这个图像所呈现出来的样子。<br>图像通常包括有 二值图像 、 灰度图像 和 彩色图像 。<br>二值图像就是在图像中，任何一个点非黑即白，像素要么为 255 （白色） 要么为 0 （黑色） 。转换的时候一般将像素 &gt;=127 的设置为白色，其余的设置为黑色。<br>灰度图像是除了黑白之外，还添加了第三种颜色：灰色，灰色把灰度划分为 256 个不同的亮度，例如纯白色，它的亮度级别是255。<br>图像转化为灰度图像有以下几种算法：</p><ul><li>浮点算法：Gray = R * 0.3 + G * 0.59 + B * 0.11 </li><li>整数方法：Gray = ( R * 30 + G * 59 + B * 11 ) / 100 </li><li>移位方法：Gray = ( R * 76 + G * 151 + B * 28 ) &gt;&gt; 8 </li><li>平均值法：Gray = ( R + G + B ) / 3 </li><li>仅取绿色：Gray = G </li><li>加权平均值算法：R = G = B = R * 0.299 + G * 0.587 + B * 0.144 </li></ul><p>彩色图像是RGB图像，RGB表示红、绿、蓝三原色，计算机里所有颜色都是三原色不同比例组成的，即三色通道。 </p><pre><code>import cv2 as cv# 读取图像img = cv.imread("2.jpg", cv.IMREAD_COLOR)cv.imshow("read_img", img)# 灰度图像img_gray = cv.cvtColor(img, cv.COLOR_RGB2GRAY)cv.imshow("gray_img",img_gray)# 二值图像ret, binary = cv.threshold(img_gray, 127, 255, cv.THRESH_BINARY)cv.imshow("binary_img", binary)key=cv.waitKey(-1)while(key!=27):    print('error exit')    key=cv.waitKey(-1)print('esc exit')cv.destroyAllWindows()</code></pre><h2 id="读取、展示和存储图像"><a href="#读取、展示和存储图像" class="headerlink" title="读取、展示和存储图像"></a>读取、展示和存储图像</h2><pre><code>import cv2img =cv2.imread('1.jpg',cv2.IMREAD_COLOR)cv2.imshow('image',img)cv2.imwrite('name1.jpg',img)key=cv2.waitKey(-1)while(key!=27):    print('error exit')    key=cv2.waitKey(-1)print('esc exit')cv2.destroyAllWindows()</code></pre><p>imread函数读取数字图像,函数参数一： 需要读入图像的完整的路径，函数参数二： 标志以什么形式读入图像。</p><ul><li>cv2.IMREAD_COLOR： 加载彩色图像。任何图像的透明度都将被忽略。它是默认标志 </li><li>cv2.IMREAD_GRAYSCALE： 以灰度模式加载图像 </li><li>cv2.IMREAD_UNCHANGED： 保留读取图片原有的颜色通道 </li><li>1 ： 等同于cv2.IMREAD_COLOR </li><li>0 ： 等同于cv2.IMREAD_GRAYSCALE </li><li>-1 ： 等同于cv2.IMREAD_UNCHANGED </li></ul><p>imshow函数作用是在窗口中显示图像，窗口自动适合于图像大小。 </p><p>imwrite函数检图像保存到本地。 </p><p>cv2.waitKey函数cv2.waitKey(time_of_milliseconds)</p><ul><li>time_of_milliseconds &gt; 0 ： 此时time_of_milliseconds表示时间，单位是毫秒，含义表示等待 time_of_milliseconds毫秒后。 </li><li>time_of_milliseconds &lt;= 0 ： 此时图像窗口将等待一个键盘敲击。返回按键的ASCII码  </li></ul><h2 id="输出文本"><a href="#输出文本" class="headerlink" title="输出文本"></a>输出文本</h2><p>处理图片的时候，我们经常会需要把一些信息直接以文字的形式输出在图片上，类似给图片加水印的效果。</p><pre><code>import cv2img =cv2.imread('1.jpg',cv2.IMREAD_COLOR)y=int(img.shape[1]/2) x=int(img.shape[0]/4) cv2.putText(img, "foot ball", (x,y), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)cv2.imshow('img', img)key=cv2.waitKey(-1)while(key!=27):    print('error exit')    key=cv2.waitKey(-1)print('esc exit')cv2.destroyAllWindows()</code></pre><h2 id="读取本地视频，调用摄像头"><a href="#读取本地视频，调用摄像头" class="headerlink" title="读取本地视频，调用摄像头"></a>读取本地视频，调用摄像头</h2><pre><code>import cv2#cap = cv2.VideoCapture(0)            #调用摄像头cap = cv2.VideoCapture('1.mp4')        #读取本地视频文件fps = cap.get(cv2.CAP_PROP_FPS)print('平均帧率 = ', fps)total_s = cap.get(cv2.CAP_PROP_FRAME_COUNT)print("总帧数 = ", total_s)while cap.isOpened():    ret, frame = cap.read()    if ret:        cv2.putText(frame, "foot ball", (40,40), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 0, 255), 2)        cv2.imshow('frame', frame)    if cv2.waitKey(1) &amp; 0xFF == ord('q'):        breakkey=cv2.waitKey(-1)while(key!=27):    print('error exit')    key=cv2.waitKey(-1)print('esc exit')cap.release()cv2.destroyAllWindows()</code></pre><h2 id="人脸检测"><a href="#人脸检测" class="headerlink" title="人脸检测"></a>人脸检测</h2><pre><code>import cv2import numpy as np# 人脸识别分类器faceCascade = cv2.CascadeClassifier(r'C:\HealthCenter\Apache24\Python\Lib\site-packages\cv2\data\haarcascade_frontalface_default.xml')# 识别眼睛的分类器eyeCascade = cv2.CascadeClassifier(r'C:\HealthCenter\Apache24\Python\Lib\site-packages\cv2\data\haarcascade_eye.xml')cap = cv2.VideoCapture(0)while cap.isOpened():    ret, frame = cap.read()    if ret:        gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)        # 人脸检测        faces=faceCascade.detectMultiScale(gray,scaleFactor=1.2,minNeighbors=5,minSize=(32,32))        result=[]        for(x,y,w,h) in faces:            cv2.rectangle(frame,(x,y),(x+w,y+h),(255,0,0),2)        # 在检测人脸的基础上检测眼睛        for (x, y, w, h) in faces:            fac_gray = gray[y: (y+h), x: (x+w)]            eyes = eyeCascade.detectMultiScale(fac_gray, 1.3, 2)            # 眼睛坐标的换算，将相对位置换成绝对位置            for (ex, ey, ew, eh) in eyes:                result.append((x+ex, y+ey, ew, eh))        for (ex, ey, ew, eh) in result:            cv2.rectangle(frame, (ex, ey), (ex+ew, ey+eh), (0, 255, 0), 2)        cv2.imshow('video',frame)    if cv2.waitKey(1) &amp; 0xFF == ord('q'):        breakkey=cv2.waitKey(-1)while(key!=27):    print('error exit')    key=cv2.waitKey(-1)print('esc exit')cap.release()cv2.destroyAllWindows()</code></pre><h2 id="人脸数据收集"><a href="#人脸数据收集" class="headerlink" title="人脸数据收集"></a>人脸数据收集</h2><pre><code>import cv2import numpy as np# 人脸识别分类器faceCascade = cv2.CascadeClassifier(r'C:\HealthCenter\Apache24\Python\Lib\site-packages\cv2\data\haarcascade_frontalface_default.xml')#cap = cv2.VideoCapture(0,cv2.CAP_DSHOW)cap = cv2.VideoCapture(0)face_id=input('\n enter user id:')count=0while cap.isOpened():    ret, frame = cap.read()    if ret:        gray=cv2.cvtColor(frame,cv2.COLOR_BGR2GRAY)        # 人脸检测        faces=faceCascade.detectMultiScale(gray,scaleFactor=1.4,minNeighbors=5,minSize=(32,32))        for(x,y,w,h) in faces:            cv2.rectangle(frame,(x,y),(x+w,y+h),(255,0,0),2)            count+=1            cv2.imwrite('Facedata/User_'+str(face_id)+'_'+str(count)+'.jpg',gray[y:y+h,x:x+w])        cv2.imshow('video',frame)    if cv2.waitKey(1) &amp; 0xFF == ord('q'):        break    elif count&gt;=100:        breakprint('本次样本采集结束，退出')cap.release()cv2.destroyAllWindows()</code></pre><h2 id="人脸数据训练"><a href="#人脸数据训练" class="headerlink" title="人脸数据训练"></a>人脸数据训练</h2><pre><code>import numpy as npfrom PIL import Imageimport osimport cv2# 人脸数据路径path = 'Facedata'recognizer = cv2.face.LBPHFaceRecognizer_create()detector = cv2.CascadeClassifier(r'C:\HealthCenter\Apache24\Python\Lib\site-packages\cv2\data\haarcascade_frontalface_default.xml')def getImagesAndLabels(path):    imagePaths = [os.path.join(path, f) for f in os.listdir(path)]  # join函数的作用？    faceSamples = []    ids = []    for imagePath in imagePaths:        PIL_img = Image.open(imagePath).convert('L')   # convert it to grayscale        img_numpy = np.array(PIL_img, 'uint8')        id = int(os.path.split(imagePath)[-1].split(".")[2])        faces = detector.detectMultiScale(img_numpy)        for (x, y, w, h) in faces:            faceSamples.append(img_numpy[y:y + h, x: x + w])            ids.append(id)    return faceSamples, idsprint('Training faces. It will take a few seconds. Wait ...')faces, ids = getImagesAndLabels(path)recognizer.train(faces, np.array(ids))# 提前新建文件夹face_trainerrecognizer.write(r'face_trainer\trainer.yml')print("{0} faces trained. Exiting Program".format(len(np.unique(ids))))</code></pre><h2 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h2><pre><code>import cv2recognizer = cv2.face.LBPHFaceRecognizer_create()recognizer.read('face_trainer/trainer.yml')faceCascade = cv2.CascadeClassifier(r'C:\HealthCenter\Apache24\Python\Lib\site-packages\cv2\data\haarcascade_frontalface_default.xml')font = cv2.FONT_HERSHEY_SIMPLEXidnum = 0names = ['Allen', 'Bob']cam = cv2.VideoCapture(0,cv2.CAP_DSHOW)minW = 0.1*cam.get(3)minH = 0.1*cam.get(4)while True:    ret, img = cam.read()    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)    faces = faceCascade.detectMultiScale(        gray,        scaleFactor=1.2,        minNeighbors=5,        minSize=(int(minW), int(minH))    )    for (x, y, w, h) in faces:        cv2.rectangle(img, (x, y), (x+w, y+h), (0, 255, 0), 2)        idnum, confidence = recognizer.predict(gray[y:y+h, x:x+w])        if confidence &lt; 100:            #print("识别到"+str(idnum))            #idnum = names[idnum]            confidence = "{0}%".format(round(100 - confidence))        else:            print('识别到unknown')            #idnum = "unknown"            confidence = "{0}%".format(round(100 - confidence))        cv2.putText(img, str(idnum), (x+5, y-5), font, 1, (0, 0, 255), 1)        cv2.putText(img, str(confidence), (x+5, y+h-5), font, 1, (0, 0, 0), 1)    cv2.imshow('camera', img)    k = cv2.waitKey(10)    if k == 27:        breakcam.release()cv2.destroyAllWindows()</code></pre><h2 id="色彩空间"><a href="#色彩空间" class="headerlink" title="色彩空间"></a>色彩空间</h2><blockquote><p>图像的颜色主要是由于图像受到外界光照影响随之产生的不同颜色信息，同一个背景物的图像在不同光源照射下产生的不同颜色效果的图像，因此在我们做图像特征提取和识别过程时，我们要的是图像的梯度信息，也就是图像的本质内容，而颜色信息会对我们对梯度信息提取造成一定的干扰，因此我们会在做图像特征提取和识别前将图像转化为灰度图，这样同时也降低了处理的数据量并且增强了处理效果。 </p></blockquote><p>在之后的图像特征提取和识别学习中，我们经常使用的是将彩色图像转化成灰度图像。</p><pre><code>图像色彩空间变换函数cv2.cvtColor cv2.cvtColor(input_image, flag)参数一： input_image表示将要变换色彩的图像ndarray对象。 参数二： 表示图像色彩空间变换的类型。常用类型如下cv2.COLOR_BGR2GRAY： 表示将图像从BGR空间转化成灰度图。 cv2.COLOR_BGR2HSV： 表示将图像从RGB空间转换到HSV空间。</code></pre><h2 id="绘制自定义数字图像"><a href="#绘制自定义数字图像" class="headerlink" title="绘制自定义数字图像"></a>绘制自定义数字图像</h2><h3 id="绘制简单图像"><a href="#绘制简单图像" class="headerlink" title="绘制简单图像"></a>绘制简单图像</h3><p>对于一个长宽分别为w、h的RGB彩色图像来说，它的每个像素值是由(B、G、R)的一个tuple组成，opencv-python中每个像素三个值的顺序是B、G、R，而对于灰度图像来说，每个像素对应的便只是一个整数，如果要把像素缩放到0、1，则灰度图像就是二值图像，0便是黑色，1便是白色。我们通过下面的例子来理解一下。</p><pre><code>import cv2rgb_img =cv2.imread('2.jpg')cv2.imshow('rgb_img',rgb_img)print(rgb_img.shape)        #(1200, 1600, 3)print(rgb_img[0, 0])        #[137 124  38]print(rgb_img[0, 0, 0])        #137gray_img = cv2.cvtColor(rgb_img, cv2.COLOR_BGR2GRAY)cv2.imshow('gray_img',gray_img)print(gray_img.shape)         #(1200, 1600)print(gray_img[0, 0])         #100key=cv2.waitKey(-1)while(key!=27):    print('error exit')    key=cv2.waitKey(-1)print('esc exit')cv2.destroyAllWindows()</code></pre><p>从上面我们可以看到彩色图像的高度height = 1200， 宽度w=1600且通道数为3， 像素(0， 0)的值是(137 124 38)，即R=137, G=124, B=38， 对于灰度图像来说便只是单通道的了</p><p>因此(0, 0, 0)便是代表一个黑色像素，(255, 255, 255)便是代表一个白色像素。这么想，B=0, G=0, R=0相当于关闭了颜色通道也就相当于无光照进入，所以图像整个是黑的，而(255, 255, 255)即B=255, G=255, R=255， 相当于打开了B、G、R所有通道光线全部进入，因此便是白色。</p><p>明白了上面的原理我们便可以通过创建numpy的ndarray对象来创建任意的彩色图像和灰度图像了。 </p><pre><code>import cv2import numpy as npwhite_img = np.ones((512,512,3), np.uint8)white_img = 255*white_imgcv2.imshow('white_img',white_img)key=cv2.waitKey(-1)while(key!=27):    print('error exit')    key=cv2.waitKey(-1)print('esc exit')cv2.destroyAllWindows()</code></pre><p>绘制简单几何图像 </p><p>公共参数: </p><ul><li>img:表示需要进行绘制的图像对象ndarray </li><li>color:绘制几何图形的颜色，采用BGR即上述说的(B、G、R) </li><li>thickness:绘制几何图形中线的粗细，默认为1，对于圆、椭圆等封闭图像取-1时是填充图形内部 </li><li>lineType:几何图形线的类型，默认8-connected线是光滑的，当取cv2.LINE_AA时线呈现锯齿状 </li></ul><p>直线绘制：cv2.line(img, starting, ending, color, thickness, lineType)<br>参数starting、ending分别表示线的起点像素坐标、终点像素坐标<br>长方形绘制：cv2.rectangle(image, top-left, bottom-right, color, thickness, lineType)<br>参数top-left、bottom-right分别表示长方形的左上角像素坐标、右下角像素坐标<br>圆形绘制：cv2.circle(image, center, radius, color, thickness, lineType)<br>参数center、radius分别表示圆的圆心像素坐标、圆的半径长度，圆绘制函数中当参数thickness = -1 时绘制的是实心圆，当thickness &gt;= 0 时绘制的是空心圆<br>椭圆绘制：cv2.circle(image, center, (major-axis-length, minor-axis-length), angle, startAngle, endAngle, color, thickness, lineType)<br>参数thickness = -1 时绘制的是实心椭圆，当thickness &gt;= 0 时绘制的是空心椭圆，其他参数如下 </p><ul><li>center： 表示椭圆中心像素坐标 </li><li>major-axis-length： 表示椭圆的长轴长度 </li><li>minor-axis-length： 表示椭圆的短轴长度 </li><li>angle： 表示椭圆在逆时针方向旋转的角度 </li><li>startAngle： 表示椭圆从主轴向顺时针方向测量的椭圆弧的起始角度 </li><li>endAngle： 表示椭圆从主轴向顺时针方向测量的椭圆弧的终止时角度  </li></ul><p>多边形绘制：cv2.polylines(image, [point-set], flag, color, thickness, lineType)<br>[point-set]： 表示多边形点的集合；<br>当flag = True 时，则多边形是封闭的，当flag = False 时，则多边形只是从第一个到最后一个点连线组成的图像，没有封闭<br>将上面五种几何图像绘制到开始的白色图像上，观看效果 </p><pre><code>import cv2import numpy as npimg = np.ones((512,512,3), np.uint8)img = 255*imgimg = cv2.line(img, (100,100), (400,400),(255, 0, 0), 5)img = cv2.rectangle(img,(200, 20),(400,120),(0,255,0),3)img = cv2.circle(img,(100,400), 50, (0,0,255), 2)img = cv2.circle(img,(250,400), 50, (0,0,255), 0)img = cv2.ellipse(img,(256,256),(100,50),0,0,180,(0, 255, 255), -1)pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)img = cv2.polylines(img,[pts],True,(0, 0, 0), 2)cv2.imshow('img',img)key=cv2.waitKey(-1)while(key!=27):    print('error exit')    key=cv2.waitKey(-1)print('esc exit')cv2.destroyAllWindows()</code></pre><h3 id="对图像的简单像素操作"><a href="#对图像的简单像素操作" class="headerlink" title="对图像的简单像素操作"></a>对图像的简单像素操作</h3><h4 id="对图像取反"><a href="#对图像取反" class="headerlink" title="对图像取反"></a>对图像取反</h4><pre><code>    reverse_img = 255 - gray_img</code></pre><h4 id="对图像像素线性变换"><a href="#对图像像素线性变换" class="headerlink" title="对图像像素线性变换"></a>对图像像素线性变换</h4><pre><code>    for i in range(gray_img.shape[0]):        for j in range(gray_img.shape[1]):            random_img[i, j] = gray_img[i, j]*1.2</code></pre><h2 id="OpenCV里数字图像的其他基本概念"><a href="#OpenCV里数字图像的其他基本概念" class="headerlink" title="OpenCV里数字图像的其他基本概念"></a>OpenCV里数字图像的其他基本概念</h2><h3 id="亮度"><a href="#亮度" class="headerlink" title="亮度"></a>亮度</h3><h3 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h3><h3 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h3><h3 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h3><h3 id="尖锐化"><a href="#尖锐化" class="headerlink" title="尖锐化"></a>尖锐化</h3><h2 id="OpenCV里数字图像的图像灰度变换"><a href="#OpenCV里数字图像的图像灰度变换" class="headerlink" title="OpenCV里数字图像的图像灰度变换"></a>OpenCV里数字图像的图像灰度变换</h2><h3 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h3><h3 id="分段线性"><a href="#分段线性" class="headerlink" title="分段线性"></a>分段线性</h3><h3 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h3><h3 id="反对数"><a href="#反对数" class="headerlink" title="反对数"></a>反对数</h3><h3 id="幂律-伽马-变换"><a href="#幂律-伽马-变换" class="headerlink" title="幂律(伽马)变换"></a>幂律(伽马)变换</h3><h2 id="OpenCV里的图像滤波操作"><a href="#OpenCV里的图像滤波操作" class="headerlink" title="OpenCV里的图像滤波操作"></a>OpenCV里的图像滤波操作</h2><h3 id="线性滤波"><a href="#线性滤波" class="headerlink" title="线性滤波"></a>线性滤波</h3><h3 id="非线性滤波"><a href="#非线性滤波" class="headerlink" title="非线性滤波"></a>非线性滤波</h3><h3 id="空间滤波"><a href="#空间滤波" class="headerlink" title="空间滤波"></a>空间滤波</h3><h3 id="频率域滤波"><a href="#频率域滤波" class="headerlink" title="频率域滤波"></a>频率域滤波</h3><h3 id="均值滤波"><a href="#均值滤波" class="headerlink" title="均值滤波"></a>均值滤波</h3><h3 id="中值滤波"><a href="#中值滤波" class="headerlink" title="中值滤波"></a>中值滤波</h3><h3 id="高斯滤波"><a href="#高斯滤波" class="headerlink" title="高斯滤波"></a>高斯滤波</h3><h3 id="逆滤波"><a href="#逆滤波" class="headerlink" title="逆滤波"></a>逆滤波</h3><h3 id="维纳滤波"><a href="#维纳滤波" class="headerlink" title="维纳滤波"></a>维纳滤波</h3><h2 id="OpenCV的文本图像倾斜矫正"><a href="#OpenCV的文本图像倾斜矫正" class="headerlink" title="OpenCV的文本图像倾斜矫正"></a>OpenCV的文本图像倾斜矫正</h2><h3 id="霍夫变换"><a href="#霍夫变换" class="headerlink" title="霍夫变换"></a>霍夫变换</h3><h3 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h3><h3 id="图像边缘检测"><a href="#图像边缘检测" class="headerlink" title="图像边缘检测"></a>图像边缘检测</h3><h4 id="canny算子"><a href="#canny算子" class="headerlink" title="canny算子"></a>canny算子</h4><h4 id="sobel算子"><a href="#sobel算子" class="headerlink" title="sobel算子"></a>sobel算子</h4><h4 id="Laplace算子"><a href="#Laplace算子" class="headerlink" title="Laplace算子"></a>Laplace算子</h4><h4 id="Scharr滤波器"><a href="#Scharr滤波器" class="headerlink" title="Scharr滤波器"></a>Scharr滤波器</h4><p><a href="https://pan.baidu.com/s/1AG6_hBxggO5-7A8So98Jsw" target="_blank">Python环境包下载</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> OpenCV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>医保卡到底怎么报销</title>
      <link href="/2020/09/04/diary-20200904-1/"/>
      <url>/2020/09/04/diary-20200904-1/</url>
      
        <content type="html"><![CDATA[<p>随便感个冒，买药就要几十上百，<br>随便去个医院门诊，五六百上千块分分钟就没了，<br>很多人都感觉肉疼，直呼现在简直是生不起病。<br>由于医保体系艰深复杂且枯燥，本文用情节互动小说的形式展开，让你沿着自己的故事路线去了解医保。</p><h2 id="01"><a href="#01" class="headerlink" title="01"></a>01</h2><p>你突然从床上醒来，手捂在肚子上，你感到你的肚子很痛。<br>当你正要起来喝口水时，在枕头旁看见了一张医保卡，<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_01_3666974d10ef60d99a833e3a37389_720w.jpg" alt=""><br>上面还贴着一张纸条：<br>“如果你的肚子还很疼的话，拿着这张医保卡去指定医院看医生，这张医保卡可以报销一部分钱。”<br>于是：<br>你拿着医保卡去指定医院看医生    –阅读03<br>你不知道这张卡的指定医院，打算查一下    –阅读02 </p><h2 id="02"><a href="#02" class="headerlink" title="02"></a>02</h2><p>你知道医保卡需要在医保定点医院和定点药店才能报销，于是你强忍疼痛，拿出手机，打算先查一查你这张卡绑定的医保定点医院和定点药房（俗称“两定点”）。<br>你经过下面的操作步骤：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_02_ac8f4c6a7997e25b991c9e8d79_720w.jpg" alt=""><br>领到了你手中这张实体社保卡的电子版社保卡，功能完全一样，只不过是解决了你容易忘带卡或者弄丢卡的问题。<br>跳转之后，你一眼就在那张电子版社保卡的下方“支持机构”那里发现了你手里这张社保卡绑定的定点医院和药房。<br>你肚子越发疼痛了起来，马上去看医生！    –阅读03 </p><h2 id="03"><a href="#03" class="headerlink" title="03"></a>03</h2><p>来到医院，你把医保卡递到挂号窗口，挂了消化科，挂号时把医保卡主动交给对方，用医保卡挂号是走医保报销程序的开始！<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_03_069cfffe0309ce98f5687cbda5_720w.jpg" alt=""><br>排了一会儿队，你终于见到了医生，大夫边听边在病历本上寥寥草草的写下几行字，抬起头面色凝重的对你说:<br>“小毛病，给你开点好药吃就行了”    –阅读04<br>“有点严重，你转到住院那边去吧”    –阅读05<br>“你这病的手术我们做不了，你得到外省大医院去”    –阅读06 </p><h2 id="04"><a href="#04" class="headerlink" title="04"></a>04</h2><p>你到收费处，交了处方单，又递了医保卡，窗口人员说要交2100。<br>你很震惊，“怎么交这么多钱？不是有医保吗？”<br>“医保已经报过了，这里是大医院，报销比例少，交的多很正常。”<br>你没想到一个肚子疼就要交这么多钱，于是离开窗口打算找个导诊台护士问问，<br>这才搞清楚医保门急诊报销的来龙去脉。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_04_20200904093052.jpg" alt="医保门急诊报销来龙去脉"><br>以上海市门急诊报销为例：</p><pre><code>在职人员门急诊报销时，先走医保个人账户当年计入的部分（刷医保卡，下同），花完这部分不够的进入自负段，自负段就是自己要先掏1500元，如果还不能覆盖门急诊费用，才进入医保报销的共负段。在共负段不同级别的医院报销比率不同，医院等级越高，报销比率越低。如果报销完还是不能覆盖门急诊医药费，剩下的部分再从医保个人账户历年累积的部分出，不够则自己掏钱。但如果是肾透析、癌症放化疗等大病，则可以报销到80%以上。退休人员报销比例整体比在职人员高20%左右。2001年后才退休的69岁以下人员，医保门急诊报销先走个人账户当年计入部分，不够再自掏腰包700元，然后才能享受医保报销，超过部分用个人账户历年累积支付，不够再自掏腰包。</code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_05_6eb2f3219736b98746343cd0b77_720w.jpg" alt="上海在职人员门急诊医保报销"><br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_06_6a50e536d70acab481dc76796a_720w.jpg" alt="上海退休人员门急诊医保报销"></p><p>举个门急诊报销的例子：</p><pre><code>小王25岁，医保卡里有3万元，其中5000元是当年划入，2.5万元是往年积累。乱吃东西去大医院看病，门诊报销上限2万元，看病花了5万元。</code></pre><p>5万元的支付顺序是<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_07_90d5766bd5f1d542dfc0f_720w.jpg" alt=""><br>5万元的支付结构是<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_08_ad6985ff39bd1dd830ca49_720w.jpg" alt=""> </p><p>你听完导诊护士的解释后，呆了半天，支支吾吾憋出来一句：“哦，真的少哈，那请问我这2100买啥了，咋这么贵？”<br>“你这是报销完2100，实际费用2955，里面有两只进口特效药，一支1000块，这都是不报的。“<br>你瞪大了眼睛，心想，既然是特效药，那就一定有非特效药，那个应该会报销，于是你打算去找医生。<br>果然，医生告诉你其实还有一些便宜的国产药，几十块钱一盒，在药店就能买到，<br>配合止痛药吃的话，三个星期左右就好了。 但是看你的病情比较急，怕拖久了有其他并发症，所以给你开的特效药，两支下去就能好。<br>于是，<br>你决定去药店买便宜药    –阅读15<br>你听医生的，买了特效药回家    –阅读18 </p><h2 id="05"><a href="#05" class="headerlink" title="05"></a>05</h2><p>你拿着住院通知单、病历到住院处办完住院手续后，又到收费处缴纳住院押金。<br>缴费前，你突然想起之前在网上看到的一个数据：中国人均住院费用9000多，于是你又去找那个导诊护士问住院费用医保怎么报。<br>护士告诉你，医保住院报销比例很高，一般能达到80%多，但各统筹地报销比例不一样。<br>拿上海举例，具体如下：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_10_b004b44350e69ffc7bf_720w.jpg" alt="上海在职人员住院医保报销"><br>在职人员住院报销，有个1500元的起付线，起付线以下，先将医保个人账户中往年积累的钱用掉，不够1500的自己掏钱补，如果没能覆盖住院费用，再进入医保报销的共负段。<br>共负段内住院费用医保统筹基金报销85%，其余部分用医保个人账户往年累积支付，不够再自己掏。<br>但医保住院统筹基金报销有最高限额，上海是53万，<br>超过最高支付限额的部分，由附加基金支付80%，剩下的20%自己承担。<br>退休人员的住院报销起付线低于在职人员，但报销比例高于在职人员。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_11_36490693461678cbc8d796_720w.jpg" alt="上海退休人员住院医保报销"><br>可以看到，在2000年前退休的人，医保住院报销的起付线只有700元，在此之后退休的起付线则为1200元。<br>起付线以下的费用先走个人账户往年积累，不够再自己掏。起付线以上退休人员可以报销到92%，剩下的还是先走个人账户往年积累，剩下的再自己掏钱承担。同样，超过报销限额53万的，由附加基金报销80%，自己承担20%。 </p><pre><code>举个住院报销的例子老王明年退休医保个人账号5万，其中1万当年划入，4万为往年积累。因病住院，住院报销上限53万。住院花了70万。</code></pre><p>70万的支付顺序为<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_12_309067d67e47d7fa863c_720w.jpg" alt=""><br>老王本次看病70万的支付结构为<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_13_0aeadb1e94f7a3f02_720w.jpg" alt=""><br>住院花70万，自己只出6.6万，可见医保是多大的福利，如果老王买了商业医疗险，这6.6万也有机会全额报销。<br>听完护士的解释，你觉得国家医保福利非常好，于是，你摸摸自己的口袋：<br>有钱，缴费住院    –阅读07<br>没钱，去门诊买药回家养病    –阅读08 </p><h2 id="06"><a href="#06" class="headerlink" title="06"></a>06</h2><p>你从没想到，自己一个肚子疼，居然闹到要去外地治。<br>可是说是要到外地治，你连外地有哪些医院能用医保卡都不知道，于是，你决定先在手机上查一查。<br>你经过如下的查询步骤：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_14_ecae0c587cd11d6061_720w.jpg" alt=""><br>并在医生的建议下来到一家外地医院，人生地不熟，你决定先去问导诊护士这边医保怎么报销。<br>你在口袋里翻找医保卡：<br>找到后交给导诊护士看    –阅读08<br>发现医保卡不见了    –阅读09</p><h2 id="07"><a href="#07" class="headerlink" title="07"></a>07</h2><p>交完了钱，护士领你到自己的病床，并告知一会儿医生会过来找你。<br>护士走后，你在病床上躺下来，全身瘫软，看病是个费心费神的事情，有个病床休息真的不容易。<br>接下来的几天：医生来看你，护士来换药，医生又来看你，护士又来换药，很快7天过去了。<br>这个时候，医生来了<br>他通知你明天就可以出院了    –阅读18<br>他通知你病情加重了，需要转院    –阅读11 </p><h2 id="08"><a href="#08" class="headerlink" title="08"></a>08</h2><p>护士看了你的医保卡，告诉你不是本地的不能直接报，因为医保实行的是地级统筹，跨统筹地异地就诊，要备案后才能直接拿医保卡结算。<br>她告诉你，异地就诊分为三种情况： </p><ul><li>长期异地就诊，比如你在上海参保，但是长期在北京居住，在北京生病就医，就属于长期异地就诊； </li><li>临时异地转诊，比如你在上海参保，但在上海治不了，转北京去了，就属于临时异地转诊； </li><li>临时异地就诊，比如你在上海参保，去北京旅游或出差的时候，生病了在北京就医，属于临时异地就诊。<br>三种情况处理方式不同，护士问你属于哪一种，<br>你的回答是：<br>长期异地就诊    –阅读10<br>临时异地转诊     –阅读11<br>临时异地就诊     –阅读12 </li></ul><h2 id="09"><a href="#09" class="headerlink" title="09"></a>09</h2><p>医保卡丢了，就没法报销了，你只能去补办。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_15_3773dc067e2589e673141_r.jpg" alt="医保卡补办步骤"><br>不同人群办的医保卡不一样<br>有工作的职工或自由职业者交的是职工医保；没工作的儿童、学生、家庭主妇等交的是城乡居民医保。<br>所以只需要确定你的身份：<br>职工或自由职业者     –阅读13<br>无工作的城镇居民     –阅读14 </p><h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><p>长期异地就诊，需要先去参保地的社保中心备案，去外地看病才能直接报销结算。<br>备案方式有两种：线上备案和线下备案。<br>有的统筹地开通了线上异地就诊备案渠道，可以在网站，公众号，APP上等直接办理备案，<br>例如上海异地就诊线上医保备案的步骤如下：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_16_86bcb893e65e66dd4a89d9_r.jpg" alt=""><br>审批成功后就可以去异地就医了。<br>如果走线下备案，需要带好本人身份证，医保卡，异地长期居住证到社保中心，填写《异地就医登记表》，审批过后就可以带着社保卡去异地就医了。<br>但医保卡异地报销也有一定的局限：医保卡异地报销只限于住院，门急诊只有部分城市会有；医保卡异地报销能报销哪些药品取决于你就诊地的医保政策，但能报销多少钱取决于参保地；如果办理了异地就医备案，则参保地医保报销资格可能会取消，也可能不取消，甚至可能需要取消备案后才能用。所以，有什么问题一定不要忘记拨打12333的电话问清楚！<br>你拿着医保卡去住院了    –阅读05 </p><h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><p>临时异地转诊需要有转诊证明，还要有《跨省转诊转院就医备案表》。<br>护士让你出示给她看，并解释说：“如果转院，会有转诊证明，没有转诊证明医保是不报销的，转诊证明主要是用来证明你的确需要转诊，防止一些病情不重的人也转诊，挤占大医院医疗资源。”<br>护士又说：“如果是转院的，转诊证明和《跨省转诊转院就医备案表》上一家医院自己会帮你弄好，你只需要拿着医保卡去就医结算就行。”<br>于是，<br>你拿着医保卡去住院了    –阅读05 </p><h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><p>临时异地就诊一般是不能直接结算的，需要自己先垫付全部费用，才能报销。<br>但部分地区只要在入院后5天内打12333备案，也可以直接结算，不过那仅限于因急诊而住院的费用。<br>临时异地就诊痊愈出院后，在3个月内带好身份证原件，社保卡原件、医疗费发票、费用清单、病历复印件、急症诊断证明、银行卡等到参保地的社保中心办理报销，不同的地方规定不同，去之前一定先拨打12333问清楚哪些材料该怎么准备。<br>听完护士的解释，<br>你拿着医保卡去住院了     –阅读05 </p><h2 id="13"><a href="#13" class="headerlink" title="13"></a>13</h2><p>职工或者自由职业者要办理职工医保，<br>公司交你工资基数的7%左右，你自己交你工资基数的2%左右，公司交的钱进入统筹账户，并且大约有30%划入你的个人账户，你交的钱全部都划入个人账户。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_17_a65925f502f840faa0e84776_720w.jpg" alt=""><br>但你的工资基数最低不能低于当地平均工资的60%，最高不能超过当地平均工资的3倍。<br>医保千万不能断缴，<br>一旦断缴，从断缴的第二个月起你就不能享受医保报销了，<br>断缴60天内补缴的，从补缴后的次月起才能报销，<br>断缴60-180天内补缴的，从补缴当月计算3个月后才能报销，<br>断缴180天以上才补缴的，6个月后才能报销，<br>要是一直不补缴。就直接清零重新参保。<br>医保连同其他社会保险一起影响着我们在大城市的买房、摇号、落户、子女上学等，<br>断缴了，也不是没有办法。<br>如果是因为离职而断缴，最好在本月15号以后再离职，在下月15号之前找到下家，这样就能接续上；<br>如果离职了暂时不找工作，也可以找个开公司的朋友，挂到他公司下面去缴，或者找家靠谱的代缴机构代缴；<br>如果是失业而断缴，只要领到失业金，每个月的医保还是会从你的失业金里面扣掉的，这样就不会断缴。</p><p>了解完职工医保的缴费和待遇之后，你：<br>想看下居民医保有多便宜    –阅读14<br>直接按步骤去补办医保卡    –阅读16 </p><h2 id="14"><a href="#14" class="headerlink" title="14"></a>14</h2><p>无工作的城镇居民办理的是城乡居民医保，城乡居民医保是由新农合和城居保合并而来，采取全国居民统一缴费，政府统一补助的方式收费。<br>2019年，每人缴费250元，政府每人补助520元，对于建档立卡的贫困户、低保户、计划生育子女等还有额外的补助。<br>城乡居民医保覆盖人群广泛，收费方式也多种多样，一般有七种：<br>通过当地办税服务大厅缴纳、银行柜面缴费、村（居）委会代收、委托银行代扣代缴，桌面版网上银行缴纳、手机银行缴纳、银行自助机等。我们平时用的支付宝，首页搜索“城乡居保缴费”就可以自助缴费。<br>每年的9月初到次年的2月末为城乡居民医保的缴费时间，一定不要错过。<br>“那城乡居民保险怎么报销？”你接着问。<br>城乡居民医保也设起付线，但不同等级的医院起付线不同，报销比例也不同。医院等级越高，起付线越高，报销比例则越低。<br>具体如下：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_18_0f285991b87ee4721c7b98c443_r.jpg" alt=""><br>在市里面的医院，城乡居保起付线高，报销少，县里面的医院起付线低，报销多，<br>如果是到市外医院就医，报销起付线为1500，而且2万元以下只报销45%，以上则报销70%。<br>城乡居保的报销限额：<br>门诊年累积报销额不超过5000，<br>住院每次不能超过200，每天可以报销10元，<br>手术费每次报销不超过1000元。<br>不同的地方规定不同，去之前也最好先问问<br>你听完：<br>决定再问问职工医保的情况     –阅读13<br>直接按步骤去补办医保卡         –阅读16 </p><h2 id="15"><a href="#15" class="headerlink" title="15"></a>15</h2><p>来到药房，你越发觉得肚子疼痛起来，<br>说明来意后导购员从架子上拿来两盒药，虽然也要几百块，但好在是报销的，你不担心。<br>你伸手去口袋里拿医保卡刷卡：<br>找到后交给收银            –阅读17<br>发现医保卡不见了        –阅读09 </p><h2 id="16"><a href="#16" class="headerlink" title="16"></a>16</h2><p>你已经知道自己要办什么医保卡了，但怎么办理又成了新的难题。<br>实际上办理医保卡非常简单，主要是三类人：<br>对于学生来说，有学校包办，不用操心；<br>对于上班族，有公司办事员处理，也不用操心；<br>对于没有工作的其他城乡居民，则需要自己到社保大厅办理。<br>你查到，办理医保卡，需要经过以下步骤：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/yibao_19_e700706f3c453b66242b12_r.jpg" alt=""><br>很快，15天过去了，你领到了你的社保卡 </p><p>于是去药房买药         –阅读15<br>于是去医院住院         –阅读05 </p><h2 id="17"><a href="#17" class="headerlink" title="17"></a>17</h2><p>收银员正在结账的时候，一位老药师走了进来，<br>看见你，一脸凝重的说：“脸色很黄很黑啊，你这个病不是买药吃就能解决的，我建议你最好到外地去看看，你要是去外地，属于长期异地就诊，最好先阅读10<br>你听完一脸懵，但也被吓着了，于是你<br>听老药师的，赶紧去外地治         –阅读06<br>不听老药师说的话，买了药回家     –阅读18 </p><h1 id="18"><a href="#18" class="headerlink" title="18"></a>18</h1><p>你推开门，带着一年疲惫和倦怠回到家，直接躺倒在床上，沉沉睡去。。。 。<br>过了一会儿不疼了，你倒头继续睡了                      –阅读01<br>半天还不见好，想起白天的事，你打算去外地看病         –阅读06</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是五险一金</title>
      <link href="/2020/09/03/diary-20200903-1/"/>
      <url>/2020/09/03/diary-20200903-1/</url>
      
        <content type="html"><![CDATA[<p>五险一金<br>五险指养老保险、医疗保险、失业保险、工伤保险和生育保险。<br>一金指住房公积金。</p><h2 id="养老保险"><a href="#养老保险" class="headerlink" title="养老保险"></a>养老保险</h2><p>所谓的养老保险，就是相当于在你的养老金账户存钱，退休之后，每月有一笔钱发放给你，用来保障老年生活！<br>养老金有一个很重要的特点，那就是可以一直领下去，条件只有一个：那就是你一直活着！即使你个人账户的余额已经用完，依然可以继续领。<br>而且，养老金会逐年上调的，你活得越久，每个月领取的钱也会越来越多！</p><p>每月到手的养老金=月基础养老金+月个人账户养老金。 </p><p>月基础养老金=（全省上年度所有职工的月平均工资+本人指数化月平均缴费工资）÷2×缴费年限×1%。<br>个人账户养老金=个人账户的余额÷计发月数（50岁为195、55岁为170、60岁为139）。</p><p>举例说明：</p><pre><code>陈某，男，武汉人。2016年满60岁退休，退休前他刚好交了15年的社保，共缴费119340元，其中个人账户的余额是：47736元。武汉市2016年所有在岗职工月平均工资为4708元，他在武汉平均工资的60%~300%之间，选择了60%作为缴费基数，所以他第一次领到的养老金是：月基础养老金：(4708+4708×0.6)÷2×15%=564.96元个人账户养老金：47736÷139=343.42元合计：564.96元+343.42元=908.38元根据2016年武汉市人均预期寿命（78岁），假设60岁的陈某还能领养老金18年，领取的时长是：18×12个月=216个月。那么，陈某退休后20年内，总共能领取的养老金总额是：908.38×216=195108.48元举例仅供参考，每个人的养老金根据当地工资水平、缴费年限、缴费档次的不同，而不一样。</code></pre><h3 id="养老金领取条件"><a href="#养老金领取条件" class="headerlink" title="养老金领取条件"></a>养老金领取条件</h3><p>两个条件：缴满15年和达到退休年龄。</p><ol><li>凡按规定参加城乡居民社会养老保险的人员年满60周岁(女性55岁)，且累计缴费年限满15年及以上的，未享受城镇职工基本养老保险待遇的，可按月享受养老金待遇。</li><li>城乡居民社会养老保险制度实施时，2012年7月1日以前已年满60周岁、未享受城镇职工基本养老保险待遇的，不用缴费，可以按月领取基础养老金。享受基础养老金的农村居民，其符合参保条件的子女应当参保缴费;积极引导享受基础养老金的城镇居民的子女按照规定参保缴费。</li><li>城乡居民社会养老保险制度实施时，距领取年龄不足15年的，应按年缴费，也允许补缴，累计缴费不超过15年，在2012年12月31日前补缴的，其补缴年限享受政府的缴费补贴;距领取年龄超过15年的，应当按年缴费，累计缴费不少于15年。参保后因各种原因中断缴费或者隔年补缴的，中断期间及补缴年限不享受政府的缴费补贴。</li></ol><ul><li>缴费时间越长，缴费基数越高，你退休后能拿到的钱就越多。</li><li>交社保的同时，公司也在帮你交（公司交的还更多）。如果你不交了，那公司的部分也停了，老板的便宜你也占不到了。</li><li>养老金的多少，与武汉的平均工资有关。如果你的工资低于武汉平均工资水平，那你更要交了！因为你工作中只需缴纳很少的养老保险，退休后反而能拿到较高的养老金。</li><li>如果停止参保，那么其他的社保待遇就不能享受，比如医保停了，去医院看病就不能报销。</li><li>15年是指累计缴纳的年限，中间可以有中断，不需要连续。只要交满12*15=180个月</li></ul><h3 id="养老金办理材料"><a href="#养老金办理材料" class="headerlink" title="养老金办理材料"></a>养老金办理材料</h3><p>填报《养老金存折户口名、帐号变更表》一式两份。</p><h3 id="养老金办理流程"><a href="#养老金办理流程" class="headerlink" title="养老金办理流程"></a>养老金办理流程</h3><p>养老金资格认证：所有退休的人每年都必须通过认证，才会按时发放退休金，带上身份证原件、户口簿原件和退休证原件到居委会登记办理即可。</p><ol><li>根据职工档案记载和相关缴费记录，计算退休职工的养老金待遇，并打印《职工退休养老金审核计算表》。</li><li>办理职工退休审核的单位在退休审核的次月15日后，到指定银行(邮局)领取存折，并及时发给职工本人，退休职工到银行(邮局)领取养老金;属于一次性支付的，在办理退休审核的次月15日后，职工本人到原单位领取。 </li></ol><h3 id="养老金办理地点"><a href="#养老金办理地点" class="headerlink" title="养老金办理地点"></a>养老金办理地点</h3><ol><li>江岸社保处 江岸区二七小路新江岸五村2号 51273800</li><li>江汉社保处 江汉区发展大道金家墩玉宇里一号 85617896</li><li>硚口社保处 桥口区解放大道461号 83888176</li><li>汉阳社保处 汉阳区马沧湖路258号 50468761</li><li>武昌社保处 武昌区小东门紫沙路特1号 87255307</li><li>青山社保处 青山区和平大道建设四路12号 51600516</li><li>洪山社保处 洪山区书城路18号 87223125</li><li>东湖新技术开发区分局 洪山区珞瑜路546号 67880231</li></ol><h2 id="医疗保险"><a href="#医疗保险" class="headerlink" title="医疗保险"></a>医疗保险</h2><p>基本医疗保险基金由统筹基金和个人帐户构成。</p><p>个人账户可支付以下费用：<br>1、定点零售药店购药费用，门诊、急诊医疗费用;<br>2、用于本人购买商业保险、意外伤害保险等;<br>3、基本医疗保险统筹基金起付标准以下的医疗费;<br>4、超过基本医疗保险统筹基金起付标准，按照比例承担个人应付费用;<br>5、个人账户不足支付部分时由本人支付。<br>统筹账户主要支付以下费用：<br>1、住院治疗的医疗费;<br>2、恶性肿瘤放射治疗、肾透析、肾移植后服抗排异药的门诊医疗费;<br>3、急诊抢救后收入住院治疗的病人，其住院前留观七日内的医疗费用。</p><p>城镇职工医疗保险设立最低缴费年限，达到缴费年限(男25年、女20年)的，退休后不再缴费即可享受基本医疗保险待遇；城镇居民医疗保险不设立最低缴费年限，必须每年缴费，不缴费不享受待遇。</p><p>一旦办理完成退休待遇以后，那么你的这个医保费用就不需要再继续缴纳了。待遇享受不同。现在居民医保和职工医保的政策大致相通，药品库相同。但居民医保的起付线、统筹基金支付限额、报销比例等等项目上和职工医保还是有些差别。总体来说，居民医保待遇上接近职工医保但仍有差距。</p><p>职工个人缴纳的基本医疗保险费，全部计入个人帐户。用人单位缴纳的基本医疗保险费分为两部分，一部分用于建立统筹基金，一部分划入个人帐户。<br>划入个人帐户的比例一般为用人单位缴费的30%左右，具体比例由统筹地区根据个人帐户的支付范围和职工年龄等因素确定。<br>要确定统筹基金的起付标准和最高支付限额，起付标准原则上控制在当地职工年平均工资的10%左右，最高支付限额原则上控制在当地职工年平均工资的4倍左右。<br>起付标准以下的医疗费用，从个人帐户中支付或由个人自付。起付标准以上、最高支付限额以下的医疗费用，主要从统筹基金中支付，个人也要负担一定比例。</p><p>2020年医疗改革办法后，公司缴纳的那部分钱将不会纳入个人账户；将普通门诊纳入报销范围，至少报销50%。门诊费用拟纳入报销，高血压、糖尿病等慢性病也能报销。个人账户使用范围拟扩至家属，医保卡家人也能用！</p><h3 id="城镇职工医保"><a href="#城镇职工医保" class="headerlink" title="城镇职工医保"></a>城镇职工医保</h3><p>是“职工社保”五险一金中的主要险种，其个人缴费以年限随工资费率而缴纳，职工费率是“人均工资基数”的11%，单位缴纳9%，个人工资代扣2%，单位9%纳入医保基金，个人代扣2%返还给个人医保卡，用于平时门诊。缴费年限长，男需缴纳25年，女需要缴纳20年年限，在未退休时，医保就是满足基本年限，仍不能停，一直缴到办理退休止，方可终身享受医疗保障。</p><h3 id="城镇居民医保"><a href="#城镇居民医保" class="headerlink" title="城镇居民医保"></a>城镇居民医保</h3><p>城镇居民医疗保险是以没有参加城镇职工医疗保险的城镇未成年人和没有工作的居民为主要参保对象的医疗保险制度。它是继城镇职工基本医疗保险制度和新型农村合作医疗制度推行后，党中央、国务院进一步解决广大人民群众医疗保障问题，不断完善医疗保障制度的重大举措。城乡居民医疗保险是城乡居民按年按地方标准定时缴纳，一年一缴，缴一年保障一年，一直缴到终生。2018年标准我得220元/人。住院同“职工社保医保”一样，缴纳“门坎费”，用药按“医疗保险药品目录”执行，报销比例从乡镇卫生院100%，到一类、二类、三类医疗机构依次按85%、75%、65%的比例报销。</p><ul><li>时间–职工医保缴满年限即可，而居民医保则需要每年都缴费参保。</li><li>对象–职工医保：有单位的职工，居民医保：未缴纳职工医保人群及老人、小孩。</li><li>方式–职工医保按月缴纳，居民医保按年缴纳。</li><li>比例–职工医保比居民医保的可选定点医院多，报销多。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>老社区</title>
      <link href="/2020/09/02/diary-20200902/"/>
      <url>/2020/09/02/diary-20200902/</url>
      
        <content type="html"><![CDATA[<p>昨天下午在派出所办完事。出来时已经下午4点多了。<br>这个派出所位于一个小区内部。大门口对着一个熙熙攘攘的广场，一撮老人围坐在树林下这个角落或那个角落打牌，一撮老人在广场中间打乒乓球。广场另一侧是个幼儿园，一群家长在门口等待着接小孩回家。这社区至少得快四十年了。炎炎夏日下，树林内，广场中，这些老人小孩青年家长过的好自在呀。<br>在石凳上坐一会的功夫，几个人经过，与黄冈黄石仙桃那些还挺有韵律的普通话相比，黄陂话在这识别度很高啊，都是黄陂人。。。<br>我自带语音识别是识别上饶附近口音。识别到的不多，民族大道上有家上饶附近人开的眼镜店，其它以坑为主。<br>回去的路上看到路边有人在争吵，凑过去观摩学习，一米八的打印机故障维修员在一边一言不发，一米六的女店长一张嘴说个不停。<br>我真应该多出来走走，也多说说。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搬家前清点一些碗筷</title>
      <link href="/2020/08/29/diary-20200829-1/"/>
      <url>/2020/08/29/diary-20200829-1/</url>
      
        <content type="html"><![CDATA[<p>这些是我妈6年前买的碗筷和一些厨房用品。上次搬家放在收纳盒和衣柜里一直没动过。  </p><p>这次准备带到新屋去，零零碎碎东西真不少，以前有人问我，”你这租的单间这多什么东西呀，怎么堆的这么高，满满当当的落脚的位置都没有?”，我回答，”讲不清楚，啥都有，大概就是一家三口的生活用品吧，我现在用不到，就放着呗。”  </p><p>还有个榨汁机。。。打开收纳盒的塑料扣件一碰就碎了。清点时看着几个勺子还有豆浆机的标签都没有撕，仿佛就是留着给今天的我看的。  </p><blockquote><p>“看！都是新的，带过去好好用”</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/649379056.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/1633530896.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/1296915013.jpg" alt=""><br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/394409203.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP面向对象小结</title>
      <link href="/2020/08/19/diary-20200819-2/"/>
      <url>/2020/08/19/diary-20200819-2/</url>
      
        <content type="html"><![CDATA[<p>面向对象三大特征：封装、继承、多态。</p><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>为了保护类，使用$this-&gt;方法名/属性名来封装方法或属性。</p><p>对属性或方法进行封装</p><pre><code>&lt;?php class Student{    private $name;             //封装了$name属性，方法也是如此。    function __construct(argument)    {    }    private    function say()    //对say这个方法进行封装。　    {    　　　　echo "hello world";    }} ?&gt;</code></pre><p>调用封装的方法或属性</p><pre><code>&lt;?phpclass Person{    private $name;        //对属性进行了封装，但是稍后的构造方法（__construct）对其进行了初始化，然后对这个属性进行了间接调用。故可以成功被调用。    private $sex;     private $age;    function __construct($name, $sex, $age)    {        $this-&gt;name = $name;        $this-&gt;sex = $sex;        $this-&gt;age = $age;    }    function say()    {        echo "我的名子叫：" . $this-&gt;name . " 性别：" . $this-&gt;sex . " 我的年龄是：" . $this-&gt;age."&lt;br /&gt;";    }}$p1 = new Person("张三", "男", 20);$p2 = new Person("李四", "女", 30);$p3 = new Person("王五", "男", 40);$p1-&gt;say();$p2-&gt;say();$p3-&gt;say();?&gt;</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>单继承，子类继承父类一切，一个子类只能继承一个父类，但使用interface接口可以实现继承多个父类。<br>方法重写：子类中的属性或方法跟父类相同即为重写。</p><pre><code>&lt;?php class human{    var $name;    var $sex;    var $age;    function __construct($name,$sex,$age)    {        $this-&gt;name=$name;        $this-&gt;sex=$sex;        $this-&gt;age=$age;    }}class Student extends human              #只能继承一个类human，也就好比一人只能有一个父亲{    var $dushu;    var $zuozuoye;    function study(){        echo "Myname is:".$this-&gt;name."Sex is:".$this-&gt;sex."Age is:".$this-&gt;age."&lt;br&gt;";    }}    $student1=new Student("张三","男",21);    $student2=new Student("李四","男",23);    $student3=new Student("王五","女",22);    $student1-&gt;study();    $student2-&gt;study();    $student3-&gt;study();?&gt;</code></pre><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>子类对父类进行了重写，所以父类在引用该方法时表现出的不同即为多态。</p><pre><code>&lt;?php interface test{  #声明一个test接口    function zhouchang(); #声明一个zhouchang方法    function mianji(); }class juxing implements test{    private $width;    private $height;    function __construct($width,$height)    {        $this-&gt;width = $width; #将输入的值(即"宽")赋值给$this-&gt;width        $this-&gt;height = $height;    }    function zhouchang(){        echo "矩形的周长：" .($this-&gt;width + $this-&gt;height)."&lt;br /&gt;";    }    function mianji(){        echo "矩形的面积：".($this-&gt;width * $this-&gt;height)."&lt;br /&gt;";    }}class yuanxing implements test #和矩形的一样的。不做讲解。{    private $r;    function __construct($r)    {        $this-&gt;r = $r;    }    function zhouchang(){        echo "圆形的周长：".(2 * 3.14 * $this-&gt;r)."&lt;br /&gt;";    }    function mianji(){        echo "圆形的面积：".(3.14 * $this-&gt;r * $this-&gt;r."&lt;br /&gt;");    }}$a = new juxing(1,2);$a -&gt; mianji();$b = new yuanxing(1,2);$b -&gt; zhouchang();?&gt;输出效果如下所示：矩形的面积：2圆形的周长：6.28</code></pre><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="static-静态"><a href="#static-静态" class="headerlink" title="static(静态)"></a>static(静态)</h3><p>类似全局变量，使用类名::方法名或属性名</p><pre><code>&lt;?php class Human{    public static $name="张大牛"; #这里将$name作为静态标识    public static function say()    {        echo "我是一个学生！";    }}class Person{    public static $name="王大帅";    public static function say()    {        echo "我是一个帅哥！！！";    }}echo Person::say()."&lt;br /&gt;";    #这里无需使用$this调用，因staic作用域为全局，所用调用方法自然不能用$this。格式：类名::方法或属性 也可以是self::方法或属性echo Human::say() ?&gt;</code></pre><h3 id="final-最终"><a href="#final-最终" class="headerlink" title="final(最终)"></a>final(最终)</h3><p>被修饰的类或方法不允许被重写。</p><h3 id="interface-接口"><a href="#interface-接口" class="headerlink" title="interface(接口)"></a>interface(接口)</h3><p>继承用extends，接口用implements,</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>const和static的功能不同，但使用的方法比较相似。在PHP中定义常量是通过调用define()函数来完成的，但要将类中的成员属性定义为常量，则只能使用const关键字。将类中的成员属性使用const关键字标识为常量，其访问的方式和静态成员一样，都可以通过类名或在成员的方法中使用self关键字访问，也不能用对象来访问。标识常量的属性是只读的，不能重新赋值，所以在声明常量时一定要给初值，因为没有其他方式后期为常量赋值。</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>使用这个关键字可以确定一个对象是类的实例、类的子类，还是实现了某个特定接口，并进行相应的操作。</p><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="private-私有"><a href="#private-私有" class="headerlink" title="private(私有)"></a>private(私有)</h3><p>只有自己可以使用和修改。</p><h3 id="public-公共"><a href="#public-公共" class="headerlink" title="public(公共)"></a>public(公共)</h3><p>谁都可以使用和修改。</p><h3 id="protected-受保护"><a href="#protected-受保护" class="headerlink" title="protected(受保护)"></a>protected(受保护)</h3><p>只有自己和子类可以调用。 </p><h3 id="abstract-抽象"><a href="#abstract-抽象" class="headerlink" title="abstract(抽象)"></a>abstract(抽象)</h3><p>在类里面定义的没有方法体的方法就是抽象方法。所谓的没有方法体指的是，在方法声明的时候没有大括号以及其中的内容，而是直接在声明时在方法名后加上分号结束，另外在声明抽象方法时还要加一个关键字“abstract”来修饰。<br>PHP抽象类应用要点：抽象方法不必实现具体的功能，由子类来完成。不能从抽象类创建对象，它的意义在于被扩展。抽象类通常具有抽象方法，方法中没有大括号。如果抽象方法有参数，那么子类的实现也必须有相同的参数个数。<br>声明一个抽象类，抽象方法</p><pre><code>&lt;?php abstract class test{         //声明一个test抽象类    public $name;    abstract public hello(); //声明一个抽象方法}?&gt;</code></pre><p>继承一个抽象类</p><pre><code>&lt;?php abstract class hello{    abstract public function test();}class nihao extends hello{    public function test(){        echo "hello world\n";    }}class wohao extends hello{    public function test(){        echo "我要成大牛！";    }}$a=new nihao;$a-&gt;test();?&gt;输出内容如下：hello world</code></pre><h3 id="interface-接口-1"><a href="#interface-接口-1" class="headerlink" title="interface(接口)"></a>interface(接口)</h3><p>接口的声明使用：interface，接口的继承使用：implements。<br>接口的声明以及接口的引用</p><pre><code>&lt;?php interface icaneat{           #使用interface声明一个接口    public function eat($food); //接口里面不需要有方法的实现}class Human implements icaneat{              //使用implements继承接口（不能使用extends），稍后要与接口对接的属性或者方法要与其一致。    public function eat($food){                //如该行所示，要与接口的属性或者方法一致。        echo "i eating ".$food."\n";           //实现了某一个接口之后，必须提供接口中定义的方法的具体实现。    }}$test=new Human();$test-&gt;eat('apple');?&gt;输出效果如下：i eating apple</code></pre><p>继承多个接口</p><pre><code>&lt;?php interface icaneat{    public function eat($food);}interface hello{    public fuction hello($nihao);}class Human implements icaneat,hello{       #使用逗号隔开即可实现对多个接口的继承    public function eat($food){        echo "i eating ".$food."\n";    }}$test=new Human();$test-&gt;eat('apple');?&gt;</code></pre><p>判断某个对象是否实现了某个接口</p><pre><code>&lt;?php interface test{    public function one($a);}interface test2{    public function two($b);}class chengdaniu implements test,test2{    public function one($a){        echo "我爱WEB安全技术！";    }    public function two($b){        echo "我要成大牛！";    }}$shi=new chengdaniu();var_dump($shi instanceof test);?&gt;输出效果如下所示：boolean true</code></pre><h2 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h2><p>序列化就是把本来不能直接存储的数据转换成可存储的数据，并且不会丢掉数据格式。</p><pre><code>serialize();</code></pre><p>反序列化就是把序列化的数据，转换成我们需要的格式。</p><pre><code>unserialize();</code></pre><p>示例</p><pre><code>&lt;?php    $sites = array('Google'=&gt;'$ser', 'Runoob'=&gt;'1111', 'Facebook'=&gt;333);    //序列化        $serialized_data = serialize($sites);    echo  $serialized_data;    //得到   a:3:{s:6:"Google";s:4:"$ser";s:6:"Runoob";s:4:"1111";s:8:"Facebook";i:333;}    //反序列化        $a = unserialize($serialized_data);    var_dump($a);    //得到  array(3) {        　　　["Google"]=&gt;        　　　string(4) "$ser"        　　　["Runoob"]=&gt;        　　　string(4) "1111"        　　　["Facebook"]=&gt;        　　　int(333)        　　}?&gt;</code></pre><h2 id="内部应用-this"><a href="#内部应用-this" class="headerlink" title="内部应用$this"></a>内部应用$this</h2><pre><code>&lt;?php class Person{    private $name;    private $age="21";        var $sex;    function play(){        echo "他正在玩儿呢";    }private    function Hello(){                //使用private封装hello方法。该方法不可直接调用。但是可以在内部使用$this调用。            echo "这个是被封装的内容";        }    function study(){        echo "他正在学习！&lt;br /&gt;";        $this-&gt;hello();                      //在这里调用了封装的hello    }}    $wangdaniu=new person;    $wangdaniu-&gt;study();?&gt;</code></pre><h2 id="构造方法和析构方法"><a href="#构造方法和析构方法" class="headerlink" title="构造方法和析构方法"></a>构造方法和析构方法</h2><p>构造方法会在创建对象之后自动调用。其名称为<strong>construct。析构函数是用来在对象关闭时完成的特殊工作，构析方法的名称必须为</strong>destruct，且构析方法不能带有参数。总的来说就是构造方法在一开始自动执行，析构方法在最后的时候自动执行。</p><pre><code>&lt;?php class Student{    var $name;    var $sex;    var $age;    function __construct($name,$sex,$age)    {        $this-&gt;name=$name;        $this-&gt;sex=$sex;        $this-&gt;age=$age;    }    function say(){        echo "我叫：".$this-&gt;name."我是一个".$this-&gt;sex."生"."我今年".$this-&gt;age."岁了&lt;br&gt;";    }    function __destruct(){        echo $this-&gt;name;    }}    $zhangsan=new Student("张三","男",21);    $lisi =new Student("李四","男",23);    $wangwu=new Student("王五","男",25);    $zhangsan-&gt;say();    $lisi-&gt;say();    $wangwu-&gt;say();?&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMWare14安装MacOS系统</title>
      <link href="/2020/08/19/diary-20200819-1/"/>
      <url>/2020/08/19/diary-20200819-1/</url>
      
        <content type="html"><![CDATA[<h2 id="安装VMware14"><a href="#安装VMware14" class="headerlink" title="安装VMware14"></a>安装VMware14</h2><h2 id="停止VMware服务"><a href="#停止VMware服务" class="headerlink" title="停止VMware服务"></a>停止VMware服务</h2><ul><li>win+R,运行services.msc打开服务。</li><li>停止VMware相关服务。<pre><code>VMware Authorization ServiceVMware DHCP ServiceVMware NAT ServiceVMware USB Arbitration ServiceVMware Workstation Service</code></pre></li></ul><h2 id="VMware里解锁mac选项unlocker"><a href="#VMware里解锁mac选项unlocker" class="headerlink" title="VMware里解锁mac选项unlocker"></a>VMware里解锁mac选项unlocker</h2><p>以管理员权限运行 Unlocker 文件下 win-install.cmd</p><h2 id="打开VMware创建Mac虚拟机"><a href="#打开VMware创建Mac虚拟机" class="headerlink" title="打开VMware创建Mac虚拟机"></a>打开VMware创建Mac虚拟机</h2><p>在虚拟机目录下找到相应macOS的.vmx文件用notepad打开，在smc.present = “TRUE” 后面添加了 smc.version = 0</p><h2 id="正常安装Mac系统"><a href="#正常安装Mac系统" class="headerlink" title="正常安装Mac系统"></a>正常安装Mac系统</h2><h2 id="将之前停掉的服务重新启动。ok"><a href="#将之前停掉的服务重新启动。ok" class="headerlink" title="将之前停掉的服务重新启动。ok"></a>将之前停掉的服务重新启动。ok</h2><h2 id="全屏显示"><a href="#全屏显示" class="headerlink" title="全屏显示"></a>全屏显示</h2><p>点击编辑虚拟机设置——CD/DVD(SATA)——使用ISO映像文件——浏览——选择darwin.iso。<br>进入Mac系统，安装刚才放入的VMware Tools,重启即可完全全屏。</p><p><a href="https://pan.baidu.com/s/1kz6Yw7V6ht9P8IbD6wIwDw" target="_blank">VMvare14MacOS_unlocker下载</a><br><br><a href="https://pan.baidu.com/s/1nvWGGM0l8VtuXbhxYhUG8Q" target="_blank">darwin.iso下载</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> MacOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过js将sqlite3数据库完整加载到客户端内存</title>
      <link href="/2020/08/18/diary-20200818-1/"/>
      <url>/2020/08/18/diary-20200818-1/</url>
      
        <content type="html"><![CDATA[<p>通过使用sql.js(version_0.5)，加载html时把服务端数据库(小型sqlite3)完整加载到客户端内存里来。之后增删查改都在客户端内存里完成。经测试流程是通的，应用场景比较奇怪。<br>内存里数据库如果有改动，浏览器没有权限直接更改服务端数据库，还是得通过调用服务器提供的接口来更改服务器数据库。</p><p>html网页内容:</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;h5操作sqlte3&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- &lt;input type="file" id="file"  /&gt;   &lt;input type="button" value="上传" onclick="uploadfile2()"  /&gt;--&gt;&lt;div id="mycontent"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="jquery-1.10.2.min.js"&gt;&lt;/script&gt;&lt;script src='dbtool/sql.js'&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;        function calcdb_createnewdb(){                        /*            //在内存里创建新的数据库                    var db = new SQL.Database();            sqlstr = "CREATE TABLE hello (a int, b char);";            sqlstr += "INSERT INTO hello VALUES (0, 'hello');";            sqlstr += "INSERT INTO hello VALUES (1, 'world');";            db.run(sqlstr);            var res = db.exec("SELECT * FROM hello");            console.log(res);            */        }                 function uploadfile2(){                    //从用户选择的文件创建数据库            var _fileObj = document.getElementById("file").files[0];                   var reader = new FileReader();                            reader.onload = function () {                                var Uints = new Uint8Array(reader.result);                var db = new SQL.Database(Uints);                //console.log(db);  //查看db里有哪些方法                var objRs = db.exec("SELECT * FROM myss");                console.log(objRs);                             };            reader.readAsArrayBuffer(_fileObj);         }        function getRemoteDB(){            //读取服务器上的数据库            var xhr = new XMLHttpRequest();            xhr.open('GET','dbtool/ss.db',true);            xhr.responseType = 'arraybuffer';            xhr.onload = function(e) {              var uInt8Array = new Uint8Array(this.response);              var db = new SQL.Database(uInt8Array);              console.log(db);              var contents = db.exec("SELECT * FROM myss");              //console.log(contents);            };            xhr.send();        }        var db;        function getRemoteDB_add(){            //读取服务器上的数据库            var xhr = new XMLHttpRequest();            xhr.open('GET','dbtool/ss.db',true);            xhr.responseType = 'arraybuffer';            xhr.onload = function(e) {                //加载数据库到内存中                var uInt8Array = new Uint8Array(this.response);                db = new SQL.Database(uInt8Array);                db.run("INSERT INTO myss(content,datetime) VALUES (?,?)",['abc','defh']);                db.run("UPDATE myss SET content=(?) WHERE datetime=(?)",['abcABC','defh']);                db.run("DELETE FROM myss WHERE datetime=(?)",['time1']);                var contents = db.exec("SELECT * FROM myss");                console.log(contents);                $('#mycontent').text(JSON.stringify(contents));                //上面的增、改、删都只是对载入内存中的数据进行变更，内存中的数据并没有存入磁盘                //修改数据后导出数据库,需要var fs =require("fs");这种浏览器针对本地磁盘文件的操作，浏览器似乎没有权限，感觉还是要通过调用服务端API来搞。                /*                    var data=db.export();                    var buffer=Buffer.from(data,'binary');                    fs.writeFileSync("d.sqlite", buffer);                */                //var data=db.export();  //返回uint8Array类型            };            xhr.send();        }        function uint8ArrayToArray1(uint8Array) {            //将uint8Array转化为Array，Array发送给服务器可以反序列化为byte[]保存为文件                        var array = [];            for (var i = 0; i &lt; uint8Array.byteLength; i++) {                array[i] = uint8Array[i];            }            return array;        }        function uint8ArrayToArray2(uint8Array) {            //将uint8Array转化为Array，Array发送给服务器可以反序列化为byte[]保存为文件                var array=Array.from(uint8Array);            return array;        }    $(document).ready(function(){         console.log("success");        getRemoteDB_add();        //getRemoteDB();        //calcdb_createnewdb();    });&lt;/script&gt;&lt;/html&gt;</code></pre><p><a href="https://pan.baidu.com/s/1pqaaqnmjwOkH3PtqIUWccQ" target="_blank">通过sql.js将sqlite3数据库完整加载到客户端内存</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> sqlite3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISC-V是什么</title>
      <link href="/2020/08/15/diary-20200815/"/>
      <url>/2020/08/15/diary-20200815/</url>
      
        <content type="html"><![CDATA[<p>最早是计算机的发展带动芯片的发展，最近十几年来越来越多其他设备开始使用芯片、有操作系统、有数据存储。特别是智能手机的出现带动芯片迅猛发展。目前热门的三种芯片架构X86、ARM和RISC-V。<br>X86是英特尔创造的，性能非常好，特别适用于电脑和笔记本，能够高效运行各种软件和执行各种指令。移动设备体积小，电池是自带的，不能够外界电源，要求设备续航能力很强，刚好ARM架构就满足了这一个条件。手机，平板，POS机，还包括穿戴的手表手环芯片，都是用ARM架构做的，主要原因就是功耗低续航能力强。<br>总而言之，X86是PC时代，带电源的设备用的架构，ARM是大多移动设备芯片架构，X86的优势是性能，ARM的优势是功耗。RICS-V是新一代移动硬件设备的芯片架构，但RICS-V是刚刚开始。</p><p>CPU只认识二进制编码，也就是只认识0和1。CPU最主要的功能是计算，可以算加法、减法、与或非等等的计算。也可以做内存存数取数的操作。那么你要让CPU计算，你就要告诉CPU你要算什么东西，这时候就要用机器语言。其实是二进制串。不同的体系结构，其实本质区别就在于它们的机器语言不一样。CPU能识别的机器语言也就是指令集了。所以说，本质区别是指令集不同。例如，同样是做一次加法，可能一个是用00001111，一个是用11000011，一个是用10100101，之类的，反正根本就是不一样的指令。还有一些其它的区别。那你可以想想，一段为ARM体系结构CPU写的机器语言，如果让MIPS体系结构的CPU来执行，结果会怎么样。不是无法识别就是识别错误，肯定是达不到这段程序预期的效果的。所以，ARM的CPU只能运行ARM程序，MIPD的CPU只能运行MIPS程序，一个CPU只能运行用它的指令集来写的程序。</p><p>指令系统诞生之初就有两种设计思想或者说流派，CISC（复杂指令集）和RISC（简单指令集），RISC的代表就是著名的ARM架构，专注于高性能，低功耗，小体积，主要应用于移动设备；而CISC的代表是x86架构，像常用的PC、服务器的CPU等等，专注于桌面，高性能和民用市场。CISC系统复杂庞大8086CPU的指令就有300多条，而大多数RISC只有几十条指令。x86系列指令集属于CISC是Intel的专利，其他人在取得Intel的授权前是不能够使用的。ARM、MIPS、RISC-V都是属于RISC，只是前两个是商业公司的专利产品，他人使用前要取得授权，RISC-V是加州大学伯克利分校以BSD协议分发的开源指令集，任何人可以免费使用，且不禁止商业用途。</p><p>生态的区别是怎么回事呢？比如windows为什么一度只能在x86的CPU上跑？因为windows是C和汇编写的，汇编语言基本和机器语言完美对应。汇编的那一部分，不同体系结构的机器语言不一样，汇编语言也不一样。如果要跑在ARM体系结构的CPU上，显然要把汇编这一部分用ARM汇编再写一遍，这个只能由微软来做，毕竟不开源，除了微软没人动的了。而微软一直不做，那自然就不行了，你总不能把x86版本的拿到ARM上跑的。可能还不光操作系统，连普通应用软件都有可能要针对某种具体的体系结构做优化，于是用到汇编语言或者机器语言（一般如果是人来写的话都是用汇编），那么这种软件也是只能在一种体系结构上跑的。也就是说，如果没人给你RISC-V写软件，你RISC-V就没有软件可用，毕竟不能拿ARM或者x86的软件来跑。</p><p>依靠开源和免费，RISC-V非常受大学和科研院所青睐，并有望在教学领域大展拳脚，而这又会给RISC-V培养源源不断的后备军。对于商业公司来说，由于ARM的授权费实在是太贵了，也有较强的动力去做RISC-V，给自己留一个备份，避免被绑死在ARM上。不过，RISC-V也存在一个隐忧，那就是缺乏强有力的主导者，进而导致破碎化的问题。当年的MIPS其实也非常学院派，MIPS阵营的商业公司可以自由添加指令，比如龙芯就以MIPS为基础添加了1000多条新指令，进而形成了自己的指令集LoongISA。这又使开发软件的时候，即便同样属于MIPS，也必须分为龙芯版和MIPS版……由于RISC-V也允许用户自己加新指令，这就有可能使RISC-V破碎化，也许未来华为、高通、谷歌开发出的RISC-V处理器虽然都属于RISC-V，但却不能跑同样一套软件。毕竟完全开放与有力的领导是一对矛盾，如果无法解决这个问题，恐怕 RISC-V 很难成长到能与X86和ARM争雄的水平。ARM、X86架构之所以这么强大，是因为多年以来X86、ARM架构已经建立了完整的生态，除了芯片设计的架构之外，其他的众多的周边产品都是围绕着这两个架构而来的，以合作的方式来完成相关的产品设计，这一点上RISC-V是很欠缺的，需要一家强有力的公司来推动才可行。</p><p>目前大家用RISC-V架构更多的是开发一些并不依赖生态的物联网芯片，也没打算去形成一个统一的生态。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> RISC-V </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git的基础操作</title>
      <link href="/2020/08/14/diary-20200814-1/"/>
      <url>/2020/08/14/diary-20200814-1/</url>
      
        <content type="html"><![CDATA[<h2 id="关于git"><a href="#关于git" class="headerlink" title="关于git"></a>关于git</h2><h3 id="git有三种状态"><a href="#git有三种状态" class="headerlink" title="git有三种状态"></a>git有三种状态</h3><p>你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域，如下图所示。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/git3statearea.jpg" alt=""></p><ul><li>Git 仓库：是 Git 用来保存项目的元数据和对象数据库的地方。这其它计算机克隆仓库时，拷贝的就是这里的数据。</li><li>工作目录：是对项目的某个版本独立提取出来的内容。这些从 Git 仓库提取出来的文件，放在磁盘上供你使用或修改。</li><li>暂存区域：是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作“索引“，不过一般说法还是叫暂存区域。</li></ul><h3 id="三种工作区域和三种文件状态关系"><a href="#三种工作区域和三种文件状态关系" class="headerlink" title="三种工作区域和三种文件状态关系"></a>三种工作区域和三种文件状态关系</h3><p>如果 Git 目录中保存着的特定版本文件，就属于已提交状态。<br>如果作了修改并已放入暂存区域，就属于已暂存状态。<br>如果自上次取出到工作目录，作了修改但还没有放到暂存区域，就是已修改状态。</p><h3 id="基本工作流程"><a href="#基本工作流程" class="headerlink" title="基本工作流程"></a>基本工作流程</h3><ol><li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录。</li></ol><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>克隆现有的仓库</p><pre><code>git clone </code></pre><p>查看当前项目的状态，如果有新修改未提交的操作会显示出来。</p><pre><code>git status </code></pre><p>将本地项目修改提交到本地暂存区。</p><pre><code>git add -u             //提交被修改(modified)和被删除(deleted)文件，不包括新文件(new)。git add .              //提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件。git add -A             //提交所有变化，包括以上2种。</code></pre><p>为暂存区里的改动写日志说明</p><pre><code>git commit -m '日志或说明'</code></pre><p>从另一个存储库或本地分支获取并集成(整合)。一般，如果你克隆别人的项目有更新，就可以使用这个命令，让你本地的代码也达到最新。</p><pre><code>git pull</code></pre><p>将代码提交到远程仓库，执行成功后，在远端上就可以看到你最新的代码了。</p><pre><code>git push</code></pre><p>可以将本地版本库回滚到指定版本</p><pre><code>git reset --hard 版本号         git push -f                 //如果需要同时回滚远程版本库，执行这个</code></pre><p>分支操作</p><pre><code>git branch test             //表示创建一个名字为test的分支git checkout test             //表示切换到test分支git checkout -b test         //创建和切换二合一，表示创建并切换到test分支git push -u origin test     //表示提交代码到远程仓库的test分支上git branch                     //查看当前分支git log                     //查看代码提交日志</code></pre><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><h3 id="本地修改后提交给远程"><a href="#本地修改后提交给远程" class="headerlink" title="本地修改后提交给远程"></a>本地修改后提交给远程</h3><p>本地修改代码提交给远程时，需要先（add）commit，然后pull，最后再push。而不是直接commit然后直接push。</p><ol><li>（add）commit 是为了告诉 git 我这次提交改了哪些东西,不然你只是改了但是 git 不知道你改了,也就无从判断比较。</li><li>pull是为了本地commit和远程commit的对比记录,git是按照文件的行数操作进行对比的,如果同时操作了某文件的同一行那么就会产生冲突,git也会把这个冲突给标记出来,这个时候就需要先把和你冲突的那个人拉过来问问保留谁的代码,然后在git add &amp;&amp; git commit &amp;&amp; git pull这三连,再次pull。是为了防止再你们协商的时候另一个人给又提交了一版东西,如果真发生了那流程重复一遍,通常没有冲突的时候就直接给你合并了,不会把你的代码给覆盖掉。</li><li>出现代码覆盖或者丢失的情况:比如AB两人的代码pull时候的版本都是1,A在本地提交了2,3并且推送到远程了,B进行修改的时候没有commit操作,他先自己写了东西,然后git pull这个时候B本地版本已经到3了,B在本地版本3的时候改了A写过的代码,再进行了git commit &amp;&amp; git push那么在远程版本中就是4,而且A的代码被覆盖了,所以说所有人都要先commit再pull,不然真的会覆盖代码的。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/localcodepushtoromote.jpg" alt="本地修改后提交给远端"></p><h3 id="分支的使用"><a href="#分支的使用" class="headerlink" title="分支的使用"></a>分支的使用</h3><p>创建分支，提交代码，在与maser分支合并，最后删除分支。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TexturePacker图集打包工具在Unity3D中的使用</title>
      <link href="/2020/08/13/diary-20200813-1/"/>
      <url>/2020/08/13/diary-20200813-1/</url>
      
        <content type="html"><![CDATA[<p>在游戏开发过程中，图片的使用是必不可少的，尤其是在UI部分，往往会使用大量的图片。如果每一张图片都是单独使用的话，实际上会对性能造成很大的损耗的。这时候我们往往是把需要的图片资源进行分类，然后按照需要打包成对应的图集。这样会方便管理和更新迭代，同时也减少了很多的性能开销。</p><h2 id="安装TexturePacker3-0-9"><a href="#安装TexturePacker3-0-9" class="headerlink" title="安装TexturePacker3.0.9"></a>安装TexturePacker3.0.9</h2><ul><li>Sprites选项卡中导入文件夹，制作图集</li><li>Output选项卡中Data Format选项选择Unity3d</li><li>Layout选项卡中取消Allow rotation</li><li>工具栏点击Publish导出unity3d所需的同名<em>.png和</em>.txt图集。</li></ul><h2 id="导入Unity3d"><a href="#导入Unity3d" class="headerlink" title="导入Unity3d"></a>导入Unity3d</h2><p>将unity3dAssets.rar内容导入unity3d2018.2.10f1的Assets目录下。<br>把导出的<em>.png和</em>.txt文件导入到unity工程中（两个文件必须在同一目录下），然后右键点击图集数据文件（<em>.txt文件），点击TexturePacker—Process to Sprite即可，此时</em>.png已被分割，其下多个sprite可以像普通图片一样拖拽使用。</p><p><a href="https://pan.baidu.com/s/1MLUhWAJ4j1LWslB25tmKJQ" target="_blank">Unity3D使用TexturePacker图集</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> unity3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu18.04下安装配置vsftpd</title>
      <link href="/2020/08/11/diary-20200811-1/"/>
      <url>/2020/08/11/diary-20200811-1/</url>
      
        <content type="html"><![CDATA[<p>首先解决ubuntu下vi不能正常使用上下左右方向键</p><pre><code>$sudo apt-get remove vim-common$sudo apt-get install vim</code></pre><p>vi常用操作：</p><ul><li>命令模式下输入”/字符串”可以进行查找字符串。</li><li>命令模式下按u，撤销上一步操作。</li></ul><h2 id="安装vsftpd"><a href="#安装vsftpd" class="headerlink" title="安装vsftpd"></a>安装vsftpd</h2><pre><code>sudo apt-get install vsftpd</code></pre><h3 id="匿名用户上传和下载"><a href="#匿名用户上传和下载" class="headerlink" title="匿名用户上传和下载"></a>匿名用户上传和下载</h3><p>查看vsftp默认目录</p><pre><code>cat /etc/passwd | grep ftp</code></pre><p>编辑配置</p><pre><code>sudo vi /etc/vsftpd.conf</code></pre><pre><code>anonymous_enable=YES      #允许匿名用户登录anon_upload_enable=YES    #打开匿名用户的上传权限 anon_mkdir_write_enable=YES    #打开匿名用户创建目录的权限anon_other_write_enable=YES    #打开匿名用户删除和重命名的权限（如需要，需自己添加）anon_umask=022    #匿名用户的掩码</code></pre><p>进入默认目录,新建一个目录，目录授权, 让匿名用户能够上传文件到此目录</p><pre><code>cd /srv/ftpsudo mkdir pubsudo chmod 777 -R /srv/ftp/pub</code></pre><p>至此，在/srv/ftp/pub目录这一层下，匿名用户可以自由新建删除文件文件夹。</p><h3 id="vsftpd常用命令"><a href="#vsftpd常用命令" class="headerlink" title="vsftpd常用命令"></a>vsftpd常用命令</h3><pre><code>service vsftpd start      //启动vsftpd服务service vsftpd stop        //停止vsftpd服务service vsftpd restart     //重启vsftpd服务service vsftpd status     //检查vsftpd运行状态</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express开发之初始化工程helloworld</title>
      <link href="/2020/08/10/diary-20200810-1/"/>
      <url>/2020/08/10/diary-20200810-1/</url>
      
        <content type="html"><![CDATA[<h2 id="关于Express"><a href="#关于Express" class="headerlink" title="关于Express"></a>关于Express</h2><p>express框架的基本操作：引入模块+创建服务器+返回文件+监听端口。<br>xpress框架的核心操作：</p><ol><li>设置中间件来响应HTTP请求。</li><li>定义了路由表用于执行不同的HTTP请求动作。</li><li>通过向模板传递参数来动态渲染HTML页面。</li></ol><p>在app.js里的var app=express()之前修改路由。</p><pre><code>    var mytestRouter = require('./routes/mytest');</code></pre><p>修改路由后需要重启express才生效。</p><p>相应位置新建中间件mytest.js文件示例</p><pre><code>var express = require('express');var router = express.Router();/*响应返回json格式的数据*///http://192.168.1.48:3000/mytest/getjsonrouter.get('/getjson', function(req, res, next) {  res.json({name:'lily',age:19});});/*响应返回jsonp格式的数据*///http://192.168.1.48:3000/mytest/getjsonprouter.get('/getjsonp', function(req, res, next) {    router.set('jsonp callback name','cb');    res.jsonp({name:'lily',age:28});});//http://192.168.1.48:3000/mytestrouter.get('/', function(req, res, next) {  res.send('dfasfsfa');});router.post('/postpage',function(req,res,next){    res.send('Hello POST');});module.exports = router;</code></pre><h2 id="搭建Express"><a href="#搭建Express" class="headerlink" title="搭建Express"></a>搭建Express</h2><p>node环境：node-v12.16.3-x64。<br>命令行进入目标文件夹，初始化express环境</p><pre><code>    npm init                                  //初始化项目    npm install express --save                //安装express    npm install express-generator --save    //安装express命令工具    npm install cookie-parser --save        //安装一些module中间件    npm install morgan --save    npm install jade --save    npm install body-parser --save    npm install multer --save</code></pre><p>新建express服务，会在当前目录下新建myapp服务器项目目录</p><pre><code>    express myapp</code></pre><p>进入新建的myapp服务器项目目录。<br>启动运行express项目后浏览器 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 访问成功。</p><pre><code>    npm start</code></pre><p><a href="https://pan.baidu.com/s/1Q8z77n1JY8enO_lhBqg8oQ" target="_blank">初始化express工程下载</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注册和登录的小例子</title>
      <link href="/2020/08/10/diary-20200810-2/"/>
      <url>/2020/08/10/diary-20200810-2/</url>
      
        <content type="html"><![CDATA[<h2 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h2><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;&lt;/title&gt;    &lt;style type="text/css"&gt;        html{font-size:12px;}        fieldset{width:520px; margin: 0 auto;}        legend{font-weight:bold; font-size:14px;}        label{float:left; width:70px; margin-left:10px;}        .left{margin-left:80px;}        .input{width:150px;}        span{color: #666666;}    &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div&gt;        &lt;fieldset&gt;            &lt;legend&gt;登录&lt;/legend&gt;            &lt;form name="LoginForm" method="post" action="xinliacc.php" onSubmit="return funLogin(this)"&gt;                     &lt;p&gt;                     &lt;label for="username" class="label"&gt;用户名:&lt;/label&gt;                     &lt;input id="username" name="username" type="text" class="input" /&gt;                     &lt;p/&gt;                     &lt;p&gt;                     &lt;label for="password" class="label"&gt;密 码:&lt;/label&gt;                     &lt;input id="password" name="password" type="password" class="input" /&gt;                     &lt;p/&gt;                     &lt;p&gt;                     &lt;input type="submit" name="submit" value="  确 定  " class="left" /&gt;                     &lt;/p&gt;             &lt;/form&gt;         &lt;/fieldset&gt;         &lt;/div&gt;        &lt;div&gt;        &lt;fieldset&gt;            &lt;legend&gt;注册&lt;/legend&gt;            &lt;form name="RegForm" method="post" action="xinliacc.php" onSubmit="return funReg(this)"&gt;                     &lt;p&gt;                     &lt;label for="usernameReg" class="label"&gt;用户名:&lt;/label&gt;                     &lt;input id="usernameReg" name="usernameReg" type="text" class="input" /&gt;                     &lt;p/&gt;                     &lt;p&gt;                     &lt;label for="passwordReg1" class="label"&gt;密 码:&lt;/label&gt;                     &lt;input id="passwordReg1" name="passwordReg1" type="password" class="input" /&gt;                     &lt;p/&gt;                     &lt;p&gt;                     &lt;label for="passwordReg2" class="label"&gt;密码确认:&lt;/label&gt;                     &lt;input id="passwordReg2" name="passwordReg2" type="password" class="input" /&gt;                     &lt;p/&gt;                     &lt;p&gt;                     &lt;input type="submit" name="submitReg" value="  确 定  " class="left" /&gt;                     &lt;/p&gt;            &lt;/form&gt;        &lt;/fieldset&gt;        &lt;/div&gt;    &lt;/body&gt;        &lt;script src="jquery-1.4.2.min.js"&gt;&lt;/script&gt;        &lt;script type="text/javascript"&gt;     function funLogin(formbody){        if(formbody.username.value==""||formbody.password.value==""){            alert("请检查输入用户名和密码");            return false;        }        var u=$("#username").val();        var p=$("#password").val();         $.ajax({                type:"POST",                url:"http://xxxxxx.net/assessment/reg.php",                data:{                    _action:'login',                    username:u,                    password:p                },                success:function(data){                                    var d=JSON.parse(data);                    alert(d.state+'   '+d.message);                }        });                return false;     }     function funReg(formbody){        if(formbody.usernameReg.value==""||formbody.passwordReg1.value==""||formbody.passwordReg2.value==""||formbody.passwordReg2.value!=formbody.passwordReg1.value){            alert("请检查用户名、密码及密码确认");            return false;        }        var u=$("#usernameReg").val();        var p=$("#passwordReg1").val();        $.ajax({                type:"POST",                url:"http://xxxxxx.net/assessment/reg.php",                data:{                    _action:'reg',                    username:u,                    password:p                },                success:function(data){                                    var d=JSON.parse(data);                    alert(d.state+'   '+d.message);                }        });                return false;     }    $(document).ready(function(){         console.log("加载完成");             });         &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="reg-php"><a href="#reg-php" class="headerlink" title="reg.php"></a>reg.php</h2><pre><code>&lt;?phpheader("Access-Control-Allow-Origin:*");header("Access-Control-Allow-Methods:*");header('Access-Control-Allow-Headers:x-requested-with,content-type');$action="";$arrRes=array();if(isset($_POST['_action'])){    $action = trim($_POST['_action']);}else{    $arrRes = array('state'=&gt;'Failed','message'=&gt;'AccessVolation');    echo json_encode($arrRes);    exit();}$username = $_POST['username'];$password = $_POST['password'];if(!preg_match('/^[\w\x80-\xff]{3,15}$/', $username)){    $arrRes = array('state'=&gt;'Failed','message'=&gt;'username non-meet the requirements');    echo json_encode($arrRes);    exit();}if(strlen($password) &lt; 6){    $arrRes = array('state'=&gt;'Failed','message'=&gt;'password non-meet the requirements');    echo json_encode($arrRes);    exit();}include('conn.php');switch($action){    case "reg":        $check_query = mysql_query("select * from xinlilogin where username='$username' limit 1");        if(mysql_fetch_array($check_query)){            $arrRes= array('state'=&gt;'Failed','message'=&gt;'username already exist');            echo json_encode($arrRes);                    }else{            $regdate =date("Y-m-d H:i:s");             $query ="INSERT INTO xinlilogin(username,password,regdate)VALUES(N'$username',N'$password',N'$regdate')";            if(mysql_query($query,$conn)){                                                             $arrRes = array('state'=&gt;'Success','message'=&gt;'regist successfully');                echo json_encode($arrRes);            }else{                                         $arrRes = array('state'=&gt;'Failed','message'=&gt;'server error');                echo json_encode($arrRes);            }                        }    break;    case "login":        $check_query = mysql_query("select * from xinlilogin where username='$username' and password='$password' limit 1");        if(mysql_fetch_array($check_query)){            $arrRes= array('state'=&gt;'Success','message'=&gt;'login successfully');            echo json_encode($arrRes);            }else{            $arrRes= array('state'=&gt;'Failed','message'=&gt;'login failed');            echo json_encode($arrRes);            }    break;    default:        $arrRes= array('state'=&gt;'Failed','message'=&gt;'error');        echo json_encode($arrRes);    break;}?&gt;</code></pre><h2 id="数据库表结构"><a href="#数据库表结构" class="headerlink" title="数据库表结构"></a>数据库表结构</h2><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/dbstructforlogreg.jpg" alt=""></p><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><p>常报这个错误 No ‘Access-Control-Allow-Origin’ header is present on the requested resource.<br>后台php里添加header(“Access-Control-Allow-Origin:*”);<br>依然报错 Cannot modify header information - headers already sent by<br>最后通过对以下几点自查解决问题。</p><p>服务端的php最开头添加</p><pre><code>header("Access-Control-Allow-Origin:*");header("Access-Control-Allow-Methods:*");header('Access-Control-Allow-Headers:x-requested-with,content-type');</code></pre><ul><li>header之前代码出错，PHP自动输出了提示语句。这种情况找出错误并解决即可，或者直接error_reporting(0)屏蔽错误输出。</li><li>PHP文件是UTF-8 BOM。这种情况可使用editplus之类编辑器将BOM去掉。</li><li>header之前有其他的输出。</li></ul><p><a href="https://pan.baidu.com/s/1Sk8xx8sU-OZZYZliR3ZW2Q" target="_blank">注册和登录demo下载</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unity3d实现物体沿指定的平滑曲线移动</title>
      <link href="/2020/08/07/diary-20200807-1/"/>
      <url>/2020/08/07/diary-20200807-1/</url>
      
        <content type="html"><![CDATA[<p>通过贝塞尔曲线连接指定节点，并实现物体沿该平滑曲线移动。<br>首先就是把关键节点保存起来，然后在通过贝塞尔的计算公式计算出两个节点之间的拟合点的集合，最后可以控制小球在运动的过程中通过走过的路径的长度作为下标，取出该长度下对应的坐标信息，从而实现小球沿规定路径移动。<br>首先是计算出指定轨迹的拟合点，保存到list中，就是只在初始化的时候计算出来，然后保存，后面可以一直沿用，如果是在运行边计算边使用计算量会偏大。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/02020080701.jpg" alt=""></p><pre><code>    #region 计算贝塞尔曲线的拟合点    //初始化算出所有的点的信息    void InitPoint()    {        //获取指定的点的信息        Vector3[] pointPos = new Vector3[basePoint.Length];        for (int i = 0; i &lt; pointPos.Length; i++)        {            pointPos[i] = basePoint[i].transform.position;        }        GetTrackPoint(pointPos);    }    /// &lt;summary&gt;    /// 根据设定节点 绘制指定的曲线    /// &lt;/summary&gt;    /// &lt;param name="track"&gt;所有指定节点的信息&lt;/param&gt;    public void GetTrackPoint(Vector3[] track)    {        Vector3[] vector3s = PathControlPointGenerator(track);        int SmoothAmount = track.Length * baseCount;        lineRender.positionCount = SmoothAmount;        for (int i = 1; i &lt; SmoothAmount; i++)        {            float pm = (float)i / SmoothAmount;            Vector3 currPt = Interp(vector3s, pm);            lineRender.SetPosition(i, currPt);            lsPoint.Add(currPt);        }    }    /// &lt;summary&gt;    /// 计算所有节点以及控制点坐标    /// &lt;/summary&gt;    /// &lt;param name="path"&gt;所有节点的存储数组&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public Vector3[] PathControlPointGenerator(Vector3[] path)    {        Vector3[] suppliedPath;        Vector3[] vector3s;        suppliedPath = path;        int offset = 2;        vector3s = new Vector3[suppliedPath.Length + offset];        Array.Copy(suppliedPath, 0, vector3s, 1, suppliedPath.Length);        vector3s[0] = vector3s[1] + (vector3s[1] - vector3s[2]);        vector3s[vector3s.Length - 1] = vector3s[vector3s.Length - 2] + (vector3s[vector3s.Length - 2] - vector3s[vector3s.Length - 3]);        if (vector3s[1] == vector3s[vector3s.Length - 2])        {            Vector3[] tmpLoopSpline = new Vector3[vector3s.Length];            Array.Copy(vector3s, tmpLoopSpline, vector3s.Length);            tmpLoopSpline[0] = tmpLoopSpline[tmpLoopSpline.Length - 3];            tmpLoopSpline[tmpLoopSpline.Length - 1] = tmpLoopSpline[2];            vector3s = new Vector3[tmpLoopSpline.Length];            Array.Copy(tmpLoopSpline, vector3s, tmpLoopSpline.Length);        }        return (vector3s);    }    /// &lt;summary&gt;    /// 计算曲线的任意点的位置    /// &lt;/summary&gt;    /// &lt;param name="pos"&gt;&lt;/param&gt;    /// &lt;param name="t"&gt;&lt;/param&gt;    /// &lt;returns&gt;&lt;/returns&gt;    public Vector3 Interp(Vector3[] pos, float t)    {        int length = pos.Length - 3;        int currPt = Mathf.Min(Mathf.FloorToInt(t * length), length - 1);        float u = t * (float)length - (float)currPt;        Vector3 a = pos[currPt];        Vector3 b = pos[currPt + 1];        Vector3 c = pos[currPt + 2];        Vector3 d = pos[currPt + 3];        return .5f * (           (-a + 3f * b - 3f * c + d) * (u * u * u)           + (2f * a - 5f * b + 4f * c - d) * (u * u)           + (-a + c) * u           + 2f * b       );    }    #endregion</code></pre><p>然后就是通过在update中移动小球，根据小球轨迹长度取出对应长度下的坐标信息赋值。</p><pre><code>    void Start()    {        lineRender = gameObject.GetComponent&lt;LineRenderer&gt;();        InitPoint();    }    void Update()    {        length += Time.deltaTime * speed;        if (length &gt;= lsPoint.Count - 1)        {            length = lsPoint.Count - 1;        }        sphere.transform.localPosition = lsPoint[(int)(length)];    }</code></pre><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/demobesizermove.gif" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> unity3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Unity3d输出webgl网页常用修改1</title>
      <link href="/2020/08/06/diary-20200806-1/"/>
      <url>/2020/08/06/diary-20200806-1/</url>
      
        <content type="html"><![CDATA[<h2 id="webgl与web之间的通信"><a href="#webgl与web之间的通信" class="headerlink" title="webgl与web之间的通信"></a>webgl与web之间的通信</h2><p>unity3d 2018.2.10f1里定义脚本，附加到Canvas上，脚本里对应public变量赋好值</p><pre><code>using System.Collections;using System.Collections.Generic;using UnityEngine;using UnityEngine.UI;public class TestWebgl : MonoBehaviour {    public InputField youInput;    public Text youText;    void Start () {    }    void Update () {    }    public void OnClickBtn1() {        UnityToWeb();    }    public void UnityToWeb() {        Application.ExternalCall("GetFromUnity", youInput.text.Trim());    }    public void WebToUnity(string s) {        youText.text = s;    }}</code></pre><p>打包输出webgl网页里修改内容index.html</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en-us"&gt;  &lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;    &lt;title&gt;Unity WebGL Player | hiwebgl&lt;/title&gt;    &lt;link rel="shortcut icon" href="TemplateData/favicon.ico"&gt;    &lt;link rel="stylesheet" href="TemplateData/style.css"&gt;    &lt;script src="TemplateData/UnityProgress.js"&gt;&lt;/script&gt;      &lt;script src="Build/UnityLoader.js"&gt;&lt;/script&gt;    &lt;script&gt;      var gameInstance = UnityLoader.instantiate("gameContainer", "Build/debug.json", {onProgress: UnityProgress});    &lt;/script&gt;    &lt;script&gt;        function GetFromUnity(str){            var content=document.getElementById("TextInUnity");            content.innerText=str;        }        function WebToUnity(s){            gameInstance.SendMessage("Canvas","WebToUnity",s);        }    &lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div&gt;&lt;h1 id="TextInUnity"&gt;标题&lt;/h1&gt;    &lt;button type="button" onclick="WebToUnity('Helloworld')"&gt;Click&lt;/button&gt;    &lt;/div&gt;    &lt;div class="webgl-content"&gt;      &lt;div id="gameContainer" style="width: 960px; height: 600px"&gt;&lt;/div&gt;      &lt;div class="footer"&gt;        &lt;div class="webgl-logo"&gt;&lt;/div&gt;        &lt;div class="fullscreen" onclick="gameInstance.SetFullscreen(1)"&gt;&lt;/div&gt;        &lt;div class="title"&gt;hiwebgl&lt;/div&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="WebGL时UI界面随浏览器自适应"><a href="#WebGL时UI界面随浏览器自适应" class="headerlink" title="WebGL时UI界面随浏览器自适应"></a>WebGL时UI界面随浏览器自适应</h2><ul><li><p>方法1：在生成的html里面修改代码</p><pre><code>function Reset() {   var canvas = document.getElementById("#canvas");   canvas.height= document.documentElement.clientHeight;   canvas.width = document.documentElement.clientWidth;   console.log(canvas.width );}</code></pre></li><li><p>方法2: 在生成的html里面修改代码</p><pre><code>将&lt;div id="unityContainer" style="width: 960px; height: 600px"&gt;&lt;/div&gt;修改为&lt;div id="unityContainer" style="width: 99vw; height: 95vh;"&gt;&lt;/div&gt;</code></pre><p>修改后<br>width: 99vw 即在左右留一白边。<br>height: 95vh 设置为95可以正好将网页底端，显示项目名和Logo那一部分显示出来。</p></li><li><p>一个html模板</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en-us"&gt;&lt;head&gt;  &lt;meta charset="utf-8"&gt;  &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;  &lt;title&gt;Unity WebGL Player&lt;/title&gt;  &lt;link rel="shortcut icon" href="TemplateData/favicon.ico"&gt;  &lt;link rel="stylesheet" href="TemplateData/style.css"&gt;  &lt;script src="TemplateData/UnityProgress.js"&gt;&lt;/script&gt;     &lt;script src="Build/UnityLoader.js"&gt;&lt;/script&gt;  &lt;script src="jquery-1.4.2.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var  gameInstance;      $(function () {                      var resizeGmContainer = function () {              var docWidth = $(window).width();              var docHeight = $(window).height();              var gmContainer = document.querySelector('#gameContainer');              gmContainer.style.width = docWidth + 'px';              gmContainer.style.height = docHeight + 'px';              if(gameInstance != null) {                  gameInstance.Module.canvas.style.width = docWidth + 'px';                  gameInstance.Module.canvas.style.height = docHeight + 'px';              }              console.log(docWidth+"   "+docHeight);          };          resizeGmContainer();          $(window).resize(resizeGmContainer);          gameInstance = UnityLoader.instantiate("gameContainer", "Build/debug.json", {onProgress: UnityProgress});      });  &lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class="webgl-content"&gt;    &lt;div id="gameContainer" style=""&gt;&lt;/div&gt;    &lt;div class="footer"&gt;      &lt;div class="webgl-logo"&gt;&lt;/div&gt;      &lt;div class="fullscreen" onclick="gameInstance.SetFullscreen(1)" &gt;&lt;/div&gt;      &lt;div class="title"&gt;123&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> webgl </tag>
            
            <tag> unity3d </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于vue的登陆页上下空白处自适应等高</title>
      <link href="/2020/08/04/diary-20200804-2/"/>
      <url>/2020/08/04/diary-20200804-2/</url>
      
        <content type="html"><![CDATA[<p>data中先定义</p><pre><code>    data() {        return {          windowHeight: "",           topHeight: ""        };    },</code></pre><p>mounted中：</p><pre><code>    mounted() {        this.windowHeight = window.innerHeight;  // 浏览器可见区域高度        this.topHeight = (this.windowHeight - 600) / 2 + "px"; // 浏览器可见区域高度 - 600为背景图高度 / 2 = 平均上下高度        window.onresize = () =&gt; {          return (() =&gt; {            this.windowHeight = window.innerHeight;            this.topHeight = (this.windowHeight - 600) / 2 + "px";          })();        };    }</code></pre><p>mouted为界面加载时执行的方法，那么，应该怎么监听到mouned中的 window.onresize呢？</p><pre><code>    // 使用vue的watch事件监听    watch: {         topHeight(val) {          this.topHeight = val;        }    },</code></pre><p>再在顶部元素中绑定style即可。</p><pre><code>    &lt;div :style="{height:topHeight}"&gt;        &lt;span&gt;xx管理平台&lt;/span&gt;    &lt;/div&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>婚礼流程细节安排参考</title>
      <link href="/2020/08/04/diary-20200804-1/"/>
      <url>/2020/08/04/diary-20200804-1/</url>
      
        <content type="html"><![CDATA[<p>史上最全结婚流程安排表 面对结婚这道“复杂”的工序，如果能有一张流程表，自上到下地列出什么时候该做什么，就不至于不知所措。小编为你罗列一个最详细的婚礼流程安排表。</p><p>这个流程表十分详细正式。各位在参考之时，可根据自己的实际情况，选择一些必要的步骤进行采纳哟 </p><ul><li><p>1.1.决定婚礼日期、地点、仪式及婚宴方式 </p></li><li><p>1.2.确定婚礼预算 </p></li><li><p>1.3.草拟客人名单 </p></li><li><p>1.4.召集好朋友讨论婚礼计划 </p></li><li><p>1.5.确定伴郎、伴娘 </p></li><li><p>1.6.确定主婚人、证婚人 </p></li><li><p>1.7.成立婚礼筹备组 制定婚礼项目计划书 明确筹备组分工  </p></li><li><p>2.1.与婚礼的所有项目干系人沟通 就婚礼筹备计划和进展与父母沟通 发喜贴给亲友 电话通知外地亲友 网上发布结婚通知 再次确认主、证婚人 及时反馈亲友受邀信息 对于重要亲友再次确认</p></li><li><p>2.2.结婚物品采购 新家布置用品 家电、家具 床上用品 彩色气球 彩灯（冷光） 纱 蜡烛 胶布 插线板 其他物品 婚礼用品订购 新郎新娘婚纱礼服 结婚戒指 新娘化妆品 喜贴、红包、喜字 彩带、拉花、喷物 烟、酒、饮料 糖、花生、瓜子、茶叶 录像带、胶卷 预定鲜花 预定蛋糕 水果 蜡烛 </p></li><li><p>2.3.新郎新娘形象准备 新娘开始皮肤保养 新郎剪头发 </p></li><li><p>2.4.拍婚纱照 挑选婚纱摄影 预约拍摄日期 拍照 选片 冲印或喷绘 </p></li><li><p>2.5.布置新房 请清洁公司彻底打扫新房 布置新房 </p></li><li><p>2.6.确定婚礼主持人 就婚礼当天计划与设想与之沟通 </p></li><li><p>2.7.婚宴预约 估计来宾人数 估计酒席数量 选择婚宴地点 确认酒席菜单、价格 确认婚宴现场的音响效果 与酒店协调婚宴布置等细节 预定酒席 </p></li><li><p>2.8.婚礼化妆预约 选择化妆地点 与发型师、化妆师沟通 确认婚礼当天的造型 预约化妆具体时间 </p></li><li><p>2.9.婚庆车辆预约 确定婚车数量 选定婚车司机 预约扎彩车时间地点 确定婚礼当天婚车行进路线及所需时间 预约婚车 </p></li><li><p>2.10.婚庆影像预约 确定摄影摄像数量 选定婚礼当天摄影摄像人员 安排摄影摄像分工 准备摄像器材 预约摄影摄像 </p></li><li><p>2.11.其他 调换崭新钞票 确定滚床儿童 为远道而来的亲友准备客房  </p></li><li><p>3.1.与婚礼的所有项目干系人沟通 就婚礼准备工作完成情况与父母沟通 就准备情况和婚礼当天分工与筹备组作最后沟通 根据准备情况就婚礼当天仪式进程与主持人作最后沟通 与伴郎伴娘再次沟通 最后确认帮忙的亲友 最后确认婚宴、车辆、影像、化妆等细节准备情况 </p></li><li><p>3.2.确认婚礼当天要发言人的准备情况 主证婚人发言准备情况 父母代表发言准备情况 来宾代表发言准备情况 抢亲时新娘提问准备 新郎新娘在仪式上或闹洞房可能会遇到的问题 </p></li><li><p>3.3.最后确认婚礼当天所有物品准备情况 最后试穿所有礼服 将婚礼当天要穿的所有服装分装口袋 准备两瓶假酒 准备婚礼当天新郎新娘的快餐干粮 最后检查所有物品并交于专人保管 新娘的新鞋 结婚证书 戒指 红包 要佩戴的首饰 新娘补妆盒 糖、烟、酒、茶、饮料 焰火道具 烛台、婚礼蜡烛 </p></li><li><p>3.4.新郎新娘特别准备 新郎新娘反复熟悉婚礼程序 预演背新娘动作 预演婚礼进行台步 预演交杯酒动作 放松心情，互相鼓励 注意睡眠，早点休息 </p></li><li><p>3.5.准备闹钟 一只正常工作的闹钟 将闹钟调到5点半  </p></li><li><p>4.1.化妆 5点30起床 7点新郎发型做好后到达女方娘家附近等待 7点45新娘妆完成，通知新郎 化妆师红包</p></li><li><p>4.2.婚车 6点30开始扎彩车 7点专车送新郎至女方娘家附近 7点30彩车完成 7点45专车送新娘回娘家（8：30前到达） 9点所有婚车到达女方娘家 司机红包 </p></li><li><p>4.3.抢新娘 8点伴郎准备好鲜花、红包 8点30新娘回到娘家，藏好新鞋 8点40新郎带领兄弟们开始抢人 8点45敲门、盘问、塞红包、挤门 8点55新郎找新鞋，向女方家人承诺 9点彩带师到位气球到位<br>9点5分新郎背新娘出门，彩带，踩气球 9点10车队出发 </p></li><li><p>4.4.迎新娘 10点车队到达男方家 </p></li><li><p>4.4.10点5新郎抱新娘进门，彩带，踩气球 10点10小孩子滚床 10点15伴娘准备好茶 10点20新娘给男方父母敬茶 10点40新郎新娘出发至酒店 </p></li><li><p>4.5.酒店准备 将糖、烟、酒、茶、饮料等带至酒店 10点10最后检查酒席安排、音响、签到处等细节 10点30准备好新郎新娘迎宾香烟火柴糖 10点45彩带师到位酒店门口</p></li><li><p>4.6.酒店迎宾 10点50新郎新娘到酒店，彩带 11点签到处人员就位 11点引导人员门口就位 11点新郎新娘门口迎宾 </p></li><li><p>4.7.婚礼仪式 12点15主持人准备 12点15音响准备 12点15结婚证书、戒指准备 12点15气球、彩带到位.12点20奏乐，新人入场，彩带、踩气球，主持人介绍，主婚人致词，证婚人宣读结婚证书，新人父母上台，新郎新娘交换戒指，三鞠躬，新人给父母敬茶，双方父母代表讲话，双方父母退场，开香槟，切蛋糕，喝交杯酒，游戏 13点婚宴正式开始 13点新郎新娘退场、速食，新娘换礼服 13点15新郎新娘逐桌敬酒 14点宴席结束，宾客与新人合影 </p></li><li><p>4.8.下午休息 14点宾客离开 14点30新郎新娘进餐、休息 14点30清点所剩烟酒糖等 14点30统计晚餐人数 </p></li><li><p>4.9.晚餐  17点通知酒店晚餐准备数量 18点请宾客进晚餐 20点清点所有物品，离开酒店 </p></li><li><p>4.10.闹洞房 21点开始闹洞房，女方藏结婚证，新郎找结婚证，其它节目自由发挥 22点30宾客离开</p></li><li><p>4.11.摄像摄影 摄像a从新娘化妆开始全程拍摄新娘 摄像b从新郎抢亲开始全程拍摄新郎 摄像c拍摄婚礼仪式全过程 摄影适时拍摄 摄影摄像人员红包  </p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="data:image/png;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCABWAFgDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9Us4rj/iL8S/Dfwp8LXXiLxRq1voujWm1ZLidz/F91UVeWY9gOa62WZYkLN90DJPYCvlbw9pkH7RX7QUXjW/cX3w98MwS2XhuxuFJivb0n9/fiPoQoBjQnnuBTSb2A6LT/wBqHX/Gckc3gD4NeMvE2jld/wDa2oiLRYpV9YlunV5R74rUi+I3xtkb7Y/wh0xLHp/Z7+KIjf7fwj8jP/bSvbIolhULGoAA+6AB+AxwBVnYvpUgfP0/7WMPhS/ksviF8PfGfghtu6C4/syTV7ef2Elisyg/7+K2vC/7X3wb8YapBpemfELQzqk52JYXU5tZy/8Ad2SqrbvbGa9hMWY9oXb/ALPQD6cGuA8f/BHwJ8StOu7DxF4T0fUIrgDzJJLVFlDHgMsq4cGmB6Clwkqgh1IIBBB4welS5r4K+JHxH1T9kDxFbR6B8UB408K6T5J1jwXrz+ffWFkQq+dFdLyCqZKxtyx6Zr7l0/UoNUsbW8t33QXEYeMspGQRkH8uaALryYHFQSTqOrYonYoM4NYlzeHJHetIxTOCrX9nozYe7T1ornHu5D60VfIcDxljxb9s39oSf4O+CNR0jwzDHqPjTUtNvLiFJm2w2NrHGxlupT/dQAKq/wATMAOTWZ+y5pUvhb4BeAbWS5NxJFpdvM0g6MzgM5Le+6vz+/bH+M1x40sfEOsQs8c/jQrdpuyGi0O3kK2kXssxVpnA5IK9jX1t+zf4q1vTf2RfhnqmlWVzdzQi2huoljaa5a1E2yQxgA/wkEE9hV4dXlZn0lPc+7rOZbi3jlGPnWrVcP4S8RxQRx2kn+qP3JQ2R+ddturCcHCTRm1qKGBAIIINfG/7dn7ZEfwK0Wfwr4VvoX+IN9bl1BG5tOgkyBMffOSueuOK+pvGPiK08KeHb/V72Vbe2s4TcSyyDIVQMn8gDX4IfFv4m3Hx5/aA8X69b3RltdWvALKeZTuii/1MfHYBVZseppKN1ckueBvHmv6X4uu9RfxEov74yyahNrUv2hdRVvmkjmSXcsgZSAentX3r+xz+29YXUdp4d15xb6ECsEMrys7aQ5fCxux62pJIWQ/NGwWN9wCufzG1nR9Nmg1G5UXOpWenX89k9yc7BBG2yOcgcgncua3fhd4b1mx8U6daQ3IsNSOk3l3aISfLuP8ARzMYX/2Xi3KR1wBjmgOXU/oj3rMmdwwBnOe3r+lYGoWuyVjmvB/2FvjRffET4c3vhbxCk9r4y8G3A0y/t7o7pWhZd1vNnuGjx83QlR619CaqoD1UHc83GU+aFzG649+nvRUOp3sWlWkt1MsjxxDLeVC0shHsq80V1R2PnHofir8f9NstU8d+NLSG7hg07w4kegWVrIdrOlvGlqm1e+drOcetfZ//AATJ8Rvq/wCzhHpkt1JPdaLqtxZyRyLxEMI6KD3HzV8N/tAxCL45eNzE4e2vdSk1a1KnIe1uSJoyD34kUZFT+Avip8SvgnozWnhPWrzRrLWZftaxCGKUXMmETgyK395fyrKnPld7H2sZKD1P1rt73SfB+t2eiw2Q0+HUzLJbSjAie4z5kicE4f5t4/3SO1ey6Nrn2/SSgk8u8RNpJGcn1r4iudU+MPjPT7jwm+kaH4r1nRtNtpdT1PS7h9Ml0vVjEs8ccUjsyXD7Wjd1Cqo34PWvXPh78TpvGHw7utR1a3ufCviDSF+z63YoMS6bdIu5tuPvKD+8X+9HwM1p7Snifdg9UdU1zRTNz49WWo+KvhR400c3ciXU+j3UatuwFJi4P6H86/F2x+CPi/T/AAt8PNdm0O5aw8V309tp11pM3m3k4idUMflHgFfLcrjbu3Zr9odM8UL4t8O6wpdI9XsUmtb+NPuxzGPJxnqshIkz2BxXFfCrRvAVz4L+C2matPaWHiTR9P8A7V0axacZaQq0UroT99huyVGcGuLHVVRjHlW5Xs1KyPk/4I/CDwd8Xfjd+0H4as4J9M0jV9CS206y1G2a1ubZ3EeC0TgNmKWMEkDpuNfOHw30LV7n4wJGUMUHhG0jGpxupyq7UspgT2w1wmc9ARmv1x+I37Ofw6+JfjS21vxDphPiaKJEhntryS3n8obtvCMNyfO2QeeBXE/Bf9lXw/ceDvig0zG/u/FOoajYpfXwDTQ2+5YdjMvysfMtlfIXrXFhqjqOVyK0eVaHpfwa+GdtZWPgnxwFktNfk8M2+l6i6Llb6FVVkDgdTGwZlPUiRx6V6nqs++Rtp3ZyOPUdalsbEaPo1lYxjCWsEcCBegCrt/lWJf6Rb3V6t1PEZZUQxKWcgbG6qQO/vXqU42sfO4yq7WRieLLojUPDMYlwG1PLhTw6+S7bW9skflRXPeIfAWhReIfC1smnxrHLczM5MrkjbE3Tn3orpPEep+Vf7V3wa1v4XeOH0e7t3ZvDNsltbXBBLX2hhitvP/tGDeI3I6BATivGJL+7ZbYLcPvsmR7cNysDbi2B6jIX8q/c79ov9nDQP2h/CY07UmbT9YtGeXTdatQBPaORtI/2kZflZT1XpzX47fHH4DeKPgT4zk8PeINLNu4V5LS4hBa2vIR0lgOOM/xRnlO+K4U+nc+yaufdf7PX7dHwm1O1upPE91F8P/FuqtBNqzagxSzvbhIo4lmSUfKPkRAQ5HSui+IHjbwzd+NtS8a+B9Xs/GWiC0TRvG9noDC8eG3cbYbxdpIkaIMxYDnaSTwtfl98JPDtx8UPGd1Y6fIBHpcA1JEZQTcPEUXyVB+8XJAAHJJ4r9mL/wAY6z4e0XVdTsPhu9npVrBLdT7720tZ2RE3b2hU8ELx8zbvavJqJYaopwep6FN80bM8z+D/AIc1W2+GCfE1PEp1mWfR4UubK3sE8q4htWkRGzncZgmQWx82yu28H/BTw38Q/gd4P0fxt4biumtrJXi86SRbuzJO5SkyP5iPjkhGUZrp/gNpc1r8H/CdvdKpS50y3lZWAzmaMuy8cYHmmq/wNvru+8Fx6fPMoufD+o3uhXKtklxbzMsTZ9TF5Wfc1z1a9StB3ezNoR5XZh8N/wBnrwJ8JtXn1bw7pVwuqzxeS9/qOoXF9OU9A8zthfbGa3vgnqaWWr+OfCztm40vVnukGf8Alhdfv0I+jGb/AL5rqc+v1rmvhjohfxt4w8XBGSHVja2cAI+9FApXzPcFpGOf7qA96vATcpyJxSjGKPTbwlVYJgSH+90rhJZvExLCSDS87ugml/wrq769Uvxk1yGvePNI0O/NndS3IuQuSkNpNMoP1UV9HBM+KxVSMtEcr4huvECeMfCKSxaaXMl0yYL4z5Xf8xRUd74003WPiP4WS1F6/lwXRCtZTRnO1FzyvpRWx5h75sFeafGz4TeG/jD4Ev8ARfFCYtVRpo72NtstpKoysyOfulQMkHgivSfMwcd/SvFf2uPEkvh74D67DYTG31HWpINEs3U4bzbmVIQV9TtLHjsDXnPRXPtvI+Wv2K/2RdD8PPb/ABOmtY/P1C8lfTIgCP8AQY4jDFK2eN0zq1xj/bX0r6/8Z+GU8SeEdf0cMI21bTrix84Z+Uyxsu7PoMjmrXh/RIPDeg6dotpGIrfTbeO2jjXoAq7f5Vm3+p65olzNJ/Zo1mxc7kWyZIp4x6MhO1vwr5irUlOo29j2oRUIoveDtHl0PwroelTkedaWMNs5XplI1XI/Kvnz4VfFO/0jxv8AFyx0jwb4k8VwzeN7t7e40u3j+yxbbe3jlDySOigiRWJ2k4zXpXij4heOr61urHwV4A1KLWHjYxX+vvFa2sD/AN/Cl3k+gFaP7IOgafoX7P8A4Zkspmubi+E2oajcycvNfySN9qY+4kDrj/ZAr0cLh1KL9p1OKvWs1boavh3w5428V6gt34lhtvDejICw0e2uRdXF03/TeYKoVf8Apmmfd2r0ecQ20PlwKEjjXasaDAFXnnAQEDIryj4kfCfTPiTd28+o6n4k06S3RkjGh63c2K7fUpG6qTXsUaKpv3UeJjK8nGzZ2Tnc3O4UBZMkKrKr+gJP5kV5loXwB0bSJNieIvGlwn/PC48V3zJ+XmZrP8Qfsl+CPEV0bu4vPF8Ej/6w2vi/UkEn+8PN/lXZqjwIxU3dvQ63Wct8UfDSuCX+w3h5JHP7r0HsfyNFeWyfsN/DA3RnuW8U3kcaGIW9z4q1AxJn72MTbuaKXM+w3Gkn8X4H0hc6df3F99tt9Wkt7Pytv2TyVIzzzn8R+Vcf4m+CyeKTAdU8R6reCGVJokcx7UlVtwcDZ1HaiiuRbn1M0mtRT8OddsNqWHjG8+zt9xb6BJyn4nrTJ/C3jmAhE1vSHB7vaSZ/9CoorF0qbldol1ZxVovQcfh34rkiD3njEWyp/Bp9gi/qTWZ4d+BU3haAW+leMNYsLRZHdLeErsXe5dsfVix/GiitIRUF7pjPV6m1F8I1mkP2nxNr95dD/lsb9oh+SipLn4WXUS5i8Ya3H/vvHJ/NaKK0UmglShLdEJ+G3iMPtXx1fCD+79mj3fnVWD4YeLtMnlW18c3MsMva+iExX6Zooq+Zk+yglZI6DQ/CGuQJN/aGuR3m5NsPlWoh8s+px1ooopcz7kfV6T1cT//Z" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>低功耗蓝牙BLE的GATT协议和广播消息解析</title>
      <link href="/2020/07/30/diary-20200730-1/"/>
      <url>/2020/07/30/diary-20200730-1/</url>
      
        <content type="html"><![CDATA[<p>蓝牙作为短距离无线通讯技术，可实现设备与设备之间的数据交换。一般将蓝牙3.0之前的BR/EDR称为传统蓝牙，将蓝牙4.0规范的BLE蓝牙称为低功耗蓝牙。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/bluetoothtype.jpg" alt="蓝牙分类"></p><ul><li>现在蓝牙实际上分为三类：单模、双模和经典。</li><li>单模蓝牙(ble低功耗蓝牙)使用GATT传输协议进行数据传输，传统蓝牙通过Socket进行数据传输。因此Android用传统蓝牙链接方式无法和低功耗蓝牙ble建立通信通道。通信协议不同。</li><li>经典蓝牙发现其它经典蓝牙设备的方式是调用BluetoothAdapter的startDiscovery()方法。蓝牙最初的设计意图，是打电话放音乐。3.0版本以下的蓝牙，都称为“经典蓝牙”。功耗高、传输数据量大、传输距离只有10米。</li><li>低功耗蓝牙ble引入主设备Central和从设备Peripheral的概念。主设备调用发现设备的方法，通过BluetoothAdapter的startLeScan()方法实现。从设备作为被发现方，发出广播以供发现。这个startLeScan()方法仅能发现ble设备。低功耗，数据量小，距离50米左右。</li><li>Android4.3(API18)版本以下对应传统蓝牙，Android4.3引入BLE核心功能并提供相应api，应用程序通过这些API扫描蓝牙设备、查询服务services、读写设备属性特征characteristics。Android4.3及以上版本才支持低功耗ble的开发，而且Android4.3版本至5.0版本的调用方法和Android5.0以上版本的调用方法还不一样。Android6.0以上必须运行时申请模糊定位的权限开启才能扫描ble广播。</li></ul><h2 id="一、中央BluetoothGatt和周边BluetoothGattServer的实现"><a href="#一、中央BluetoothGatt和周边BluetoothGattServer的实现" class="headerlink" title="一、中央BluetoothGatt和周边BluetoothGattServer的实现"></a>一、中央BluetoothGatt和周边BluetoothGattServer的实现</h2><p>Android4.3规范了BLE的API，但是直到目前的Android4.4，还有些功能不完善。直到目前最新的Android4.4.2，Android手机只能作为中央来使用和处理数据；那数据从哪儿来？从BLE设备来，现在的很多可穿戴设备都是用BLE来提供数据的。一个中央可以同时连接多个周边，但是一个周边某一时刻只能连接一个中央。<br>Android BLE SDK的四个关键类(class):</p><ul><li>BluetoothGattServer作为周边来提供数据。代表周边。</li><li>BluetoothGattServerCallback返回周边的状态。</li><li>BluetoothGatt作为中央来使用和处理数据。代表中央。</li><li>BluetoothGattCallback返回中央的状态和周边提供的数据。</li></ul><h3 id="1-1-创建周边"><a href="#1-1-创建周边" class="headerlink" title="1.1 创建周边"></a>1.1 创建周边</h3><p>虽然周边API是在设备内工作，并不在Android手机上工作，但还是可以看看。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/zhoubianble.jpg" alt="周边"><br>每一个周边BluetoothGattServer，包含多个服务Service，每一个Service包含多个特征Characteristic。<br>new一个特征</p><pre><code>character = new BluetoothGattCharacteristic(UUID.fromString(characteristicUUID),BluetoothGattCharacteristic.PROPERTY_NOTIFY,BluetoothGattCharacteristic.PERMISSION_READ);</code></pre><p>new一个服务</p><pre><code>service = new BluetoothGattService(UUID.fromString(serviceUUID),BluetoothGattService.SERVICE_TYPE_PRIMARY);</code></pre><p>把特征添加到服务</p><pre><code>service.addCharacteristic(character);</code></pre><p>获取BluetoothManager</p><pre><code>manager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);</code></pre><p>获取/打开周边</p><pre><code>BluetoothGattServer server = manager.openGattServer(this,new BluetoothGattServerCallback(){...}); </code></pre><p>把service添加到周边</p><pre><code>server.addService(service);</code></pre><p>开始广播</p><pre><code>//Google还没有广播Service的API，等吧！！！！！//所以目前我们还不能让一个Android手机作为周边来提供数据。</code></pre><h3 id="1-2-创建中央"><a href="#1-2-创建中央" class="headerlink" title="1.2 创建中央"></a>1.2 创建中央</h3><p>在Android手机里运行，成功创建后可以连接到周边<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/centerble.jpg" alt="Center"></p><p>首先拿到BluetoothManager</p><pre><code>bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);</code></pre><p>再拿到BluetoothAdapt</p><pre><code>btAdapter = bluetoothManager.getAdapter();</code></pre><p>开始扫描</p><pre><code>btAdapter.startLeScan( BluetoothAdapter.LeScanCallback);</code></pre><p>从LeScanCallback中得到BluetoothDevice</p><pre><code>public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {.....}</code></pre><p>用BluetoothDevice得到BluetoothGatt</p><pre><code>gatt = device.connectGatt(this, true, gattCallback);</code></pre><p>终于拿到中央BluetoothGatt，通过调用BluetoothGatt的一堆方法api,通过BluetoothGattCallback和周边BluetoothGattServer交互进行通信。</p><h2 id="二、BLE数据发送"><a href="#二、BLE数据发送" class="headerlink" title="二、BLE数据发送"></a>二、BLE数据发送</h2><p>BluetoothGattCallback回调函数先准备好。</p><pre><code>    private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {    @Override    public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {//连接状态改变        Log.e("BluetoothGatt中中中", "连接状态:" + newState);        /**         * 连接状态：         *    * The profile is in disconnected state   *public static final int STATE_DISCONNECTED  = 0;         *    * The profile is in connecting state     *public static final int STATE_CONNECTING    = 1;         *    * The profile is in connected state      *public static final int STATE_CONNECTED    = 2;         *    * The profile is in disconnecting state  *public static final int STATE_DISCONNECTING = 3;         *         */        if (BluetoothGatt.STATE_CONNECTED == newState) {            Log.e("onConnec中中中", "连接成功:");            gatt.discoverServices();//必须有，可以让onServicesDiscovered显示所有Services            Toast.makeText(mContext, "连接成功", Toast.LENGTH_SHORT).show();        }else if (BluetoothGatt.STATE_DISCONNECTED == newState){            Log.e("断开 中中中", "断开连接:");            Toast.makeText(mContext, "断开连接", Toast.LENGTH_SHORT).show();        }    }    @Override    public void onServicesDiscovered(BluetoothGatt gatt, int status) {//发现服务，在蓝牙连接的时候会调用        List&lt;BluetoothGattService&gt; list = mBluetoothGatt.getServices();        for (BluetoothGattService bluetoothGattService:list){            String str = bluetoothGattService.getUuid().toString();            Log.e("onServicesDisc中中中", " ：" + str);            List&lt;BluetoothGattCharacteristic&gt; gattCharacteristics = bluetoothGattService.getCharacteristics();            for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) {                Log.e("onServicesDisc中中中", " ：" + gattCharacteristic.getUuid());                if("0000ffe1-0000-1000-8000-00805f9b34fb".equals(gattCharacteristic.getUuid().toString())){                    linkLossService=bluetoothGattService;                    alertLevel=gattCharacteristic;                    Log.e("daole",alertLevel.getUuid().toString());                }            }        }        enableNotification(true,gatt,alertLevel);//必须要有，否则接收不到数据    }    @Override    public void onCharacteristicRead(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status) {        Log.e("onCharacteristicRead中", "数据接收了哦"+bytesToHexString(characteristic.getValue()));    }    /**     *  发送数据后的回调     * @param gatt     * @param characteristic     * @param status     */    @Override    public void onCharacteristicWrite(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status) {//发送数据时调用        Log.e("onCharacteristicWrite中", "数据发送了哦");        Log.e("onCharacteristicWrite中", bytesToHexString(characteristic.getValue()));        if(status == BluetoothGatt.GATT_SUCCESS){//写入成功            Log.e("onCharacteristicWrite中", "写入成功");        }else if (status == BluetoothGatt.GATT_FAILURE){            Log.e("onCharacteristicWrite中", "写入失败");        }else if (status == BluetoothGatt.GATT_WRITE_NOT_PERMITTED){            Log.e("onCharacteristicWrite中", "没权限");        }    }    @Override    public void onDescriptorRead(BluetoothGatt gatt,BluetoothGattDescriptor descriptor, int status) {//descriptor读        //Log.e("onCDescripticRead中", "数据接收了哦"+bytesToHexString(characteristic.getValue()));    }    @Override    public void onCharacteristicChanged(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic) {// Characteristic 改变，数据接收会调用        Log.e("CharacteristicChanged中", "数据接收了哦"+bytesToHexString(characteristic.getValue()));        tx_receive.append(bytesToHexString(characteristic.getValue()) + "\n");    }    @Override    public void onDescriptorWrite(BluetoothGatt gatt,BluetoothGattDescriptor descriptor, int status) {//descriptor写    }    @Override    public void onReliableWriteCompleted(BluetoothGatt gatt, int status) {    }    @Override    public void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) { //读Rssi    }    @Override    public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) {    }};</code></pre><p>先要定义mBluetoothGatt ，然后在连接ble的时候写上上面这个回调函数。这样会把蓝牙的相关信息传到回调函数，才能进行接下来的数据发送与接收。<br>通过BluetoothDevice连接ble，得到mBluetoothGatt，如下</p><pre><code>    /**     * 蓝牙连接     * @param device     */    public void connect(BluetoothDevice device) {        Log.e("connect中中中","开始连接:");        mBluetoothGatt = device.connectGatt(mContext, false, mGattCallback);    }</code></pre><ul><li>BluetoothGattCallback回调中的onConnectionStateChange是判断蓝牙ble连接是否成功。</li><li>BluetoothGattCallback回调中的onServicesDiscovered先遍历ble设备的所有服务，然后遍历所有服务的所有特征。目的就是为了找到特定的服务和特征<pre><code>linkLossService=bluetoothGattService; alertLevel=gattCharacteristic;</code></pre>这两句，把需要的服务中的Characteristic找到，为什么呢，因为发送数据需要，如果你不知道你的设备中可读写的Characteristic的uuid你需要先知道目标特征的uuid是多少。<br>既然已经找到需要的特征Characteristic，那么就可以用于发送数据了。<pre><code>  /**   * 向蓝牙发送数据   */  public void dataSend(){      //byte[] send={(byte) 0xaa,0x01,0x01,(byte)0x81,(byte) 0xff};      byte[] send = new byte[20];      send = hexStringToBytes(et_send.getText().toString());      byte[] sendData=new byte[send.length+2];      sendData[0]=(byte) 0xaa;      sendData[sendData.length-1]=(byte) 0xff;      for(int i=1;i&lt;sendData.length-1;i++){          sendData[i]=send[i-1];      }      Log.e("dataSend", bytesToHexString(sendData));      Log.e("dataSend", linkLossService +"");      alertLevel.setValue(sendData);      boolean status = mBluetoothGatt.writeCharacteristic(alertLevel);      Log.e("dataSend", status+"");  }</code></pre></li></ul><p>硬件设备接收的都是byte类型的数据，所以我们发送的也就是byte，我这里是从editview中获取数据，然后加工成byte类型。这里我在每条指令前加了0xaa，末尾加了0xff，因为底层硬件要求的数据帧为这种格式，具体发送的时候要按照具体情况来。 </p><h2 id="三、BLE数据接收"><a href="#三、BLE数据接收" class="headerlink" title="三、BLE数据接收"></a>三、BLE数据接收</h2><p>想要接收到数据必须先要使能通知。</p><pre><code>        @Override        public void onServicesDiscovered(BluetoothGatt gatt, int status) {//发现服务，在蓝牙连接的时候会调用            List&lt;BluetoothGattService&gt; list = mBluetoothGatt.getServices();            for (BluetoothGattService bluetoothGattService:list){                String str = bluetoothGattService.getUuid().toString();                Log.e("onServicesDisc中中中", " ：" + str);                List&lt;BluetoothGattCharacteristic&gt; gattCharacteristics = bluetoothGattService.getCharacteristics();                for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) {                    Log.e("onServicesDisc中中中", " ：" + gattCharacteristic.getUuid());                    if("0000ffe1-0000-1000-8000-00805f9b34fb".equals(gattCharacteristic.getUuid().toString())){                        linkLossService=bluetoothGattService;                        alertLevel=gattCharacteristic;                        Log.e("daole",alertLevel.getUuid().toString());                    }                }            }            enableNotification(true,gatt,alertLevel);//必须要有，否则接收不到数据            //Log.e("onServicesDisc中中中", " ：" + mBluetoothGatt.getServices().toString());        }</code></pre><p>就是enableNotification(true,gatt,alertLevel);这句话，这个必须要有不然接收数据的那个回调函数会毫无反应。</p><pre><code>    private void enableNotification(boolean enable, BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {        if (gatt == null || characteristic == null)            return; //这一步必须要有 否则收不到通知         gatt.setCharacteristicNotification(characteristic, enable);    }</code></pre><p>这些都做完了以后，在发送了指令后，如果有数据返回，就会接收到数据</p><pre><code>    @Override    public void onCharacteristicChanged(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic) {// Characteristic 改变，数据接收会调用        Log.e("CharacteristicChanged中", "数据接收了哦"+bytesToHexString(characteristic.getValue()));        tx_receive.append(bytesToHexString(characteristic.getValue()) + "\n");    }</code></pre><p>下面是写入状态的回调函数，写入成功后就会显示写入成功与否</p><pre><code>    @Override    public void onCharacteristicWrite(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status) {//发送数据时调用        Log.e("onCharacteristicWrite中", "数据发送了哦");        Log.e("onCharacteristicWrite中", bytesToHexString(characteristic.getValue()));        if(status == BluetoothGatt.GATT_SUCCESS){//写入成功            Log.e("onCharacteristicWrite中", "写入成功");            tx_display.append("写入成功");        }else if (status == BluetoothGatt.GATT_FAILURE){            Log.e("onCharacteristicWrite中", "写入失败");        }else if (status == BluetoothGatt.GATT_WRITE_NOT_PERMITTED){            Log.e("onCharacteristicWrite中", "没权限");        }    }</code></pre><h2 id="四、BLE总结"><a href="#四、BLE总结" class="headerlink" title="四、BLE总结"></a>四、BLE总结</h2><p>(打开蓝牙-&gt;搜索设备-&gt;发现设备-&gt;建立连接-&gt;数据通信)</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/blekaifaliucheng2.jpg" alt="ble蓝牙开发流程"></p><h3 id="4-1-Android-BLE-API简介"><a href="#4-1-Android-BLE-API简介" class="headerlink" title="4.1 Android BLE API简介"></a>4.1 Android BLE API简介</h3><pre><code>+ GATT描述了一个框架，该框架定义了服务(Server)和服务属性(characteristic)的过程(Procedure)及格式Procedure定义了characteristic的发现、读、写、通知(Notifing)、指示(Indicating)及配置characteristic的广播。GATT中最上层是Profile，Profile由一个或多个服务(Service)组成服务是由Characteristics组成，或是其他服务的引用(Reference)Characteristic包含一个值(Value)，可能包含该Value的相关信息。+ Server一个低功耗蓝牙设备可以定义许多 Service, Service可以理解为一个功能的集合。设备中每一个不同的Service都有一个128bit的UUID作为这个Service的独立标志。蓝牙核心规范制定了两种不同的UUID，一种是基本的UUID，一种是代替基本UUID的16位UUID。所有的蓝牙技术联盟定义UUID共用了一个基本的UUID：0x0000xxxx-0000-1000-8000-00805F9B34FB，为了进一步简化基本UUID，每一个蓝牙技术联盟定义的属性有一个唯一的16位UUID，以代替上面的基本UUID的‘x’部分。例如，心率测量特性使用0X2A37作为它的16位UUID，因此它完整的128位UUID为：0x00002A37-0000-1000-8000-00805F9B34FB+ Characteristic在Service下面，又包括了许多的独立数据项，我们把这些独立的数据项称作Characteristic。同样的，每一个Characteristic也有一个唯一的UUID作为标识符。在Android开发中，建立蓝牙连接后，我们说的通过蓝牙发送数据给外围设备就是往这些Characteristic中的Value字段写入数据；外围设备发送数据给手机就是监听这些Charateristic中的Value字段有没有变化，如果发生了变化，手机的BLE API就会收到一个监听的回调。</code></pre><h4 id="4-1-1-BluetoothAdapter"><a href="#4-1-1-BluetoothAdapter" class="headerlink" title="4.1.1 BluetoothAdapter"></a>4.1.1 BluetoothAdapter</h4><p>拥有基本的蓝牙操作，例如开启蓝牙扫描，使用已知的MAC地址（BluetoothAdapter getRemoteDevice）实例化一个 BluetoothDevice用于连接蓝牙设备的操作等</p><h4 id="4-1-2-BluetoothDevice"><a href="#4-1-2-BluetoothDevice" class="headerlink" title="4.1.2 BluetoothDevice"></a>4.1.2 BluetoothDevice</h4><p>代表一个远程蓝牙设备。这个类可以让你连接所代表的蓝牙设备或者获取一些有关它的信息，例如它的名字，地址和绑定状态等等。</p><h4 id="4-1-3-BluetoothGatt"><a href="#4-1-3-BluetoothGatt" class="headerlink" title="4.1.3 BluetoothGatt"></a>4.1.3 BluetoothGatt</h4><p>提供了Bluetooth GATT的基本功能。例如重新连接蓝牙设备，发现蓝牙设备的 Service 等</p><h4 id="4-1-4-BluetoothGattService"><a href="#4-1-4-BluetoothGattService" class="headerlink" title="4.1.4 BluetoothGattService"></a>4.1.4 BluetoothGattService</h4><p>通过BluetoothGatt.getService获得，如果当前服务不可见那么将返回一个null。这一个类对应上面说过的Service。我们可以通过这个类的getCharacteristic(UUID uuid) 进一步获取 Characteristic 实现蓝牙数据的双向传输。</p><h4 id="4-1-5-BluetoothGattCharacteristic"><a href="#4-1-5-BluetoothGattCharacteristic" class="headerlink" title="4.1.5 BluetoothGattCharacteristic"></a>4.1.5 BluetoothGattCharacteristic</h4><p>对应上面提到的 Characteristic。通过这个类定义需要往外围设备写入的数据和读取外围设备发送过来的数据。</p><h2 id="五、蓝牙与BLE通讯"><a href="#五、蓝牙与BLE通讯" class="headerlink" title="五、蓝牙与BLE通讯"></a>五、蓝牙与BLE通讯</h2><h3 id="5-0思路步骤-梳理整体逻辑"><a href="#5-0思路步骤-梳理整体逻辑" class="headerlink" title="5.0思路步骤(梳理整体逻辑)"></a>5.0思路步骤(梳理整体逻辑)</h3><ul><li>权限问题<br>先判断手机是否满足android4.3以上版本，再判断手机是否开启蓝牙。Android6.0以上申请运行时定位权限。</li><li>搜索蓝牙<br>搜索蓝牙，回调接口中查看ble设备相关信息，一定时间停止扫描。</li><li>连接蓝牙<br>首先获取到ble设备的mac地址，然后调用connect()方法进行连接。</li><li>获取特征<br>蓝牙连接成功后，需要获取蓝牙的服务及特征等，然后开启接收设置。</li><li>发送消息<br>writeCharacteristic()方法，发送数据给ble设备。</li><li>接收消息<br>通过蓝牙的回调接口中onCharacteristicRead()方法，接收蓝牙收的消息。</li><li>释放资源<br>断开连接，关闭资源。</li></ul><h3 id="5-1声明权限"><a href="#5-1声明权限" class="headerlink" title="5.1声明权限"></a>5.1声明权限</h3><p>AndroidManifest.xml中声明权限</p><pre><code>&lt;!-- 蓝牙所需权限 --&gt;    &lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;    &lt;uses-feature        android:name="android.hardware.bluetooth_le"        android:required="true" /&gt;    &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt;    &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt;</code></pre><p>android.permission.BLUETOOTH允许程序连接到已配对的蓝牙设备。<br>android.permission.BLUETOOTH_ADMIN允许程序发现和配对蓝牙设备。<br>因为只有在API18(Android4.3)以上的手机才支持ble开发，所以还要声明一个feature。当required为true时，应用只能在支持BLE的Android设备上安装运行，required为false时，Android设备均可正常安装运行，需要在代码运行时判断设备是否支持BLE。<br>需要定位权限，不然扫描不到ble设备。</p><h3 id="5-2获取蓝牙适配器"><a href="#5-2获取蓝牙适配器" class="headerlink" title="5.2获取蓝牙适配器"></a>5.2获取蓝牙适配器</h3><pre><code>  BluetoothManager  mBluetoothManager =(BluetoothManager)context.getSystemService(Context.BLUETOOTH_SERVICE);  BluetoothAdapter  mBluetoothAdapter = mBluetoothManager.getAdapter();</code></pre><h3 id="5-3判断手机蓝牙是否打开"><a href="#5-3判断手机蓝牙是否打开" class="headerlink" title="5.3判断手机蓝牙是否打开"></a>5.3判断手机蓝牙是否打开</h3><pre><code>mBluetoothAdapter.isEnabled()</code></pre><p>如果返回true，开始扫描。如果返回false,调用系统方法让用户打开蓝牙。</p><h3 id="5-4开始扫描"><a href="#5-4开始扫描" class="headerlink" title="5.4开始扫描"></a>5.4开始扫描</h3><pre><code>    //10s后停止搜索    new Handler().postDelayed(new Runnable() {                    @Override                    public void run() {                        mBluetoothAdapter.stopLeScan(mLeScanCallback);                    }                }, 1000 * 10);    UUID[] serviceUuids = {UUID.fromString(service_uuid)};    mBluetoothAdapter.startLeScan(serviceUuids, mLeScanCallback);</code></pre><ul><li>startLeScan中，第一个参数是只扫描UUID是同一类的ble设备，第二个参数是扫描到设备后的回调。</li><li>因为蓝牙扫描比较耗电，建议设置扫描时间，一定时间后停止扫描。</li><li>如果不需要过滤扫描到的蓝牙设备，可用mBluetoothAdapter.startLeScan(mLeScanCallback);进行扫描。</li></ul><h3 id="5-5扫描的回调"><a href="#5-5扫描的回调" class="headerlink" title="5.5扫描的回调"></a>5.5扫描的回调</h3><pre><code>    //蓝牙扫描回调接口    private BluetoothAdapter.LeScanCallback mLeScanCallback = new BluetoothAdapter.LeScanCallback(){        @Override        public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) {            if (device.getName() == null) {                return;            }            Log.e("---&gt;搜索到的蓝牙名字：", device.getName());            //可以将扫描的设备弄成列表，点击设备连接，也可以根据每个设备不同标识，自动连接。        }    };</code></pre><h3 id="5-6连接蓝牙"><a href="#5-6连接蓝牙" class="headerlink" title="5.6连接蓝牙"></a>5.6连接蓝牙</h3><ul><li><p>获取设备的mac地址，然后连接。</p><pre><code>//获取所需地址String mDeviceAddress = device.getAddress();BluetoothGatt mBluetoothGatt = device.connectGatt(context, false, mGattCallback);</code></pre></li><li><p>onConnectionStateChange()被调用<br>连接状态改变时，mGattCallback中onConnectionStateChange()方法会被调用，当连接成功时，需要调用mBluetoothGatt.discoverServices();去获取服务。</p></li><li><p>onServicesDiscovered()被调用<br>调用mBluetoothGatt.discoverServices();方法后，onServicesDiscovered（）这个方法会被调用，说明发现当前设备了。然后我们就可以在里面去获取BluetoothGattService和BluetoothGattCharacteristic。</p></li></ul><p>下面就是mGattCallback回调方法。</p><pre><code>    // BLE回调操作    private BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {        @Override        public void onConnectionStateChange(BluetoothGatt gatt, int status,int newState){            super.onConnectionStateChange(gatt, status, newState);            if (newState == BluetoothProfile.STATE_CONNECTED) {                // 连接成功                mBluetoothGatt.discoverServices();            } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {                // 连接断开               Log.d("TAG","onConnectionStateChange fail--&gt;" + status);            }        }        @Override        public void onServicesDiscovered(BluetoothGatt gatt, int status) {            super.onServicesDiscovered(gatt, status);            if (status == BluetoothGatt.GATT_SUCCESS) {                //发现设备，遍历服务，初始化特征                initBLE(gatt);            } else {               Log.d("TAG","onServicesDiscovered fail--&gt;" + status);            }        }        @Override        public void onCharacteristicRead(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status){            super.onCharacteristicRead(gatt, characteristic, status);            if (status == BluetoothGatt.GATT_SUCCESS) {                // 收到的数据                byte[] receiveByte = characteristic.getValue();            }else{               Log.d("TAG","onCharacteristicRead fail--&gt;" + status);            }        }        @Override        public void onCharacteristicChanged(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic){            super.onCharacteristicChanged(gatt, characteristic);            //当特征中value值发生改变        }        /**         * 收到BLE终端写入数据回调         * @param gatt         * @param characteristic         * @param status         */        @Override        public void onCharacteristicWrite(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status) {            super.onCharacteristicWrite(gatt, characteristic, status);            if (status == BluetoothGatt.GATT_SUCCESS) {             // 发送成功            } else {             // 发送失败            }        }        @Override        public void onDescriptorWrite(BluetoothGatt gatt,                                      BluetoothGattDescriptor descriptor, int status) {            super.onDescriptorWrite(gatt, descriptor, status);            if (status == BluetoothGatt.GATT_SUCCESS) {            }        }        @Override        public void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) {            super.onReadRemoteRssi(gatt, rssi, status);            if (status == BluetoothGatt.GATT_SUCCESS) {            }        }        @Override        public void onDescriptorRead(BluetoothGatt gatt,BluetoothGattDescriptor descriptor, int status) {            super.onDescriptorRead(gatt, descriptor, status);            if (status == BluetoothGatt.GATT_SUCCESS) {            }        }    };</code></pre><ul><li><p>获取特征<br>确认ble设备相关的uuid，不同的ble设备的uuid不相同，请根据自己的设备初始化uuid。</p><pre><code>  //写通道uuid  private static final UUID writeCharactUuid = UUID.fromString("0000fff6-0000-1000-8000-00805f9b34fb");  //通知通道 uuid  private static final UUID notifyCharactUuid =UUID.fromString( "0000fff7-0000-1000-8000-00805f9b34fb");</code></pre><p>获取bluetoothGattCharacteristic（因为有的设备可能存在双服务的情况，所以这里遍历所有服务）</p><pre><code>  //初始化特征  public void initBLE(BluetoothGatt gatt) {      if (gatt == null) {          return;      }      //遍历所有服务      for (BluetoothGattService BluetoothGattService : gatt.getServices()) {          Log.e(TAG, "---&gt;BluetoothGattService" + BluetoothGattService.getUuid().toString());          //遍历所有特征          for (BluetoothGattCharacteristic bluetoothGattCharacteristic : BluetoothGattService.getCharacteristics()) {              Log.e("----&gt;gattCharacteristic", bluetoothGattCharacteristic.getUuid().toString());              String str = bluetoothGattCharacteristic.getUuid().toString();              if (str.equals(writeCharactUuid)) {                  //根据写UUID找到写特征                  mBluetoothGattCharacteristic = bluetoothGattCharacteristic;              } else if (str.equals(notifyCharactUuid)) {                  //根据通知UUID找到通知特征                  mBluetoothGattCharacteristicNotify = bluetoothGattCharacteristic;              }          }      }  }</code></pre><p>开启通知，设置开启通知之后，才能在onCharacteristicRead()这个方法中收到数据。</p><pre><code>  mBluetoothGatt.setCharacteristicNotification(mGattCharacteristicNotify, true);</code></pre></li><li><p>发送消息</p><pre><code>  mGattCharacteristicWrite .setValue(sData);  if (mBluetoothGatt != null) {      mBluetoothGatt.setCharacteristicNotification(notifyCharactUuid , true);      mBluetoothGatt.writeCharacteristic(mGattCharacteristicWrite );  } </code></pre></li><li><p>接收消息<br>接收到数据后，mGattCallback 中的onCharacteristicRead()这个方法会被调用。</p><pre><code>      @Override      public void onCharacteristicRead(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status){          super.onCharacteristicRead(gatt, characteristic, status);          if (status == BluetoothGatt.GATT_SUCCESS) {              // 收到的数据              byte[] receiveByte = characteristic.getValue();          }else{             Log.d("TAG","onCharacteristicRead fail--&gt;" + status);          }      }</code></pre></li><li><p>释放资源<br>断开连接，关闭资源。</p><pre><code>  public boolean disConnect() {      if (mBluetoothGatt != null) {          mBluetoothGatt.disconnect();          mBluetoothGatt.close();          mBluetoothGatt = null;          return true;      }      return false;  }</code></pre></li></ul><h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><ul><li>通知开启后，才能读到数据，否则读不到。</li><li>发送数据时，如果一包数据超过20字节，需要分包发送，一次最多发送二十字节。</li><li>接收数据时，一次最多也只接收20字节的数据，需要将接收到的数据拼接起来，在数据的结尾弄一个特定的标识，去判断数据是否接受完毕。</li><li>每次发送数据或者数据分包发送时， 操作间要有至少15ms的间隔。</li><li>如果出现扫描不到的情况，那是因为手机没有开启定位权限，清单文件中写上定位权限，代码中在动态获取下就OK</li></ul><h2 id="七、我的例子"><a href="#七、我的例子" class="headerlink" title="七、我的例子"></a>七、我的例子</h2><h3 id="7-1-扫描ble设备并解析广播消息"><a href="#7-1-扫描ble设备并解析广播消息" class="headerlink" title="7.1 扫描ble设备并解析广播消息"></a>7.1 扫描ble设备并解析广播消息</h3><p>AndroidManifest.xml</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="my.compancy1.mybluetooth"&gt;    &lt;uses-feature        android:name="android.hardware.bluetooth_le"        android:required="true" /&gt;    &lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;    &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;    &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;    &lt;application        android:networkSecurityConfig="@xml/network"        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/AppTheme"        android:usesCleartextTraffic="true"&gt;        &lt;meta-data            android:name="com.google.android.actions"            android:resource="@xml/network" /&gt;        &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>入口函数MainActivity.java</p><pre><code>package my.compancy1.mybluetooth;import androidx.annotation.RequiresApi;import androidx.appcompat.app.AppCompatActivity;import androidx.core.app.ActivityCompat;import androidx.core.content.ContextCompat;import android.Manifest;import android.bluetooth.BluetoothAdapter;import android.bluetooth.BluetoothDevice;import android.bluetooth.BluetoothGatt;import android.bluetooth.BluetoothGattCallback;import android.bluetooth.BluetoothGattCharacteristic;import android.bluetooth.BluetoothGattDescriptor;import android.bluetooth.BluetoothGattService;import android.bluetooth.BluetoothManager;import android.bluetooth.BluetoothProfile;import android.bluetooth.le.AdvertiseCallback;import android.bluetooth.le.AdvertiseData;import android.bluetooth.le.AdvertiseSettings;import android.bluetooth.le.BluetoothLeAdvertiser;import android.content.Context;import android.content.Intent;import android.content.pm.PackageManager;import android.os.Build;import android.os.Bundle;import android.os.ParcelUuid;import android.provider.SyncStateContract;import android.text.method.HideReturnsTransformationMethod;import android.util.Log;import android.view.View;import android.widget.Adapter;import android.widget.ArrayAdapter;import android.widget.Button;import android.widget.ListView;import android.widget.SimpleAdapter;import android.widget.TextView;import android.widget.Toast;import org.json.JSONException;import org.json.JSONObject;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Array;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.net.URLEncoder;import java.sql.BatchUpdateException;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.UUID;import okhttp3.Call;import okhttp3.Callback;import okhttp3.FormBody;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class MainActivity extends AppCompatActivity {    TextView textViewDebug;    ListView listView_content;    Button btnTest;    private String[] data={};    private  ArrayList&lt;String&gt; list;    ArrayAdapter&lt;String&gt; adapter;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        btnTest=this.findViewById(R.id.addItem);        btnTest.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Log.d("LLL","alfjl");              //  adapter.add("xxxxxxxx");              //  Toast.makeText(getApplicationContext(),"测试",Toast.LENGTH_SHORT).show();            }        });        Button btnConnect=findViewById(R.id.buttonConnect);        btnConnect.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Toast.makeText(getApplicationContext(),"click me",Toast.LENGTH_SHORT).show();                bleRemote= mBluetoothAdapter.getRemoteDevice("E4:B5:4A:3B:A8:55");                if(bleRemote==null){                    Log.d("zz","Device not found,Unable to connect.");                }else{                    bleRemote.connectGatt(getApplicationContext(),false,mGattCallback);                    Log.d("zz","Trying to create a new connection");                }            }        });        textViewDebug=(TextView) this.findViewById(R.id.textViewDebug);        listView_content=(ListView) this.findViewById(R.id.contentScan);        list=new ArrayList&lt;String&gt;();        Collections.addAll(list,data);        adapter=new ArrayAdapter&lt;String&gt;(MainActivity.this,R.layout.scan_item,list);        //ArrayAdapter&lt;String&gt; adapter=new ArrayAdapter&lt;String&gt;(MainActivity.this,R.layout.scan_item,data);        listView_content.setAdapter(adapter);       // arrayAdapter=new MyAdapter(list,MainActivity.this);       // listView_content.setAdapter(arrayAdapter);       // showErrorText("开始");        InitBluetooth();        GetAccessFineLocation();        PrepareDiscovery();    }    BluetoothAdapter mBluetoothAdapter;    private void InitBluetooth(){        final BluetoothManager bluetoothManager=(BluetoothManager)getSystemService(Context.BLUETOOTH_SERVICE);        mBluetoothAdapter= bluetoothManager.getAdapter();        if(mBluetoothAdapter==null||!mBluetoothAdapter.isEnabled()){            mBluetoothAdapter.enable();        }    }    Button btnStartDiscovery;    private void PrepareDiscovery(){        btnStartDiscovery=this.findViewById(R.id.btnStartD);        btnStartDiscovery.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Toast.makeText(getApplicationContext(),"准备扫描",Toast.LENGTH_SHORT).show();                if(mBluetoothAdapter.isDiscovering()){                    mBluetoothAdapter.stopLeScan(mLeScanCallback);                }                //Log.d("MyZS","开始扫描");               // textViewDebug.setText("开始扫描");                mBluetoothAdapter.startLeScan(mLeScanCallback);            }        });    }    ArrayList&lt;String&gt; arr;    private String ParseAdMsg(String _msg){        /*        020105030309B0040954583111FF0000003400005049470C2D002403D7180000000000000000000000000000000000000000000000000000000000000000        * */        String msg=_msg.substring(24,60);        arr=new ArrayList&lt;String&gt;();        arr.add(msg.substring(0,2));        arr.add(msg.substring(2,4));        arr.add(msg.substring(4,6));        arr.add(msg.substring(6,8));        arr.add(msg.substring(8,10));        arr.add(msg.substring(10,12));        arr.add(msg.substring(12,14));        arr.add(msg.substring(14,16));        arr.add(msg.substring(16,18));        arr.add(msg.substring(18,20));        arr.add(msg.substring(20,22));        arr.add(msg.substring(22,24));        arr.add(msg.substring(24,26));        arr.add(msg.substring(26,28));        arr.add(msg.substring(28,30));        arr.add(msg.substring(30,32));        arr.add(msg.substring(32,34));        arr.add(msg.substring(34,36));        String resStr="";        if(arr.get(7).equals("00")){            resStr+=" 充电:false 佩戴:false ";        }        if(arr.get(7).equals("01")){            resStr+=" 充电:true 佩戴:false ";        }        if(arr.get(7).equals("02")){            resStr+=" 充电:false 佩戴:true ";        }        if(arr.get(7).equals("03")){            resStr+=" 充电:true 佩戴:true ";        }        int WenDuZ=Integer.parseInt(arr.get(14),16);        int WenDuX=Integer.parseInt(arr.get(15),16);        resStr+=" 体温: "+WenDuZ+"."+WenDuX+" ";        int dianLiang=Integer.parseInt(arr.get(8),16);        resStr+=" 电量: "+dianLiang+"% ";        int jiBu=Integer.parseInt(arr.get(4)+arr.get(5),16);        resStr+=" 计步: "+jiBu+" ";        int hours=Integer.parseInt(arr.get(11),16);        int minutes=Integer.parseInt(arr.get(12),16);        resStr+=" 时间  "+hours+":"+minutes;        return resStr;    }    private String ParseAdMsgWeb(String _mac, String _msg){        /*        020105030309B0040954583111FF0000003400005049470C2D002403D7180000000000000000000000000000000000000000000000000000000000000000        * */        String msg=_msg.substring(24,60);        arr=new ArrayList&lt;String&gt;();        arr.add(msg.substring(0,2));        arr.add(msg.substring(2,4));        arr.add(msg.substring(4,6));        arr.add(msg.substring(6,8));        arr.add(msg.substring(8,10));        arr.add(msg.substring(10,12));        arr.add(msg.substring(12,14));        arr.add(msg.substring(14,16));        arr.add(msg.substring(16,18));        arr.add(msg.substring(18,20));        arr.add(msg.substring(20,22));        arr.add(msg.substring(22,24));        arr.add(msg.substring(24,26));        arr.add(msg.substring(26,28));        arr.add(msg.substring(28,30));        arr.add(msg.substring(30,32));        arr.add(msg.substring(32,34));        arr.add(msg.substring(34,36));        String battery_charging="";        String worn="";        String temperature="";        String electric_quantity="";        String step_num="";        String device_time="";        String resStr="";        if(arr.get(7).equals("00")){            resStr+=" 充电false 佩戴false ";            battery_charging="未充电";            worn="未佩戴";        }        if(arr.get(7).equals("01")){            resStr+=" 充电true 佩戴false ";            battery_charging="充电中";            worn="未佩戴";        }        if(arr.get(7).equals("02")){            resStr+=" 充电false 佩戴true ";            battery_charging="未充电";            worn="佩戴中";        }        if(arr.get(7).equals("03")){            resStr+=" 充电true 佩戴true ";            battery_charging="充电中";            worn="佩戴中";        }        int WenDuZ=Integer.parseInt(arr.get(14),16);        int WenDuX=Integer.parseInt(arr.get(15),16);        resStr+=" 体温"+WenDuZ+"."+WenDuX+" ";        temperature=WenDuZ+"."+WenDuX;        int dianLiang=Integer.parseInt(arr.get(8),16);        resStr+=" 电量"+dianLiang+"";        electric_quantity=dianLiang+"%";        int jiBu=Integer.parseInt(arr.get(4)+arr.get(5),16);        resStr+=" 计步"+jiBu+"";        step_num=jiBu+"";        int hours=Integer.parseInt(arr.get(11),16);        int minutes=Integer.parseInt(arr.get(12),16);        resStr+=" 时间"+hours+":"+minutes;        device_time=hours+":"+minutes;        // String battery_charging,worn,temperature,electric_quantity,step_num,device_time;        JSONObject json=new JSONObject();        try{            json.put("mac_address",_mac);            json.put("battery_charging",battery_charging);            json.put("worn",worn);            json.put("temperature",temperature);            json.put("electric_quantity",electric_quantity);            json.put("step_num",step_num);            json.put("device_time",device_time);        }catch (JSONException e){            e.printStackTrace();        }        return String.valueOf(json);     //   return resStr;    }    public static String str2HexStr(String str) {        char[] chars = "0123456789ABCDEF".toCharArray();        StringBuilder sb = new StringBuilder("");        byte[] bs = str.getBytes();        int bit;        for (int i = 0; i &lt; bs.length; i++) {            bit = (bs[i] &amp; 0x0f0) &gt;&gt; 4;            sb.append(chars[bit]);            bit = bs[i] &amp; 0x0f;            sb.append(chars[bit]);            sb.append(' ');        }        return sb.toString().trim();    }    private  int tempi=0;    private BluetoothDevice bleRemote;    private  BluetoothGatt mBluetoothGatt;    private BluetoothDevice remoteBluetoothDevice=null;    private BluetoothAdapter.LeScanCallback mLeScanCallback=new BluetoothAdapter.LeScanCallback() {        @RequiresApi(api = Build.VERSION_CODES.M)        @Override        public void onLeScan(final BluetoothDevice bluetoothDevice, int i, byte[] bytes) {            Log.d("MyScanRSSI_ZZ:",bluetoothDevice.getAddress()+"    "+bluetoothDevice.getName()+"  ad:  "+bytesToHex(bytes));            handleScanResult(bytes);            if(bluetoothDevice.getName()!=null){                Log.d("ZZZZZZ",bytesToHex(bytes).substring(0,25));                //if(bluetoothDevice.getName().equals("TX1")){                    if(bytesToHex(bytes).substring(0,24).equals("020105030309B00409545831")){               //     adapter.add(bluetoothDevice.getAddress()+"    "+bluetoothDevice.getName()+"  数据:  "+bytesToHex(bytes));           //         adapter.add(bluetoothDevice.getAddress()+"    "+Integer.parseInt("0034",16) +"  截取:  "+ParseAdMsg(bytesToHex(bytes))+"  数据:  "+bytesToHex(bytes));              //      adapter.add(bluetoothDevice.getAddress()+"  截取:  "+ParseAdMsg(bytesToHex(bytes))+"  数据:  "+bytesToHex(bytes));//1.1 描述一个蓝牙设备，提供设备Mac地址和设备名称。                   String msg="设备地址-&gt; "+bluetoothDevice.getAddress()+" 设备名-&gt; "+bluetoothDevice.getName()+" 设备信息-&gt; "+ParseAdMsg(bytesToHex(bytes));                  String msgjson=ParseAdMsgWeb(bluetoothDevice.getAddress().toString(),bytesToHex(bytes));                    adapter.add(msg);//1.2 准备连接蓝牙设备                    /*                    if(tempi&lt;1){                        tempi++;                        bleRemote= mBluetoothAdapter.getRemoteDevice(bluetoothDevice.getAddress());                        if(bleRemote==null){                            Log.d("Tag","Device not found,Unable to connect.");                        }else{                            bleRemote.connectGatt(getApplicationContext(),false,mGattCallback);                            Log.d("TAG","Trying to create a new connection");                        }                    }                    */                 //   getWebReq("Address-"+bluetoothDevice.getAddress()+"Name-"+bluetoothDevice.getName()+""+ParseAdMsg(bytesToHex(bytes)));                 mypost(msgjson);                }            }           //     showErrorText(bytesToHex(bytes));          //  if(bluetoothDevice.getName().equals())            runOnUiThread(new Runnable() {                @Override                public void run() {                      //  Log.d("MyScanRSSI:",bluetoothDevice.getAddress()+"    "+bluetoothDevice.getName());                }            });        }    };    private void mypost(String str){        String url="http://192.168.31.112:8181";        OkHttpClient okHttpClient=new OkHttpClient();        FormBody.Builder formBody=new FormBody.Builder();        formBody.add("username","关云长");        formBody.add("msg",str);        Request request=new Request.Builder()                .url(url)                .post(formBody.build())                .build();        Call call=okHttpClient.newCall(request);        //异步请求，通过接口回调告知用户http的异步执行结果        call.enqueue(new Callback() {            @Override            public void onFailure(Call call, IOException e) {                Log.d("OKHttpFailed",e.getMessage());            }            @Override            public void onResponse(Call call, Response response) throws IOException {                if(response.isSuccessful()){                    Log.d("OKHttp",response.body().toString());                }            }        });    }    private void getWebReq(String _p){        String login_url="http://192.168.31.112:8081/wen.html";       // String p=new String(_p.getBytes("GBK"),"UTF-8");        try {            String lastUrl = login_url + "?dat="+ URLEncoder.encode(_p, "utf-8");            Log.d("西瓜",lastUrl);            URL url = new URL(lastUrl);            HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();//开发访问此连接            //设置访问时长和相应时长            urlConn.setConnectTimeout(5*1000);//设置连接时间为5秒            urlConn.setReadTimeout(6*1000);//设置读取时间为5秒            int code = urlConn.getResponseCode();//获得相应码            if(code == 200){//相应成功，获得相应的数据                InputStream is = urlConn.getInputStream();//得到数据流（输入流）                byte[] buffer = new byte[1024];                int length = 0;                String data = "";                while((length = is.read(buffer)) != -1){                    String str = new String(buffer,0,length);                    data += str;                }                Log.d("main", data);                //解析json，展示在ListView（GridView）            }        } catch (MalformedURLException e) {            // TODO Auto-generated catch block            e.printStackTrace();        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }    private void GetAccessFineLocation(){        //动态申请定位权限        if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION)                != PackageManager.PERMISSION_GRANTED){//未开启定位权限            //开启定位权限,200是标识码            ActivityCompat.requestPermissions(MainActivity.this,new String[]{Manifest.permission.ACCESS_FINE_LOCATION},200);        }else{            // startLocaion();//开始定位            // GetBLUETOOTH_ADMIN();            Toast.makeText(MainActivity.this,"已开启定位权限",Toast.LENGTH_LONG).show();        }    }    private void showErrorText(String messageId) {        TextView view = (TextView) findViewById(R.id.textViewDebug);        view.setText(messageId);    }    //字节数据转化为Hex    static final char[] hexArray="0123456789ABCDEF".toCharArray();    private static  String bytesToHex(byte[] bytes){        char[] hexChars=new char[bytes.length*2];        for(int j=0;j&lt;bytes.length;j++){            int v=bytes[j]&amp;0xFF;            hexChars[j*2]=hexArray[v&gt;&gt;&gt;4];            hexChars[j*2+1]=hexArray[v&amp;0x0F];        }        return new String(hexChars);    }    //格式化UUID    public String parseUUID(String data){        String uuid="";        if(data.length()==32){            uuid=data.substring(0,8)+"-"                    +data.substring(8,12)+"-"                    +data.substring(12,16)+"-"                    +data.substring(16,20)+"-"                    +data.substring(20);        }else{            Toast.makeText(getApplicationContext(),"UUID未发现",Toast.LENGTH_SHORT).show();        }        return uuid;    }    //处理广播数据    private void handleScanResult(byte[] scanRecord){    }    /*    * GATT    * */    //1.3 连接到设备之后，获取设备服务Service和服务对应的Characteristic    //1.4 写入成功后，开始读取设备返回来的数据    private final BluetoothGattCallback mGattCallback=new BluetoothGattCallback() {        //判断连接是否成功        @Override        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {            super.onConnectionStateChange(gatt, status, newState);            String intentAction;            if(status==BluetoothGatt.GATT_SUCCESS){                //连接成功时                Log.d("ZS","连接到GATT服务器");                //立即去执行发现服务                mBluetoothGatt=gatt;                gatt.discoverServices();            }else if(newState== BluetoothProfile.STATE_DISCONNECTED){                //断开连接                mBluetoothGatt=null;                Log.d("ZS","与Gatt服务器断开连接");            }        }        //发现服务        @Override        public void onServicesDiscovered(BluetoothGatt gatt, int status) {            super.onServicesDiscovered(gatt, status);            List&lt;BluetoothGattService&gt; services=gatt.getServices();            for(BluetoothGattService service:services){                List&lt;BluetoothGattCharacteristic&gt; characteristics=service.getCharacteristics();                for(BluetoothGattCharacteristic character:characteristics){                    Log.d("发现服务",gatt+" serviceUUID:  "+service.getUuid()+"  characterUUID:  "+character.getUuid());                }            }            if(status==BluetoothGatt.GATT_SUCCESS){                Log.d("ZZ","发现服务是可以的");            }else{                Log.d("ZZ","发现接收到的服务:"+status);            }        }        //数据读取  从特征中读取数据        @Override        public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {            super.onCharacteristicRead(gatt, characteristic, status);            Log.d("读取出来的值",gatt+"  "+characteristic+"  "+status);        }        //向特征中写入数据        @Override        public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {            super.onCharacteristicWrite(gatt, characteristic, status);        }        //数据改变  连接成功后回调该方法        @Override        public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {            super.onCharacteristicChanged(gatt, characteristic);            byte[] value=characteristic.getValue();            for(int i=0;i&lt;value.length;i++){                Log.d("BLE","character_value="+value[i]);            }        }        //数据描述读取        @Override        public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {            super.onDescriptorRead(gatt, descriptor, status);        }        @Override        public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {            super.onDescriptorWrite(gatt, descriptor, status);            UUID uuid=descriptor.getCharacteristic().getUuid();            if(uuid.equals(UUID.fromString("0000cd01-0000-1000-8000-00805f9b34fb"))){            }        }    };    //获得特征之后，找到服务可以向下位机写指令的特征，向该特征写入指令    public void wirteCharacteristic(BluetoothGattCharacteristic characteristic){        if(mBluetoothAdapter==null||mBluetoothGatt==null){            Log.d("TAG","BluetoothAdapter not initialized");            return;        }        mBluetoothGatt.writeCharacteristic(characteristic);    }}</code></pre><h3 id="7-2-协议说明与操作结果"><a href="#7-2-协议说明与操作结果" class="headerlink" title="7.2 协议说明与操作结果"></a>7.2 协议说明与操作结果</h3><p>厂家协议说明和nRFConnect软件实际操作结果对比，如图：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/documentinstruct1.jpg" alt="协议说明"><br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/nrfconnectres2.jpg" alt="nRF Connect操作结果"></p><h2 id="八、GATT读写操作的一点说明"><a href="#八、GATT读写操作的一点说明" class="headerlink" title="八、GATT读写操作的一点说明"></a>八、GATT读写操作的一点说明</h2><p>bluetoothDevice.connectGatt（）方法返回的对象BluetoothGatt，这个BluetoothGatt对象非常重要，甚至可以说是最重要的。一般都是单独声明成全局变量来使用的，因为我们设备的读、写和订阅等操作都需要用到这个对象。<br>发现服务后才可以进行读写订阅等操作。读写订阅操作通过服务Service和特征值Characteristic来操作，如何获得对应的服务和特征值呢？一般硬件工程师会预先定义好uuid并告诉我们。我们通过如下方法获得服务和特征值：</p><pre><code>//write_UUID_service和write_UUID_chara是硬件工程师告诉我们的 BluetoothGattService service=mBluetoothGatt.getService(write_UUID_service); BluetoothGattCharacteristic charaWrite=service.getCharacteristic(write_UUID_chara);</code></pre><p>读取数据 </p><pre><code>private void readData() {        BluetoothGattCharacteristic characteristic=mBluetoothGatt.getService(read_UUID_service).getCharacteristic(read_UUID_chara);        mBluetoothGatt.readCharacteristic(characteristic);}</code></pre><p>读取数据用的少，一般我们都是先订阅，再写入，在订阅的回调里进行数据交互。</p><p>写入数据</p><pre><code>private void writeData(){        BluetoothGattService service=mBluetoothGatt.getService(write_UUID_service);        BluetoothGattCharacteristic charaWrite=service.getCharacteristic(write_UUID_chara);        byte[] data=HexUtil.hexStringToBytes(hex);        if (data.length&gt;20){//数据大于个字节 分批次写入            Log.e(TAG, "writeData: length="+data.length);            int num=0;            if (data.length%20!=0){                num=data.length/20+1;            }else{                num=data.length/20;            }            for (int i=0;i&lt;num;i++){                byte[] tempArr;                if (i==num-1){                    tempArr=new byte[data.length-i*20];                    System.arraycopy(data,i*20,tempArr,0,data.length-i*20);                }else{                    tempArr=new byte[20];                    System.arraycopy(data,i*20,tempArr,0,20);                }                charaWrite.setValue(tempArr);                mBluetoothGatt.writeCharacteristic(charaWrite);            }        }else{            charaWrite.setValue(data);            mBluetoothGatt.writeCharacteristic(charaWrite);        }    }</code></pre><p>写操作的回调</p><pre><code>        @Override        public void onCharacteristicWrite(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status) {                super.onCharacteristicWrite(gatt, characteristic, status);                Log.e(TAG,"onCharacteristicWrite()  status="+status+",value="+HexUtil.encodeHexStr(characteristic.getValue()));        }</code></pre><p>订阅回调</p><pre><code>//订阅通知mBluetoothGatt.setCharacteristicNotification(mBluetoothGatt.getService(notify_UUID_service).getCharacteristic(notify_UUID_chara),true);</code></pre><p>注意一定要写在写入之前，要不然就收不到写入的数据，我一般都是在发现服务之后就订阅。关于订阅收不到这里，需要注意一下，首先你写入的和订阅的Characteristic对象一定要属于同一个Service对象，另外就是保证你写入的数据没问题，否则就可能收不到订阅回调。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> BLE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio快速实现二维码功能</title>
      <link href="/2020/07/28/diary-20200728-1/"/>
      <url>/2020/07/28/diary-20200728-1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-AndroidManifest-xml内添加权限"><a href="#1-1-AndroidManifest-xml内添加权限" class="headerlink" title="1.1 AndroidManifest.xml内添加权限"></a>1.1 AndroidManifest.xml内添加权限</h3><pre><code>    &lt;uses-permission android:name="android.permission.CAMERA" /&gt;    &lt;uses-permission android:name="android.permission.FLASHLIGHT" /&gt;    &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt;    &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;    &lt;uses-feature android:name="android.hardware.camera" /&gt;    &lt;uses-feature android:name="android.hardware.camera.autofocus" /&gt;    &lt;uses-permission android:name="android.permission.VIBRATE" /&gt;    &lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;</code></pre><h3 id="1-2-在build-gradle-Module-app-中添加"><a href="#1-2-在build-gradle-Module-app-中添加" class="headerlink" title="1.2 在build.gradle(Module:app)中添加"></a>1.2 在build.gradle(Module:app)中添加</h3><p>在build.gradle(Module:app)的dependencies{}中添加 implementation “cn.yipianfengye.android:zxing-library:2.2”</p><pre><code>    dependencies {        implementation fileTree(dir: "libs", include: ["*.jar"])        implementation 'androidx.appcompat:appcompat:1.1.0'        implementation 'androidx.constraintlayout:constraintlayout:1.1.3'        testImplementation 'junit:junit:4.12'        androidTestImplementation 'androidx.test.ext:junit:1.1.1'        androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'        implementation "cn.yipianfengye.android:zxing-library:2.2"    }</code></pre><h3 id="1-3-入口函数里初始化"><a href="#1-3-入口函数里初始化" class="headerlink" title="1.3 入口函数里初始化"></a>1.3 入口函数里初始化</h3><p>在MainActivity的onCreate里初始化，执行ZXingLibrary.initDisplayOpinion(this);<br>Android6.0以后需要动态运行时权限。<br>MainActivity.java如下</p><pre><code>package com.compancy1.myqrcode;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import android.Manifest;import android.content.Intent;import android.content.pm.PackageManager;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Build;import android.os.Bundle;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.ImageView;import android.widget.Toast;import com.uuzuche.lib_zxing.activity.CaptureActivity;import com.uuzuche.lib_zxing.activity.CodeUtils;import com.uuzuche.lib_zxing.activity.ZXingLibrary;public class MainActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        getRuntimePermission();    }    private void getRuntimePermission(){        if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.M){            String[] perms={Manifest.permission.CAMERA,Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.READ_EXTERNAL_STORAGE};            if(checkSelfPermission(perms[0])== PackageManager.PERMISSION_DENIED||checkSelfPermission(perms[1])==PackageManager.PERMISSION_DENIED||checkSelfPermission(perms[2])==PackageManager.PERMISSION_DENIED){                requestPermissions(perms,200);            }else{                DoReallyThing();            }        }    }    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        switch(requestCode){            case 200:{                for(int i:grantResults){                    if(i==PackageManager.PERMISSION_DENIED){                        Toast.makeText(this,"权限拒绝",Toast.LENGTH_SHORT).show();                        return;                    }                }                DoReallyThing();                break;            }        }    }    private void DoReallyThing(){        ZXingLibrary.initDisplayOpinion(getApplicationContext());        Button btnStartQR=findViewById(R.id.btn);        btnStartQR.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                //打开摄像头识别二维码                Intent intent =new Intent(MainActivity.this, CaptureActivity.class);                startActivityForResult(intent,250);            }        });        Button btnGenerateQR=findViewById(R.id.btn2);        final EditText yourInputText=(EditText)findViewById(R.id.yourinput);        final ImageView imageView=(ImageView)findViewById(R.id.imageView1);        btnGenerateQR.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                String textContent=yourInputText.getText().toString();                if(TextUtils.isEmpty(textContent)){                    Toast.makeText(getApplicationContext(),"您的输入为空!",Toast.LENGTH_SHORT).show();                    return;                }                yourInputText.setText("");                Bitmap bitmap=CodeUtils.createImage(textContent,400,400, null);                imageView.setImageBitmap(bitmap);            }        });    }    @Override    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {        super.onActivityResult(requestCode, resultCode, data);        if(requestCode==250){            Bundle bundle=data.getExtras();            if(bundle==null){                return;            }            if(bundle.getInt(CodeUtils.RESULT_TYPE)==CodeUtils.RESULT_SUCCESS){                String result=bundle.getString(CodeUtils.RESULT_STRING);                Toast.makeText(this,"解析结果:"+result,Toast.LENGTH_LONG).show();            }else if(bundle.getInt(CodeUtils.RESULT_TYPE)==CodeUtils.RESULT_FAILED){                Toast.makeText(this,"解析失败",Toast.LENGTH_SHORT).show();            }        }    }}</code></pre><p>布局文件activity_main.xml如下：</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent" android:layout_height="wrap_content"    xmlns:android="http://schemas.android.com/apk/res/android"    android:orientation="vertical"&gt;    &lt;Button        android:id="@+id/btn"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:text="开启相机识别二维码" /&gt;    &lt;Button        android:id="@+id/btn2"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:layout_weight="1"        android:text="生成二维码" /&gt;    &lt;EditText        android:id="@+id/yourinput"        android:layout_width="match_parent"        android:layout_height="wrap_content" /&gt;    &lt;ImageView        android:id="@+id/imageView1"        android:layout_width="match_parent"        android:layout_height="wrap_content"        tools:srcCompat="@tools:sample/avatars" /&gt;&lt;/LinearLayout&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidStudio </tag>
            
            <tag> 二维码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio开发记录1-运行时权限</title>
      <link href="/2020/07/27/diary-20200727-1/"/>
      <url>/2020/07/27/diary-20200727-1/</url>
      
        <content type="html"><![CDATA[<h2 id="申请运行时权限"><a href="#申请运行时权限" class="headerlink" title="申请运行时权限"></a>申请运行时权限</h2><p>Android 6.0以后加入了运行时权限这一概念。对于危险权限，应用必须在使用的时候进行申请。</p><h3 id="1-1-AndroidManifest-xml内添加权限"><a href="#1-1-AndroidManifest-xml内添加权限" class="headerlink" title="1.1 AndroidManifest.xml内添加权限"></a>1.1 AndroidManifest.xml内添加权限</h3><pre><code>    &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;    &lt;uses-permission android:name="android.permission.CAMERA" /&gt;</code></pre><h3 id="1-2-获得运行时权限"><a href="#1-2-获得运行时权限" class="headerlink" title="1.2 获得运行时权限"></a>1.2 获得运行时权限</h3><p>入口处添加执行函数(以下运行时权限其实是批量申请的，String[] perms里可以添加多个)。</p><pre><code>    private void getRuntimePermission(){        if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.M){            String[] perms={Manifest.permission.CAMERA,Manifest.permission.WRITE_EXTERNAL_STORAGE};            if(checkSelfPermission(perms[0])==PackageManager.PERMISSION_DENIED||checkSelfPermission(perms[1])==PackageManager.PERMISSION_DENIED){                requestPermissions(perms,200);            }else{                jumpDoSomethingReally();            }        }    }    @Override    public void onRequestPermissionsResult(int resquestCode,@NonNull String[] permissions,@NonNull int[] grantResults){        switch(resquestCode){            case 200:{                for(int i:grantResults){                    if(i==PackageManager.PERMISSION_DENIED){                        Toast.makeText(this,"权限拒绝",Toast.LENGTH_SHORT).show();                        return;                    }                }                jumpDoSomethingReally();                break;            }        }    }</code></pre><h2 id="使用第三方jar包或类库"><a href="#使用第三方jar包或类库" class="headerlink" title="使用第三方jar包或类库"></a>使用第三方jar包或类库</h2><ul><li>File-&gt;New-&gt;Import Module 导入第三方类库文件</li><li>File-&gt;Project Structure 在出现的界面中选择Properties、SDK version、Build Tools Version。尽量把自己新建的程序和导入类库的SDK版本BuildToolsVersion版本一致。</li><li>将第三方类库和自己新建的安卓程序设置关联关系，File-&gt;Prject Structure-&gt;自己的项目-&gt;Dependencies-&gt;点击+ -&gt;Module dependence -&gt;在之后出现的界面选择导入的第三方类库，点击ok确认。</li><li>导入类库文件比较容易出问题的地方就是SDK版本和Build Tools Version版本了，上面也记录了怎么修改版本。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android调用摄像头拍照，保存至相册并显示在当前界面</title>
      <link href="/2020/07/23/diary-20200723-4/"/>
      <url>/2020/07/23/diary-20200723-4/</url>
      
        <content type="html"><![CDATA[<p>测试的功能就是界面一个按钮，点击调用摄像头拍照，在onActivityResult回调方法里对图片处理显示在当前界面并保存在相册。<br>直接上代码。</p><p>Android应用的清单文件AndroidManifest.xml</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="com.compancy1.usecamera"&gt;    &lt;uses-permission android:name="android.permission.CAMERA"/&gt;    &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;    &lt;application        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/AppTheme"&gt;        &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>布局文件activity_main.xml</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="wrap_content"    android:orientation="vertical"    xmlns:android="http://schemas.android.com/apk/res/android"&gt;    &lt;Button        android:id="@+id/btn_take_photo"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:text="拍照" /&gt;    &lt;ImageView        android:id="@+id/picture"        android:layout_width="wrap_content"        android:layout_height="wrap_content"        tools:srcCompat="@tools:sample/avatars" /&gt;&lt;/LinearLayout&gt;</code></pre><p>入口MainActivity.java</p><pre><code>package com.compancy1.usecamera;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import androidx.core.app.ActivityCompat;import androidx.core.content.ContextCompat;import androidx.core.content.FileProvider;import android.Manifest;import android.app.Activity;import android.content.ContentUris;import android.content.ContentValues;import android.content.Context;import android.content.Intent;import android.content.pm.PackageManager;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.os.Environment;import android.provider.MediaStore;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.Toast;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class MainActivity extends AppCompatActivity {    public static  final int TAKE_PHOTO=1;    public static  final int TAKE_PHOTO_2=2;    private ImageView pictureShow;    private String mFilePath;    private String fileName;    private Context mContext;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button takePhoto=findViewById(R.id.btn_take_photo);        pictureShow=findViewById(R.id.picture);        mContext=MainActivity.this;        takePhoto.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                if(ContextCompat.checkSelfPermission(mContext, Manifest.permission.CAMERA)!= PackageManager.PERMISSION_GRANTED){                    ActivityCompat.requestPermissions((Activity)mContext,new String[]{Manifest.permission.CAMERA},100);                }else{                    startCamera2();                }            }        });    }    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        switch (requestCode){            case 100:                startCamera2();                break;            default:        }    }    private void startCamera(){        Intent intent=new Intent("android.media.action.IMAGE_CAPTURE");        startActivityForResult(intent,TAKE_PHOTO);    }    private void  startCamera2(){        //拍摄的照片保存到本地相册        File fileDir=new File(Environment.getExternalStorageState(),"Pictures");        if(!fileDir.exists()){            fileDir.mkdir();        }        fileName="IMG_"+System.currentTimeMillis()+".jpg";        mFilePath=fileDir.getAbsolutePath()+"/"+fileName;        Uri uri=null;        ContentValues contentValues=new ContentValues();        contentValues.put(MediaStore.Images.Media.DISPLAY_NAME,fileName);        if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.Q){            contentValues.put(MediaStore.Images.Media.RELATIVE_PATH,"DCIM/Pictures");        }else{            contentValues.put(MediaStore.Images.Media.DATA,mFilePath);        }        contentValues.put(MediaStore.Images.Media.MIME_TYPE,"image/JPEG");        uri=getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,contentValues);        Intent intent=new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//启动系统相机        intent.putExtra(MediaStore.EXTRA_OUTPUT,uri);        startActivityForResult(intent,TAKE_PHOTO_2);    }    @Override    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {        super.onActivityResult(requestCode, resultCode, data);        switch (requestCode){            case TAKE_PHOTO:                break;            case TAKE_PHOTO_2:                //将拍摄的照片显示在当前界面                String selection=MediaStore.Images.Media.DISPLAY_NAME+"=?";                Cursor cursor=getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,new String[]{MediaStore.Images.Media._ID},selection,new String[]{fileName},null);                if(cursor!=null&amp;&amp;cursor.moveToFirst()){                    do{                        Uri uri= ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,cursor.getLong(0));                        Log.i("luingssd","@"+uri);                        try {                            InputStream inputStream=getContentResolver().openInputStream(uri);                            Bitmap bitmap= BitmapFactory.decodeStream(inputStream);                            pictureShow.setImageBitmap(bitmap);                        } catch (FileNotFoundException e) {                            e.printStackTrace();                        }                    }while (cursor.moveToNext());                }else{                    Toast.makeText(this, "no photo", Toast.LENGTH_SHORT).show();                }                break;                default:        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Nodejs+Mongodb+Android+Vue的一个应用</title>
      <link href="/2020/07/23/diary-20200723-3/"/>
      <url>/2020/07/23/diary-20200723-3/</url>
      
        <content type="html"><![CDATA[<p>最近数据联通验证了一个应用。</p><ul><li>手环作为ble设备，时刻通过蓝牙向外广播信息。</li><li>运行起来MongoDB数据库,用于接收存储手环信息，如体温步数等。</li><li>Android应用，通过手机蓝牙扫描，收集手环信息，通过http发往服务器。</li><li>服务端NodeJS,监听http，一方面接收Android应用传过来的信息并存储，另一方面提供信息给web端管理页面显示。</li><li>Web端管理页面，基于Vue的网页通过服务端，数据库展示信息。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/bleAppWeb.jpg" alt="ble设备在Web端的展示管理"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue常用功能之2-验证码</title>
      <link href="/2020/07/23/diary-20200723-2/"/>
      <url>/2020/07/23/diary-20200723-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、验证码的实现"><a href="#一、验证码的实现" class="headerlink" title="一、验证码的实现"></a>一、验证码的实现</h2><h3 id="1-1新建组件identify-vue"><a href="#1-1新建组件identify-vue" class="headerlink" title="1.1新建组件identify.vue"></a>1.1新建组件identify.vue</h3><pre><code>    &lt;template&gt;      &lt;div class="s-canvas"&gt;        &lt;canvas id="s-canvas" :width="contentWidth" :height="contentHeight"&gt;&lt;/canvas&gt;      &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;    export default {        name: 'SIdentify',        props: {            identifyCode: { // 默认注册码                type: String,                default: '1234'            },        fontSizeMin: { // 字体最小值            type: Number,            default: 25        },        fontSizeMax: { // 字体最大值            type: Number,            default: 35        },        backgroundColorMin: { // 验证码图片背景色最小值            type: Number,            default: 200        },        backgroundColorMax: { // 验证码图片背景色最大值            type: Number,            default: 220        },        dotColorMin: { // 背景干扰点最小值            type: Number,            default: 60        },        dotColorMax: { // 背景干扰点最大值            type: Number,            default: 120        },        contentWidth: { // 容器宽度            type: Number,            default: 116        },        contentHeight: { // 容器高度            type: Number,            default: 38        }      },      methods: {        // 生成一个随机数        randomNum (min, max) {            return Math.floor(Math.random() * (max - min) + min)        },        // 生成一个随机的颜色        randomColor (min, max) {            let r = this.randomNum(min, max)            let g = this.randomNum(min, max)            let b = this.randomNum(min, max)            return 'rgb(' + r + ',' + g + ',' + b + ')'        },        drawPic () {            let canvas = document.getElementById('s-canvas')            let ctx = canvas.getContext('2d')            ctx.textBaseline = 'bottom'          // 绘制背景            ctx.fillStyle = this.randomColor(this.backgroundColorMin, this.backgroundColorMax)            ctx.fillRect(0, 0, this.contentWidth, this.contentHeight)          // 绘制文字            for (let i = 0; i &lt; this.identifyCode.length; i++) {                this.drawText(ctx, this.identifyCode[i], i)            }            this.drawLine(ctx)            this.drawDot(ctx)        },        drawText (ctx, txt, i) {          ctx.fillStyle = this.randomColor(50, 160) // 随机生成字体颜色          ctx.font = this.randomNum(this.fontSizeMin, this.fontSizeMax) + 'px SimHei' // 随机生成字体大小          let x = (i + 1) * (this.contentWidth / (this.identifyCode.length + 1))          let y = this.randomNum(this.fontSizeMax, this.contentHeight - 5)          var deg = this.randomNum(-30, 30)          // 修改坐标原点和旋转角度          ctx.translate(x, y)          ctx.rotate(deg * Math.PI / 180)          ctx.fillText(txt, 0, 0)          // 恢复坐标原点和旋转角度          ctx.rotate(-deg * Math.PI / 180)          ctx.translate(-x, -y)        },        drawLine (ctx) {          // 绘制干扰线          for (let i = 0; i &lt; 4; i++) {            ctx.strokeStyle = this.randomColor(100, 200)            ctx.beginPath()            ctx.moveTo(this.randomNum(0, this.contentWidth), this.randomNum(0, this.contentHeight))            ctx.lineTo(this.randomNum(0, this.contentWidth), this.randomNum(0, this.contentHeight))            ctx.stroke()          }        },        drawDot (ctx) {          // 绘制干扰点          for (let i = 0; i &lt; 30; i++) {            ctx.fillStyle = this.randomColor(0, 255)            ctx.beginPath()            ctx.arc(this.randomNum(0, this.contentWidth), this.randomNum(0, this.contentHeight), 1, 0, 2 * Math.PI)            ctx.fill()          }        }      },      watch: {        identifyCode () {          this.drawPic()        }      },      mounted () {        this.drawPic()      }    }    &lt;/script&gt;    &lt;style scoped&gt;    &lt;/style&gt;</code></pre><h3 id="1-2在需要的页面中使用验证码组件"><a href="#1-2在需要的页面中使用验证码组件" class="headerlink" title="1.2在需要的页面中使用验证码组件"></a>1.2在需要的页面中使用验证码组件</h3><pre><code>&lt;template&gt;  &lt;div class="pageLogin"&gt;    &lt;div class="pageInner"&gt;    &lt;el-form :model="loginfrom" :rules="rules" ref="loginfrom" label-width="0px" class="demo-ruleForm"&gt;        &lt;el-form-item prop="username"&gt;             &lt;el-input v-model="loginfrom.username" placeholder="账号"&gt;             &lt;i slot="prepend" class="el-icon-s-custom"/&gt;             &lt;/el-input&gt;        &lt;/el-form-item&gt;        &lt;el-form-item prop="password"&gt;             &lt;el-input :type="passw" placeholder="密码" v-model="loginfrom.password"&gt;             &lt;i slot="prepend" class="el-icon-lock"/&gt;             &lt;/el-input&gt;        &lt;/el-form-item&gt;        &lt;el-form-item prop="code"&gt;             &lt;el-row :span="24"&gt;             &lt;el-col :span="12"&gt;             &lt;el-input v-model="loginfrom.code" auto-complete="off" placeholder="请输入验证码" maxlength="4"              &gt;&lt;/el-input&gt;             &lt;/el-col&gt;             &lt;el-col :span="12"&gt;             &lt;div class="login-code" @click="changeCode()"&gt;                    &lt;identify :identifyCode="identifyCode"&gt;&lt;/identify&gt;                &lt;/div&gt;             &lt;/el-col&gt;             &lt;/el-row&gt;        &lt;/el-form-item&gt;        &lt;el-form-item&gt;            &lt;el-col :span="8"&gt;                &lt;span&gt;&lt;/span&gt;            &lt;/el-col&gt;            &lt;el-col :span="8"&gt;                &lt;div class="login-btn"&gt;                    &lt;el-button type="primary" @click="submitForm('loginfrom')"&gt;登录&lt;/el-button&gt;                &lt;/div&gt;            &lt;/el-col&gt;            &lt;el-col :span="8"&gt;                &lt;i&gt;&lt;router-link to="Register"&gt;我要注册&lt;/router-link&gt;&lt;/i&gt;            &lt;/el-col&gt;                    &lt;/el-form-item&gt;    &lt;/el-form&gt;    &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Qs from 'qs';import Mock from 'mockjs';import store from "@/vuex/store";import identify from '@/components/identify';export default {    created(){        this.identifyCode = ''        this.makeCode(this.identifyCodes, 4);        Mock.mock('http://unExist.net/assessment/unExistLogin.php',{            'objs':[                {                    'msg':'欢迎你的登陆'                },                {                    'msg':'这是一条测试信息'                }            ]        });    },    components:{        identify    },    store,    name: 'Login',    data () {        return {            loginfrom: {                username: '',                password:'',                code:''            },                        rules: {                username: [                { required: true, message: '请输入账号', trigger: 'blur' },                { min: 3, max: 15, message: '长度在 3 到 15 个字符', trigger: 'blur' }                ],                password: [                { required: true, message: '请输入密码', trigger: 'blur' },                { min: 3, max: 15, message: '长度在 3 到 15 个字符', trigger: 'blur' }                ],             },            passw:"password",            identifyCode:'',            identifyCodes:'1234567890abcdefghijkmnpstuwxyz',            username:'',            password:'',            rememberPw:false        }    },    methods:{        onClickLogin:function(){            var _this=this;             var data=Qs.stringify({                user:this.username,                pass:this.password            });                        this.$axios.post('http://unExist.net/assessment/unExistLogin.php',data,{headers:{}}).then(function(res){                console.log(res);                _this.loginSuccess();            }).catch(function(err){                console.log(err);            });        },        loginSuccess:function(){            console.log(this.$store.state.count);        },        submitForm(formName) {            this.$refs[formName].validate((valid) =&gt; {                if (valid) {                    console.log('success validate');                    if(this.identifyCode.toLowerCase()==this.loginfrom.code.toLowerCase()){                        console.log('success code');                        this.onClickLogin();                        this.$router.push("/admin").catch(error =&gt; error);                    }else{                        console.log('error code');                    }                } else {                    console.log('error validate');                    return false;                }            });        },        changeCode(){            //点击验证码刷新验证码            this.identifyCode='';            this.makeCode(this.identifyCodes,4);        },        randomNum(min,max){            //生成随机整数            max=max+1;            return Math.floor(Math.random()*(max-min)+min);        },        makeCode(data,len){            //生成随机验证码字符串            for(let i =0;i&lt;len;i++)            {                this.identifyCode+=data[this.randomNum(0,data.length-1)];            }        },        showPass(){            if(this.passw=="text"){                this.passw="password";                this.icon="el-input__icon el-icon-view";            }else{                this.passw="text";                this.icon="el-input__icon el-icon-lock";            }        }    }}&lt;/script&gt;&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;&lt;style lang="scss" scoped&gt;    body{        text-align:center;    }    .pageInner{        width:300px;        height:220px;        margin:25px auto;        padding:0 0;    }  .pageLogin{    width:400px;    height:280px;    margin:160px auto;    padding:5px 0px;    background-color:#f5f5f5;    .el-col{        border: 1px solid transparent;    }  }&lt;/style&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue常用功能之1-轮询</title>
      <link href="/2020/07/23/diary-20200723-1/"/>
      <url>/2020/07/23/diary-20200723-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、轮询的实现"><a href="#一、轮询的实现" class="headerlink" title="一、轮询的实现"></a>一、轮询的实现</h2><p>添加定义，方法。</p><pre><code>    data(){        return{            timer:null,        }    }        ......    ......    methods:{        setTimer(intMilliecond){            this.timer=setInterval(()=&gt;{                this.whatDoIDo();            },intMilliecond);        },        whatDoIDo:function(){            console.log("what can i do");        }    }    </code></pre><p>调用轮询方法之前，先clearInterval(this.timer)；关闭网页前要清理本次轮询</p><pre><code>    created:function(){        if(this.timer!=null){            clearInterval(this.timer);        }        this.setTimer(3000);            },    ......    ......    destroyed(){        clearInterval(this.timer);    }</code></pre><h2 id="二、常见问题"><a href="#二、常见问题" class="headerlink" title="二、常见问题"></a>二、常见问题</h2><h3 id="2-1-定时器里的this"><a href="#2-1-定时器里的this" class="headerlink" title="2.1 定时器里的this"></a>2.1 定时器里的this</h3><p>定时器里的this是指向window的，导致定时器里this.属性是访问不了Vue在data里定义的属性的。解决方法是提前把vue对象this以参数的形式传进定时器里</p><pre><code>    created:function(){        var that=this;                if(this.timer!=null){            clearInterval(this.timer);        }        this.setTimer(3000,that);            },    ......    ......    methods:{        setTimer(intMilliecond,_t){            this.timer=setInterval(()=&gt;{                this.whatDoIDo(_t);            },intMilliecond);        },        whatDoIDo:function(_this){            console.log("what can i do");            console.log(_this.VueData属性);        }    }</code></pre><h3 id="2-2完整demo"><a href="#2-2完整demo" class="headerlink" title="2.2完整demo"></a>2.2完整demo</h3><p>以下是我一个vue轮询使用的例子</p><pre><code>&lt;style lang="scss" scoped&gt; .pageorder{    height:100%; }&lt;/style&gt;&lt;template&gt;    &lt;div class="pageorder"&gt;           &lt;h1&gt;设备管理&lt;/h1&gt;        &lt;data-list-table             :list="listA"             :total-num="listA.length"&gt;&lt;/data-list-table&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Qs from 'qs';import Mock from 'mockjs';import DataListTable from '@/components/DataListTable'export default {    data(){        return{            timer:null,            listA:[],        }    },    name: 'order',    components:{        'data-list-table':DataListTable        },    created:function(){        //[]里从数组的第2个开始删除1个元素        //this.listA.splice(2,1);        var that=this;        if(this.timer!=null){            clearInterval(this.timer);        }        this.setTimer(3000,that);            },    methods:{        setTimer(intMilliecond,_t){            this.timer=setInterval(()=&gt;{                this.whatDoIDo(_t);            },intMilliecond);        },        whatDoIDo:function(_this){                        this.$axios({                url:'http://127.0.0.1:8181',                method:'get',                params:{                    action:'getble'                }            }).then(function(res){                //console.log(res);                                console.log(res.data.length);                for(var i=0;i&lt;res.data.length;i++){                                        var jsonprepare=JSON.parse(res.data[i].msg);                    var jsonObj=eval("("+jsonprepare+")");                    jsonObj["student_id"]="No0001";                    for(var j in _this.listA){                    if(_this.listA[j]["mac_address"]==jsonObj["mac_address"]){                            _this.listA.splice(j,1,jsonObj);                                                    return;                        }                    }                    _this.listA.push(jsonObj);                }                /*                var jsonprepare=JSON.parse(res.data[0].msg);                //console.log(jsonprepare);                var jsonObj=eval("("+jsonprepare+")");                jsonObj["student_id"]="No0001";                console.log(jsonObj);                for(var j in _this.listA){                    if(_this.listA[j]["mac_address"]==jsonObj["mac_address"]){                        console.log("找到相同的mac address");                                                //将数组中第i个元素起第1个元素，替换为jsonObj                        _this.listA.splice(j,1,jsonObj);                                                return;                    }                }                console.log("没有相同的mac address，添加记录");                _this.listA.push(jsonObj);                */            }).catch(function(err){                console.log("attenation!!!+ "+err);            });        }    },    destroyed(){        clearInterval(this.timer);    }}&lt;/script&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB实践之2-nodejs连接mongodb数据库</title>
      <link href="/2020/07/20/diary-20200720-2/"/>
      <url>/2020/07/20/diary-20200720-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础操作"><a href="#一、基础操作" class="headerlink" title="一、基础操作"></a>一、基础操作</h2><h3 id="1-1初始化nodejs工程"><a href="#1-1初始化nodejs工程" class="headerlink" title="1.1初始化nodejs工程"></a>1.1初始化nodejs工程</h3><p>在项目根目录下初始化一个package.json文件</p><pre><code>    npm init -y</code></pre><h3 id="1-2安装mongodb模块"><a href="#1-2安装mongodb模块" class="headerlink" title="1.2安装mongodb模块"></a>1.2安装mongodb模块</h3><pre><code>    npm install --save-dev mongodb</code></pre><h3 id="1-3基础增删改查操作"><a href="#1-3基础增删改查操作" class="headerlink" title="1.3基础增删改查操作"></a>1.3基础增删改查操作</h3><p>建立index.js进行代码编写，对数据库进行连接操作。node index.js运行。</p><pre><code>    const mongodbClient=require("mongodb").MongoClient;    const url="mongodb://127.0.0.1:27017";    mongodbClient.connect(url,        {            useUnifiedTopology:true        },        (err,client)=&gt;{        if(err){            console.log("连接失败:"+err);        }else{            console.log("连接成功:"+url);        }    });    mongodbClient.connect(        url,        {            useUnifiedTopology:true        },        (err,client)=&gt;{            if(err){                console.log("连接失败:"+err);            }else{                //连接到该数据库服务器下数据库tablihi中的表biao1,获取表后，对表进行操作。                const collection=client.db("tablehi").collection("biao1");                //增                //collection.save(                //    {                //        "name":"赵四",                //        "password":"safs56"                //    },(err,result)=&gt;{                //        //client.close();                //    }                //);                //删                //collection.remove(                //    {                //        "name":"张三"                //    },()=&gt;{                //        //client.close();                //    }                //);                //改                //collection.update(                //    {                //        "name":"王五"                //    },                //    {                //        "$set":{"password":"wangwu"}                //    }                //);                //查                collection.find().toArray((err,data)=&gt;{                    console.log(data);                    client.close();                });            }        }    );</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB实践之1-安装及命令行登录</title>
      <link href="/2020/07/20/diary-20200720-1/"/>
      <url>/2020/07/20/diary-20200720-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/gainianmongodb1.jpg" alt="MongoDB相关概念1"><br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/gainianmongodb2.jpg" alt="MongoDB相关概念直观示意"></p><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><h2 id="二、解压版MongoDB配置使用"><a href="#二、解压版MongoDB配置使用" class="headerlink" title="二、解压版MongoDB配置使用"></a>二、解压版MongoDB配置使用</h2><p>官方下载地址 <a href="http://dl.mongodb.org/dl/win32/x86_64" target="_blank" rel="noopener">http://dl.mongodb.org/dl/win32/x86_64</a></p><h3 id="2-1-创建mongodb目录"><a href="#2-1-创建mongodb目录" class="headerlink" title="2.1 创建mongodb目录"></a>2.1 创建mongodb目录</h3><p>下载mongodb-win32-x86_64-2008plus-ssl-v4.0-latest.zip，解压到当前目录后更改文件夹名称为mongodb（名称可随意）。<br>在解压后的文件夹内新建data、log两个文件夹<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/jiayainstallmongodb1.jpg" alt="创建mongodb目录"></p><h3 id="2-2-创建配置文件"><a href="#2-2-创建配置文件" class="headerlink" title="2.2 创建配置文件"></a>2.2 创建配置文件</h3><p>mongodb目录下创建conf文件夹，其内创建mongodb.config</p><pre><code>dbpath=D:\mdb\mongodb\data                            #数据库路径logpath=D:\mdb\mongodb\log\mongodb.log                #日志输出文件路径logappend=true                                        #日志采用追加模式，mongodb的日志会追加到现有日志文件里，而不是重新创建一个新文件journal=true                                        #启用日志quiet=true                                            #过滤掉一些无用日志信息，若需调试请设置为falseport=27017                                            #端口号 默认为27017bind_ip_all=true                                    #允许所有地址访问</code></pre><h3 id="2-3手动启动"><a href="#2-3手动启动" class="headerlink" title="2.3手动启动"></a>2.3手动启动</h3><p>管理员cmd模式下进入mongodb目录 D:\mdb\mongodb\bin下</p><h4 id="运行mongodb"><a href="#运行mongodb" class="headerlink" title="运行mongodb"></a>运行mongodb</h4><pre><code>mongod --config "D:/mdb/mongodb/conf/mongodb.config"</code></pre><h4 id="查看mongodb版本"><a href="#查看mongodb版本" class="headerlink" title="查看mongodb版本"></a>查看mongodb版本</h4><pre><code>mongod --version</code></pre><h3 id="2-4命令行登录db"><a href="#2-4命令行登录db" class="headerlink" title="2.4命令行登录db"></a>2.4命令行登录db</h3><p>mongodb运行后，重新另起一个cmd模式进入 D:\mdb\mongodb\bin，可以登录测试mongodb是否起来了</p><pre><code>mongo 127.0.0.1:27017</code></pre><h3 id="2-5命令行登录mongodb后的操作"><a href="#2-5命令行登录mongodb后的操作" class="headerlink" title="2.5命令行登录mongodb后的操作"></a>2.5命令行登录mongodb后的操作</h3><h4 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h4><p>show dbs;</p><h4 id="切换-创建数据库"><a href="#切换-创建数据库" class="headerlink" title="切换/创建数据库"></a>切换/创建数据库</h4><p>use dancy;<br>如果use后面的数据库存在则切换到该数据库，如果不存在则创建</p><h4 id="查看当前数据库"><a href="#查看当前数据库" class="headerlink" title="查看当前数据库"></a>查看当前数据库</h4><p>db;</p><h4 id="查看当前库有多少集合"><a href="#查看当前库有多少集合" class="headerlink" title="查看当前库有多少集合"></a>查看当前库有多少集合</h4><p>show collections;</p><h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h4><p>db.createCollection(某collection名)</p><h4 id="查询某个集合的内容"><a href="#查询某个集合的内容" class="headerlink" title="查询某个集合的内容"></a>查询某个集合的内容</h4><p>db.”某collection名(类似某表名)”.find();</p><h4 id="往某集合里插入一条文档数据"><a href="#往某集合里插入一条文档数据" class="headerlink" title="往某集合里插入一条文档数据"></a>往某集合里插入一条文档数据</h4><p>db.”某collection名(类似某表名)”.insert({“name”: “dancy”})</p><h4 id="删除当前数据库db-dropDatabase"><a href="#删除当前数据库db-dropDatabase" class="headerlink" title="删除当前数据库db.dropDatabase()"></a>删除当前数据库db.dropDatabase()</h4><h4 id="查看集合内文档-db-集合名-find"><a href="#查看集合内文档-db-集合名-find" class="headerlink" title="查看集合内文档 db.集合名.find()"></a>查看集合内文档 db.集合名.find()</h4><p>find方法里面可以传递参数（查询条件）</p><h4 id="查看已插入集合的所有文档（格式化输出）"><a href="#查看已插入集合的所有文档（格式化输出）" class="headerlink" title="查看已插入集合的所有文档（格式化输出）"></a>查看已插入集合的所有文档（格式化输出）</h4><p>db.集合名.find().pretty()</p><h4 id="删除一个文档"><a href="#删除一个文档" class="headerlink" title="删除一个文档"></a>删除一个文档</h4><p>db.集合名.deleteOne({“name”: “lotus”}) , 括号内参数为删除条件。</p><h4 id="删除所有文档："><a href="#删除所有文档：" class="headerlink" title="删除所有文档："></a>删除所有文档：</h4><p>db.集合名.deleteMany({})</p><pre><code>db.adminCommand()               db.dbEval()                     db.getFreeMonitoringStatus()    db.getSiblingDB()               db.isMaster()                   db.revokePrivilegesFromRole()   db.stats()db.aggregate()                  db.disableFreeMonitoring()      db.getLastError()               db.getSisterDB()                db.killOP()                     db.revokeRolesFromRole()        db.toLocaleString()db.auth()                       db.dropAllRoles()               db.getLastErrorCmd()            db.getSlaveOk()                 db.killOp()                     db.revokeRolesFromUser()        db.toString()db.changeUserPassword()         db.dropAllUsers()               db.getLastErrorObj()            db.getUser()                    db.listCommands()               db.runCommand()                 db.tojson()db.cloneCollection()            db.dropDatabase(               db.getLogComponents(           db.getUsers()                   db.loadServerScripts()          db.runCommandWithMetadata()     db.unsetWriteConcern()db.cloneDatabase()              db.dropRole()                   db.getMongo()                   db.getWriteConcern()            db.logout()                     db.runReadCommand()             db.updateRole()db.commandHelp()                db.dropUser()                   db.getName()                    db.grantPrivilegesToRole()      db.printCollectionStats()       db.serverBits()                 db.updateUser()db.constructor                 db.enableFreeMonitoring()       db.getPrevError()               db.grantRolesToRole()           db.printReplicationInfo()       db.serverBuildInfo()            db.valueOfdb.copyDatabase()               db.eval()                       db.getProfilingLevel()          db.grantRolesToUser()           db.printShardingStatus()        db.serverCmdLineOpts()          db.version()db.createCollection()           db.forceError()                 db.getProfilingStatus()         db.group()                      db.printSlaveReplicationInfo()  db.serverStatus()db.createRole()                 db.fsyncLock()                  db.getQueryOptions()            db.groupcmd()                   db.propertyIsEnumerable        db.setLogLevel()db.createUser()                 db.fsyncUnlock()                db.getReplicationInfo()         db.groupeval()                  db.prototype                   db.setProfilingLevel()db.createView()                 db.getCollection()              db.getRole()                    db.hasOwnProperty              db.removeUser()                 db.setSlaveOk()db.currentOP()                  db.getCollectionInfos()         db.getRoles()                   db.help()                       db.repairDatabase()             db.setWriteConcern()db.currentOp()                  db.getCollectionNames()         db.getSession()                 db.hostInfo()                   db.resetError()                 db.shutdownServer()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android网络请求框架OkHttp的使用</title>
      <link href="/2020/07/17/diary-20200717-1/"/>
      <url>/2020/07/17/diary-20200717-1/</url>
      
        <content type="html"><![CDATA[<ul><li>okhttp-3.9.0.jar</li><li>okio-1.13.0.jar(配套必须包含)</li></ul><h2 id="一、关于OkHttp"><a href="#一、关于OkHttp" class="headerlink" title="一、关于OkHttp"></a>一、关于OkHttp</h2><p> OkHttp 是 Square 公司开源的针对 Java 和 Android 程序，封装的一个高性能 http 请求库。支持spdy、http2.0、websocket，支持同步、异步，而且OkHttp又封装了线程池，封装了数据转换，封装了参数使用、错误处理等，api使用起来更加方便。可以把它理解成是一个封装之后的类似HttpUrlConnection的一个东西，但是你在使用的时候仍然需要自己再做一层封装，这样才能像使用一个框架一样更加顺手。</p><h2 id="二、安装使用"><a href="#二、安装使用" class="headerlink" title="二、安装使用"></a>二、安装使用</h2><h3 id="2-1-添加库的引用"><a href="#2-1-添加库的引用" class="headerlink" title="2.1 添加库的引用"></a>2.1 添加库的引用</h3><p>将okhttp-3.9.0.jar和okio-1.13.0.jar放入AndroidStudio的Project/app/libs/目录下，并右键点击“Add As Library”。</p><h3 id="2-2-添加网络访问权限"><a href="#2-2-添加网络访问权限" class="headerlink" title="2.2 添加网络访问权限"></a>2.2 添加网络访问权限</h3><p>在AndroidManifest.xml里添加权限</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="com.compancy1.yibuhttp"&gt;    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;    &lt;application        android:networkSecurityConfig="@xml/network"        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/AppTheme"&gt;        &lt;meta-data            android:name="com.google.android.actions"            android:resource="@xml/network" /&gt;        &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><h3 id="2-3-Activity代码中使用"><a href="#2-3-Activity代码中使用" class="headerlink" title="2.3 Activity代码中使用"></a>2.3 Activity代码中使用</h3><pre><code>public class MainActivity extends AppCompatActivity {    Button btn;         @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        btn=(Button) findViewById(R.id.btn1);        btn.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                myPost();            }        });    }    private void myPost(){        String url="http://192.168.31.112:8181";        OkHttpClient okHttpClient=new OkHttpClient();        FormBody.Builder formBody=new FormBody.Builder();        formBody.add("username","关云长");        formBody.add("password","a123321b");        Request request=new Request.Builder()                .url(url)                .post(formBody.build())                .build();        Call call=okHttpClient.newCall(request);        //异步请求，通过接口回调告知用户http的异步执行结果        call.enqueue(new Callback() {            @Override            public void onFailure(Call call, IOException e) {                Log.d("OKHttpFailed",e.getMessage());            }            @Override            public void onResponse(Call call, Response response) throws IOException {                if(response.isSuccessful()){                    Log.d("OKHttp",response.body().toString());                }            }        });    }}</code></pre><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>由于Android P以后网络访问安全策略升级引起的错误，报错CLEARTEXT communication to “ “ not permitted by network security policy 。<br>解决方法:添加res/xml/network.xml文件后，在Androidmanifest.xml中设置networkSecurity指向该文件即可。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/notpermittedbynetworksecuritypolicy.jpg" alt="网络访问安全策略修改"><br>network.xml如下</p><pre><code>&lt;?xml version ="1.0" encoding ="utf-8"?&gt;&lt;network-security-config&gt;    &lt;base-config cleartextTrafficPermitted="true"  /&gt;&lt;/network-security-config&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidStudio </tag>
            
            <tag> OkHttp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用socket.io和nodeJS的websocket实践</title>
      <link href="/2020/07/16/diary-20200716-2/"/>
      <url>/2020/07/16/diary-20200716-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于socket-IO"><a href="#一、关于socket-IO" class="headerlink" title="一、关于socket.IO"></a>一、关于socket.IO</h2><p>socket.IO是一个websocket库，包括了客户端的js和服务器端的nodejs。官方地址：<a href="http://socket.io" target="_blank" rel="noopener">http://socket.io</a> </p><h2 id="二、socket-io提供给客户端的websock服务"><a href="#二、socket-io提供给客户端的websock服务" class="headerlink" title="二、socket.io提供给客户端的websock服务"></a>二、socket.io提供给客户端的websock服务</h2><p>去github clone socket.io的最新版本，或者直接饮用使用socket.io的CDN服务：</p><pre><code>    &lt;script src="https://lib.baomitu.com/socket.io/2.3.0/socket.io.js"&gt;&lt;/script&gt;</code></pre><p>以下是使用socket.io库来创建客户端</p><pre><code>    &lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script src="https://lib.baomitu.com/socket.io/2.3.0/socket.io.js"&gt;&lt;/script&gt;    &lt;script&gt;        var socket=io.connect('http://localhost:8081');        socket.on('message',function(data){            console.log('Receive message from server,'+data);            socket.emit('message',{nihao:'helloworld'});            socket.emit('storeClientInfo',{customId:"000CustomIdHere1234"});        });        socket.on('connect',function(){            alert("连接成功");        });        socket.on('disconnect',function(){            console.log("断开连接");        });    &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;</code></pre><h2 id="三、socket-io提供给服务器端搭建websock服务"><a href="#三、socket-io提供给服务器端搭建websock服务" class="headerlink" title="三、socket.io提供给服务器端搭建websock服务"></a>三、socket.io提供给服务器端搭建websock服务</h2><h3 id="创建空的项目文件夹"><a href="#创建空的项目文件夹" class="headerlink" title="创建空的项目文件夹"></a>创建空的项目文件夹</h3><pre><code>    mkdir socketserver    cd socketserver</code></pre><h3 id="在项目内安装socket-io"><a href="#在项目内安装socket-io" class="headerlink" title="在项目内安装socket.io"></a>在项目内安装socket.io</h3><pre><code>    npm install socket.io</code></pre><h3 id="搭建服务器环境"><a href="#搭建服务器环境" class="headerlink" title="搭建服务器环境"></a>搭建服务器环境</h3><p>通过nodejs的http模块就可以方便的搭建websocket服务器环境</p><pre><code>    // 引入需要的模块：http和socket.io    var http=require('http');    var io=require('socket.io');    // 创建server，Socket服务器还是构建于HTTP服务器之上，因此先调用 http.createServer()    var server=http.createServer();    server.on('request',function(req,res){        res.writeHead(200,{'Content-Type':'text/html'});        res.end('&lt;h1&gt;Hello,Socket&lt;/h1&gt;');    });    //http端口8081    server.listen(8081);    console.log("-- http listen on port :8081 --");    var clients=[];    //创建socket，交由Socket.io接管    var socket=io.listen(server);    //添加连接监听，Socket.io 真正的连接事件    socket.on('connection',function(client){        //服务端这边的客户端对象代表接受客户端发过来的信息        client.on('message',function(obj){            console.log("Receive message from client,"+obj.nihao);        });        //客户端断开连接时，在服务器端的列表里删除相应对象代表        client.on('disconnect',function(){            //console.log('server has disconnected');            for(var i=0,len=clients.length;i&lt;len;++i){                var c=clients[i];                if(c.clientId==client.id){                    clients.splice(i,1);                    console.log(clients.length);                    break;                }            }        });        //服务端这边的监听客户端对象代表接受客户端发过来的自定义事件        client.on('storeClientInfo',function(data){            var clientInfo=new Object();            clientInfo.customId=data.customId;            clientInfo.clientId=client.id;            clients.push(clientInfo);            console.log(clients.length);        });        //服务端通过客户端对象代表向该客户端发送信息message        client.send("welcome my friend");    });    console.log("-- socket listen on port :8081 --");</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> socket.io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速搭建在线文档的实践</title>
      <link href="/2020/07/16/diary-20200716-1/"/>
      <url>/2020/07/16/diary-20200716-1/</url>
      
        <content type="html"><![CDATA[<ul><li>Vue v2.9.6</li><li>Node v12.16.3</li></ul><h2 id="一、关于vuepress："><a href="#一、关于vuepress：" class="headerlink" title="一、关于vuepress："></a>一、关于vuepress：</h2><p>vuepress项目的文档结构，都必须按照官方文档的格式进行制作。比如说你想修改整体的主题颜色，你就必须修改styles文件夹下的palette.styl。你想在markdown中添加vue组件，vue组件必须放在components文件夹下，诸如此类。等到vuepress在打包的时候，它会遍历特定的路径和文件名称，读取内容生成页面结构和样式。</p><h2 id="二、开始制作"><a href="#二、开始制作" class="headerlink" title="二、开始制作"></a>二、开始制作</h2><h3 id="创建空的项目文件夹"><a href="#创建空的项目文件夹" class="headerlink" title="创建空的项目文件夹"></a>创建空的项目文件夹</h3><pre><code>    mkdir vuepressdemo    cd vuepressdemo</code></pre><h3 id="全局安装vuepress"><a href="#全局安装vuepress" class="headerlink" title="全局安装vuepress"></a>全局安装vuepress</h3><pre><code>    npm install -g vuepress</code></pre><h3 id="初始化项目信息"><a href="#初始化项目信息" class="headerlink" title="初始化项目信息"></a>初始化项目信息</h3><pre><code>    npm init -y</code></pre><p>创建完成后，进入我们的pageckage.json文件，在scripts中添加两条命令</p><pre><code>"scripts": {    "dev": "vuepress dev docs",         //用于实时预览    "build": "vuepress build docs"      //用于打包项目}</code></pre><h3 id="按规则创建vuepress项目结构的文件夹和文件"><a href="#按规则创建vuepress项目结构的文件夹和文件" class="headerlink" title="按规则创建vuepress项目结构的文件夹和文件"></a>按规则创建vuepress项目结构的文件夹和文件</h3><p>有现成的就直接复制docs目录吧。<br>或者对照<a href="https://vuepress.vuejs.org/zh/guide/directory-structure.html" target="_blank" rel="noopener">官方的目录结构</a></p><pre><code>├── docs│   ├── .vuepress  //存放核心内容的文件夹│   │   ├── components  //存放你需要添加的vue组件│   │   ├── public  //存放静态文件，如图片等│   │   ├── styles  //存放需要定制的样式│   │   │   └── palette.styl  //配置页面主题颜色的文件│   │   └── config.js   //设定顶部导航栏、侧边导航栏等项目配置的核心文件│   ├── pages   //存放markdown文件，用于设置其他页面内容│   ├── README.md   //首页展示用的markdown文件├── deploy.sh     //之后用于编写上传、发布脚本的文件└── package.json  //之前创建的Node.js项目描述文件</code></pre><h3 id="开发、部署"><a href="#开发、部署" class="headerlink" title="开发、部署"></a>开发、部署</h3><p>CMD进入在package.json同层目录里执行命令。</p><pre><code>    npm run dev    用于开发实时预览    npm run build  用于打包项目输出静态网页于docs/.vuepress/dist/处。</code></pre><p>如果不部署在服务器根目录，需要在docs/.vuepress/config.js里添加base信息。</p><pre><code>//config.jsmodule.exports = {    title: '我的首页', // 显示在左上角的网页名称以及首页在浏览器标签显示的title名称    description: '我的首页记录', // meta 中的描述文字，用于SEO    // 注入到当前页面的 HTML &lt;head&gt; 中的标签    head: [        ['link', { rel: 'icon', href: '/egg.png' }],  //浏览器的标签栏的网页图标    ],    markdown: {        lineNumbers: true    },    serviceWorker: true,    themeConfig: {            logo: '/egg.png',        lastUpdated: 'lastUpdate', // string | boolean        nav: [            { text: '首页', link: '/' },            {                text: '分类',                ariaLabel: '分类',                items: [                    { text: '文章', link: '/pages/folder1/test1.md' },                    { text: '琐碎', link: '/pages/folder2/test4.md' },                ]            },            { text: '功能演示', link: '/pages/folder1/test3.md' },            { text: '联系我', link: 'https://www.baidu.com' },        ],        sidebar: {            '/pages/folder1/':[                {                    title: '测试菜单1',   // 必要的一级菜单名称                    collapsable: false, // 可选的, 默认值是 true折叠,                    sidebarDepth: 1,    // 可选的, 设置侧边导航自动提取markdown文件标题的层级，默认1为h2层级                    children: [                        ['test1.md', '子菜单1'],    //菜单名称为'子菜单1'，跳转至/pages/folder1/test1.md                        ['test3.md', '子菜单2']                    ]                },                {                    title: '测试菜单2',                    collapsable: false, // 可选的, 默认值是 true,                    children: [                        ['test2.md', '子菜单1']                    ]                }            ],            //...可添加多个不同的侧边栏，不同页面会根据路径显示不同的侧边栏        }    },    base: '/mydoc/'  //部署时服务器的发布目录}</code></pre><p><a href="https://pan.baidu.com/s/1M7J9CvwaR3TFp9dr3JKXuA" target="_blank">vuepress搭建在线文档demo</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中ListView的用法</title>
      <link href="/2020/07/15/diary-20200715-1/"/>
      <url>/2020/07/15/diary-20200715-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ListView的作用："><a href="#一、ListView的作用：" class="headerlink" title="一、ListView的作用："></a>一、ListView的作用：</h2><p>将数据填充到布局，处理用户的选择点击操作。<br>创建ListView需要3个元素：</p><ol><li>ListView中的每一列的View。</li><li>填入View的数据或图片资源等。</li><li>连接数据与ListView的适配器。</li></ol><h2 id="二、什么是适配器？"><a href="#二、什么是适配器？" class="headerlink" title="二、什么是适配器？"></a>二、什么是适配器？</h2><p>适配器是一个连接数据资源和AdapterView（如ListView）的桥梁，使用适配器能实现数据与AdapterView的分离，使AdapterView与数据的绑定更加简单，修改更加方便。<br>Android中常用的适配器Adapter有：</p><ul><li>ArrayAdapter<t>：用于绑定数组，支持泛型操作</t></li><li>SimpleAdapte：用于绑定在xml中定义的控件对应的数据</li><li>SimpleCursorAdapter：用于绑定游标得到的数据</li><li>BaseAdapter：通用的基础适配器</li></ul><h3 id="2-1-ArrayAdapter："><a href="#2-1-ArrayAdapter：" class="headerlink" title="2.1 ArrayAdapter："></a>2.1 ArrayAdapter<t>：</t></h3><p>用ArrayAdapter可实现简单的ListView数据绑定。默认情况下，ArrayAdapter绑定每个对象的toString值到layout中预先定义的TextView控件上。还可以实现带RadioButton和CheckBox的ListView。<br>在布局文件中添加一个ListView控件。</p><pre><code>&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;LinearLayoutxmlns:android="http://schemas.android.com/apk/res/android"    android:layout_width="fill_parent"    android:layout_height="fill_parent"    &gt;    &lt;ListView         android:id="@+id/lv"        android:layout_width="fill_parent"        android:layout_height="fill_parent"    /&gt;&lt;/LinearLayout&gt;</code></pre><p>然后在Activity中初始化。</p><pre><code>publicclass MyListView extends Activity {    privatestaticfinal String[] strs = new String[] {        "first", "second", "third", "fourth", "fifth"    };    //定义一个String数组用来显示ListView的内容    private ListView lv;    /** Called when the activity is first created. */    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        lv = (ListView) findViewById(R.id.lv);        //得到ListView对象的引用        /*为ListView设置Adapter来绑定数据*/        lv.setAdapter(new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1, strs));        /*处理用户的操作。通过如下的代码就可以为ListView绑定一个点击监听器*/        lv.setOnItemClickListener(new OnItemClickListener() {            @Override            publicvoid onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2,long arg3) {                //点击后在标题上显示点击了第几行                setTitle("你点击了第"+arg2+"行");            }        });    }}</code></pre><p>其中R.layout.simple_list_item_1是一个自定义的layout文件xml,必须要有TextView控件。比如长下面这个样子：</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;TextView xmlns:android="http://schemas.android.com/apk/res/android"    android:layout_width="match_parent"    android:layout_height="wrap_content"    android:orientation="vertical"&gt;&lt;/TextView&gt;</code></pre><p>分析一下以上简单的使用步骤：</p><ul><li>定义一个数组来存放ListView中item的内容。</li><li>通过实现ArrayAdapter的构造函数来创建一个ArrayAdapter的对象。</li><li>通过ListView的setAdapter()方法绑定ArrayAdapter。<br>其中第二步有必要说一下的是，ArrayAdapter有多个构造函数，例子中实现的是最常用的一种。第一个参数为上下文，第二个参数为一个包含TextView，用来填充ListView的每一行的布局资源ID。第三个参数为ListView的内容。其中第二个参数可以自定义一个layout，但是这个layout必须要有TextView控件。通常我们使用Android提供的资源，除了例子中所用的，常用的还有如下几种，可实现带RadioButton和CheckBox的ListView。</li></ul><h3 id="2-2-SimpleAdapter："><a href="#2-2-SimpleAdapter：" class="headerlink" title="2.2 SimpleAdapter："></a>2.2 SimpleAdapter：</h3><p>使用SimpleAdapter可以自定义实现ListView中的item的内容，比如图片、多选框等。使用simpleAdapter的数据一般都是用HashMap构成的列表，列表的每一节对应ListView的每一行。通过SimpleAdapter的构造函数，将HashMap的每个键的数据映射到布局文件中对应控件上。<br>很多时候需要在列表中展示一些除了文字以外的东西，比如图片等。这时候可以使用SimpleAdapter。SimpleAdapter的使用也非常简单，同时它的功能也非常强大。可以通过它自定义ListView中的item的内容，比如图片、多选框等。接下来这个例子，实现一个每一行都有一个ImageView和TextView的ListView。<br>在布局文件中添加一个ListView控件。</p><pre><code>&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;LinearLayoutxmlns:android="http://schemas.android.com/apk/res/android"    android:layout_width="fill_parent"    android:layout_height="fill_parent"    &gt;    &lt;ListView         android:id="@+id/lv"        android:layout_width="fill_parent"        android:layout_height="fill_parent"    /&gt;&lt;/LinearLayout&gt;</code></pre><p>定义一个ListView中每一行的布局item.xml，用RelativeLayout来实现一个带两行字和一个图片的布局。</p><pre><code>&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;RelativeLayoutxmlns:android="http://schemas.android.com/apk/res/android"    android:layout_height="fill_parent"    android:layout_width="fill_parent"    &gt;    &lt;ImageView android:layout_alignParentRight="true"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:id="@+id/ItemImage"    /&gt;    &lt;TextView android:id="@+id/ItemTitle"    android:layout_height="wrap_content"    android:layout_width="fill_parent"    android:textSize="20sp"/&gt;    &lt;TextViewandroid:id="@+id/ItemText"    android:layout_height="wrap_content"    android:layout_width="fill_parent"    android:layout_below="@+id/ItemTitle"    /&gt;&lt;/RelativeLayout&gt;</code></pre><p>配置完毕，就可以在Activity中为ListView绑定数据。</p><pre><code>    public class MyListViewSimple extends Activity {        private ListView lv;        /** Called when the activity is first created. */        @Override        public void onCreate(Bundle savedInstanceState) {            super.onCreate(savedInstanceState);            setContentView(R.layout.main);            lv = (ListView) findViewById(R.id.lv);            /*定义一个动态数组*/            ArrayList&lt;HashMap&lt;String, Object&gt;&gt; listItem = new ArrayList&lt;HashMap&lt;String,Object&gt;&gt;();            /*在数组中存放数据*/            for(int i=0;i&lt;10;i++)            {                HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();                map.put("ItemImage", R.drawable.icon);//加入图片                map.put("ItemTitle", "第"+i+"行");                map.put("ItemText", "这是第"+i+"行");                listItem.add(map);            }            SimpleAdapter mSimpleAdapter = new SimpleAdapter(this,listItem,R.layout.item,new String[] {"ItemImage","ItemTitle", "ItemText"},new int[] {R.id.ItemImage,R.id.ItemTitle,R.id.ItemText});            lv.setAdapter(mSimpleAdapter);//为ListView绑定适配器            lv.setOnItemClickListener(new OnItemClickListener() {                 @Override                public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2,long arg3) {                    setTitle("你点击了第"+arg2+"行");//设置标题栏显示点击的行                }            });            }    }</code></pre><p>使用simpleAdapter的数据一般都是用HashMap构成的列表，列表的每一节对应ListView的每一行。通过SimpleAdapter的构造函数，将HashMap的每个键的数据映射到布局文件中对应控件上。这个布局文件一般根据自己的需要来自己定义。梳理一下使用SimpleAdapter的步骤。</p><ul><li>根据需要定义ListView每行所实现的布局。</li><li>定义一个HashMap构成的列表，将数据以键值对的方式存放在里面。</li><li>构造SimpleAdapter对象。</li><li>将LsitView绑定到SimpleAdapter上。</li></ul><h3 id="2-3-BaseAdapter"><a href="#2-3-BaseAdapter" class="headerlink" title="2.3 BaseAdapter:"></a>2.3 BaseAdapter:</h3><p>当ListView不只是用于展示数据，还需要加入按钮等控件获取焦点时，使用BaseAdapter，因为SimpleAdapter添加一个按钮到ListView的条目中时，无法获得焦点，点击操作会被ListView的Item所覆盖。<br><font color="red">使用BaseAdapter必须写一个类继承它</font>，同时BaseAdapter是一个抽象类，继承它必须实现它的方法。BaseAdapter的灵活性就在于它要重写很多方法，以下是必须实现的方法</p><ul><li>***Adapter(Content)</li><li>getCount():int</li><li>getItem(int):Object</li><li>getItemId(int):long</li><li>getView(int,View,ViewGroup):View<br>其中最重要的即为getView()方法。这些方法都有什么作用呢？我们通过分析ListView的原理来揭晓。<br>当系统开始绘制ListView的时候，首先调用getCount()方法。得到它的返回值，即ListView的长度。然后系统调用getView()方法，根据这个长度逐一绘制ListView的每一行。也就是说，如果让getCount()返回1，那么只显示一行。而getItem()和getItemId()则在需要处理和取得Adapter中的数据时调用。那么getView如何使用呢？如果有10000行数据，就绘制10000次？这肯定会极大的消耗资源，导致ListView滑动非常的慢，那应该怎么做呢？通过一个例子来讲解如何在使用BaseAdapter的时候优化ListView的显示。例子中将上一节中的ImageView换成Button，并且处理Button的点击事件，其中对ListView的显示做了优化。<br>例子的布局文件同上一个例子类似，这里只给出Activity类。<pre><code>public class MyListViewBase extends Activity {  private ListView lv;  /*定义一个动态数组*/  ArrayList&lt;HashMap&lt;String, Object&gt;&gt;listItem;  /** Called when the activity is first created. */  @Override  public void onCreate(Bundle savedInstanceState) {      super.onCreate(savedInstanceState);      setContentView(R.layout.main);      lv = (ListView)findViewById(R.id.lv);      MyAdapter mAdapter = new MyAdapter(this);//得到一个MyAdapter对象      lv.setAdapter(mAdapter);//为ListView绑定Adapter      /*为ListView添加点击事件*/      lv.setOnItemClickListener(new OnItemClickListener() {          @Override          public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2,long arg3) {              Log.v("MyListViewBase", "你点击了ListView条目" + arg2);//在LogCat中输出信息          }      });  }  /*添加一个得到数据的方法，方便使用*/  private ArrayList&lt;HashMap&lt;String, Object&gt;&gt; getDate(){      ArrayList&lt;HashMap&lt;String,Object&gt;&gt; listItem = new ArrayList&lt;HashMap&lt;String,Object&gt;&gt;();      /*为动态数组添加数据*/          for(int i=0;i&lt;30;i++)      {          HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();          map.put("ItemTitle", "第"+i+"行");          map.put("ItemText", "这是第"+i+"行");          listItem.add(map);                 }      return listItem;  }  /* 新建一个类继承BaseAdapter，实现视图与数据的绑定     */  private class MyAdapter extends BaseAdapter {      private LayoutInflater mInflater;//得到一个LayoutInfalter对象用来导入布局      /*构造函数*/      public MyAdapter(Context context) {          this.mInflater = LayoutInflater.from(context);      }      @Override      public int getCount() {          return getDate().size();//返回数组的长度      }      @Override      public Object getItem(int position) {          return null;      }      @Override      public long getItemId(int position) {          return 0;      }      /*书中详细解释该方法*/      @Override      public View getView(finalint position, View convertView, ViewGroup parent) {          ViewHolder holder;                      //观察convertView随ListView滚动情况          Log.v("MyListViewBase", "getView " + position + " " + convertView);          if (convertView == null) {              convertView = mInflater.inflate(R.layout.item,null);              holder = new ViewHolder();              /*得到各个控件的对象*/              holder.title = (TextView) convertView.findViewById(R.id.ItemTitle);              holder.text = (TextView) convertView.findViewById(R.id.ItemText);              holder.bt = (Button) convertView.findViewById(R.id.ItemButton);              convertView.setTag(holder);//绑定ViewHolder对象          }else{              holder = (ViewHolder)convertView.getTag();//取出ViewHolder对象          }          /*设置TextView显示的内容，即我们存放在动态数组中的数据*/          holder.title.setText(getDate().get(position).get("ItemTitle").toString());          holder.text.setText(getDate().get(position).get("ItemText").toString());          /*为Button添加点击事件*/          holder.bt.setOnClickListener(new OnClickListener() {              @Override              public void onClick(View v) {                  Log.v("MyListViewBase", "你点击了按钮" + position);//打印Button的点击信息              }          });          return convertView;      }  }  /*存放控件*/  public final class ViewHolder{      public TextView title;      public TextView text;      public Button bt;  }}</code></pre>还需要注意的是，Button会抢夺ListView的焦点，需要将Button设置为没有焦点。设置非常简单，只需要在xml的Button标签下加入一行：android:focusable=“false”代码就可以了。<br>代码中getView()方法不容易理解。其实完全可以不用所谓的convertView和ViewHolder，直接导入布局并且设置控件显示的内容就可以了。但是这意味着有多少行数据就需要绘制多少行ListView，这显然是不可取的。这里采用了一种优化的方法。代码中，在getView()方法中加入了一行log输出convertView的内容。滚动ListView。<br>当启动Activity呈现第一屏ListView的时候，convertView为零。当用户向下滚动ListView时，上面的条目变为不可见，下面出现新的条目。这时候convertView不再为空，而是创建了一系列的convertView的值。当又往下滚一屏的时候，发现第11行的容器用来容纳第22行，第12行的容器用来容纳第23行。也就是说convertView相当于一个缓存，开始为0，当有条目变为不可见，它缓存了它的数据，后面再出来的条目只需要更新数据就可以了，这样大大节省了系统资料的开销。<br>还可以继续优化。虽然重复利用了已经绘制的view，但是要得到其中的控件，需要在控件的容器中通过findViewById的方法来获得。如果这个容器非常复杂，这显然会增加系统资源的开销。在上面的例子中，引入了Tag的概念。或许不是最好的办法，但是它确实能使ListView变得更流畅。代码中，当convertView为空时，用setTag()方法为每个View绑定一个存放控件的ViewHolder对象。当convertView不为空，重复利用已经创建的view的时候，使用getTag()方法获取绑定的ViewHolder对象，这样就避免了findViewById对控件的层层查询，而是快速定位到控件。<br>总结一下，这节介绍了用BaseAdapter来绑定ListView的数据。因为BaseAdapter非常灵活，使用也相对较其他控件麻烦。同时ListView的优化问题也值得读者去研究，一个流畅的ListView会带来更好的用户体验。</li></ul><h3 id="2-4-SimpleCursorAdapter："><a href="#2-4-SimpleCursorAdapter：" class="headerlink" title="2.4 SimpleCursorAdapter："></a>2.4 SimpleCursorAdapter：</h3><p>在SQLite中使用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熬过无人问津的日子，才有诗和远方</title>
      <link href="/2020/07/06/diary-20200706/"/>
      <url>/2020/07/06/diary-20200706/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/644219926.jpg" alt=""></p><center>推开世界的门</center><center>你是站在门外最孤单的人</center><center>捧着一颗不懂计较的认真</center><center>路过你的时候 时间多残忍</center><center>左手的泥呀 右手的泥呀</center><center>多泪的花衣裳</center><center>世界本该是你醒来的模样</center><center>左眼的悲伤 右眼的倔强</center><center>看起来都一样</center><center>原来你就是我自负的胆量</center><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BLE学习笔记3-BLE广播数据解析</title>
      <link href="/2020/07/05/diary-20200705-3/"/>
      <url>/2020/07/05/diary-20200705-3/</url>
      
        <content type="html"><![CDATA[<p>BLE设备工作的第一步就是向外广播数据。广播数据中带有设备相关的信息。本文主要说一下 BLE 的广播中的数据的规范以及广播包的解析。</p><h2 id="一、广播模式"><a href="#一、广播模式" class="headerlink" title="一、广播模式"></a>一、广播模式</h2><p>BLE 中有两种角色 Central 和 Peripheral ，也就是中心设备和外围设备。中心设备可以主动连接外围设备，外围设备发送广播或者被中心设备连接。外围通过广播被中心设备发现，广播中带有外围设备自身的相关信息。<br>广播包有两种： 广播包 （Advertising Data）和 响应包 （Scan Response），其中广播包是每个设备必须广播的，而响应包是可选的。 数据包的格式如下图所示<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/data_format.jpg" alt="数据包格式"><br>每个包都是 31 字节，数据包中分为有效数据（significant）和无效数据（non-significant）两部分。</p><ul><li>有效数据部分：包含若干个广播数据单元，称为 AD Structure。如图中所示，AD Structure 的组成是：第一个字节是长度值 Len，表示接下来的 Len 个字节是数据部分。数据部分的第一个字节表示数据的类型 AD Type，剩下的 Len - 1 个字节是真正的数据 AD data。其中 AD type 非常关键，决定了 AD Data 的数据代表的是什么和怎么解析，这个在《BLE学习笔记1-Android开发前言》里详细讲；</li><li>无效数据部分 ：因为广播包的长度必须是 31 个 byte，如果有效数据部分不到 31 自己，剩下的就用 0 补全。这部分的数据是无效的，解释的时候，忽略即可。<h2 id="二、广播数据解析"><a href="#二、广播数据解析" class="headerlink" title="二、广播数据解析"></a>二、广播数据解析</h2>在 Android 可以使用 BluetoothAdapter 来发起扫描。基本用法如下：<pre><code>BluetoothAdapter.LeScanCallback mLeScanCallback =    new BluetoothAdapter.LeScanCallback() {      @Override      public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) {          // 解析广播数据          parseAdvData(scanRecord);      }  };</code></pre></li></ul><p>mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();<br>// 开始扫描设备<br>mBluetoothAdapter.startLeScan(mLeScanCallback);<br>…<br>// 停止扫描设备<br>mBluetoothAdapter.stopLeScan(mLeScanCallback);  </p><pre><code>当扫描到设备以后，就会回调 onLeScan(...)，这里的参数 scanRecord 就是广播数据，这里同时包含广播数据和扫描相应数据（如果有的话），所以长度一般就是 62 字节。据上一节的广播数据格式的说明，可以实现解析广播数据函数 parseAdvData(scanRecord);，下面的代码实现了解析几个我关心的数据：</code></pre><p>public static ParsedAd parseData(byte[] adv_data) {<br>    ParsedAd parsedAd = new ParsedAd();<br>    ByteBuffer buffer = ByteBuffer.wrap(adv_data).order(ByteOrder.LITTLE_ENDIAN);<br>    while (buffer.remaining() &gt; 2) {<br>        byte length = buffer.get();<br>        if (length == 0)<br>            break;</p><pre><code>    byte type = buffer.get();    length -= 1;    switch (type) {        case 0x01: // Flags            parsedAd.flags = buffer.get();            length--;            break;        case 0x02: // Partial list of 16-bit UUIDs        case 0x03: // Complete list of 16-bit UUIDs        case 0x14: // List of 16-bit Service Solicitation UUIDs            while (length &gt;= 2) {                parsedAd.uuids.add(UUID.fromString(String.format(                        "%08x-0000-1000-8000-00805f9b34fb", buffer.getShort())));                length -= 2;            }            break;        case 0x04: // Partial list of 32 bit service UUIDs        case 0x05: // Complete list of 32 bit service UUIDs            while (length &gt;= 4) {                parsedAd.uuids.add(UUID.fromString(String.format(                        "%08x-0000-1000-8000-00805f9b34fb", buffer.getInt())));                length -= 4;            }            break;        case 0x06: // Partial list of 128-bit UUIDs        case 0x07: // Complete list of 128-bit UUIDs        case 0x15: // List of 128-bit Service Solicitation UUIDs            while (length &gt;= 16) {                long lsb = buffer.getLong();                long msb = buffer.getLong();                parsedAd.uuids.add(new UUID(msb, lsb));                length -= 16;            }            break;        case 0x08: // Short local device name        case 0x09: // Complete local device name            byte sb[] = new byte[length];            buffer.get(sb, 0, length);            length = 0;            parsedAd.localName = new String(sb).trim();            break;                        case (byte) 0xFF: // Manufacturer Specific Data            parsedAd.manufacturer = buffer.getShort();            length -= 2;            break;        default: // skip            break;    }    if (length &gt; 0) {        buffer.position(buffer.position() + length);    }}return parsedAd;</code></pre><p>}</p><pre><code>其中 ParsedAd 是自定义的简单 Java 对象，用来保存解析后的数据。这里只是解析了我关心的数据，你也可以根据前面的说明，解析更多的内容。## 三、参考资料- [蓝牙官方文档](https://www.bluetooth.org/en-us/specification/adopted-specifications)- [GAP Advertising and Scan Response Data format](https://devzone.nordicsemi.com/documentation/nrf51/4.2.0/html/group___b_l_e___g_a_p___a_d___t_y_p_e___d_e_f_i_n_i_t_i_o_n_s.html)- [Parsing BLE Advertisement packets](http://www.sfonge.com/forum/topic/parsing-ble-advertisement-packets)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BLE学习笔记2-GATT Profile简介</title>
      <link href="/2020/07/05/diary-20200705-2/"/>
      <url>/2020/07/05/diary-20200705-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>BLE低功耗蓝牙（Bluetooth Low Energy）连接都是建立在 GATT (Generic Attribute Profile) 协议之上。GATT 是一个在蓝牙连接之上的发送和接收很短的数据段的通用规范，这些很短的数据段被称为属性（Attribute）。</p><h2 id="二、GAP"><a href="#二、GAP" class="headerlink" title="二、GAP"></a>二、GAP</h2><p>详细介绍 GATT 之前，需要了解 GAP（Generic Access Profile），它在用来控制设备连接和广播。GAP 使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互。例如 Beacon 设备就只是向外广播，不支持连接，小米手环就等设备就可以与中心设备连接。</p><h3 id="2-1-设备角色"><a href="#2-1-设备角色" class="headerlink" title="2.1 设备角色"></a>2.1 设备角色</h3><p>GAP 给设备定义了若干角色，其中主要的两个是：外围设备（Peripheral）和中心设备（Central）。</p><ul><li>外围设备：这一般就是非常小或者简单的低功耗设备，用来提供数据，并连接到一个更加相对强大的中心设备。例如小米手环。</li><li>中心设备：中心设备相对比较强大，用来连接其他外围设备。例如手机等。<h3 id="2-2-广播数据"><a href="#2-2-广播数据" class="headerlink" title="2.2 广播数据"></a>2.2 广播数据</h3>在 GAP 中外围设备通过两种方式向外广播数据： Advertising Data Payload（广播数据）和 Scan Response Data Payload（扫描回复），每种数据最长可以包含 31 byte。这里广播数据是必需的，因为外设必需不停的向外广播，让中心设备知道它的存在。扫描回复是可选的，中心设备可以向外设请求扫描回复，这里包含一些设备额外的信息，例如设备的名字。<h3 id="2-3-广播流程"><a href="#2-3-广播流程" class="headerlink" title="2.3 广播流程"></a>2.3 广播流程</h3>GAP 的广播工作流程如下图所示。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GAP_adv_proc.jpg" alt="GAP的广播工作流程"><br>从图中我们可以清晰看出广播数据和扫描回复数据是怎么工作的。外围设备会设定一个广播间隔，每个广播间隔中，它会重新发送自己的广播数据。广播间隔越长，越省电，同时也不太容易扫描到。<h3 id="2-4-广播的网络拓扑结构"><a href="#2-4-广播的网络拓扑结构" class="headerlink" title="2.4 广播的网络拓扑结构"></a>2.4 广播的网络拓扑结构</h3>大部分情况下，外设通过广播自己来让中心设备发现自己，并建立 GATT 连接，从而进行更多的数据交换。也有些情况是不需要连接的，只要外设广播自己的数据即可。用这种方式主要目的是让外围设备，把自己的信息发送给多个中心设备。因为基于 GATT 连接的方式的，只能是一个外设连接一个中心设备。 使用广播这种方式最典型的应用就是苹果的 iBeacon。广播工作模式下的网络拓扑图如下：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GAP_BroadcastTopology.jpg" alt="广播工作模式网络拓扑图"><h2 id="三、GATT"><a href="#三、GATT" class="headerlink" title="三、GATT"></a>三、GATT</h2>GATT 的全名是 Generic Attribute Profile（姑且翻译成：普通属性协议），它定义两个东西(Service和Characteristic)用于BLE设备的通信。GATT使用ATT（Attribute Protocol）协议，把 Service, Characteristic对应的数据保存在一个查找表中，次查找表使用 16 bit ID 作为每一项的索引。<br>一旦两个设备建立起了连接，GATT 就开始起作用了，这也意味着，你必需完成前面的 GAP 协议。这里需要说明的是，GATT 连接，必需先经过 GAP 协议。实际上，我们在 Android 开发中，可以直接使用设备的 MAC 地址，发起连接，可以不经过扫描的步骤。这并不意味不需要经过 GAP，实际上在芯片级别已经给你做好了，蓝牙芯片发起连接，总是先扫描设备，扫描到了才会发起连接。<br>GATT 连接需要特别注意的是：<code>GATT 连接是独占的</code>。也就是一个 BLE 外设同时只能被一个中心设备连接。一旦外设被连接，它就会马上停止广播，这样它就对其他设备不可见了。当设备断开，它又开始广播。<br>中心设备和外设需要双向通信的话，唯一的方式就是建立 GATT 连接。<h3 id="3-1-GATT连接的网络拓扑"><a href="#3-1-GATT连接的网络拓扑" class="headerlink" title="3.1 GATT连接的网络拓扑"></a>3.1 GATT连接的网络拓扑</h3>下图展示了 GTT 连接网络拓扑结构。这里很清楚的显示，一个外设只能连接一个中心设备，而一个中心设备可以连接多个外设。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GATT_network_topology.jpg" alt="GATT连接的网络拓扑"><br>一旦建立起了连接，通信就是双向的了，对比前面的 GAP 广播的网络拓扑，GAP 通信是单向的。如果你要让两个设备外设能通信，就只能通过中心设备中转。<h3 id="3-2-GATT-通信事务"><a href="#3-2-GATT-通信事务" class="headerlink" title="3.2 GATT 通信事务"></a>3.2 GATT 通信事务</h3>GATT 通信的双方是 C/S 关系。外设作为 GATT 服务端（Server），它维持了 ATT 的查找表以及 service 和 characteristic 的定义。中心设备是 GATT 客户端（Client），它向 Server 发起请求。需要注意的是，所有的通信事件，都是由客户端（也叫主设备，Master）发起，并且接收服务端（也叫从设备，Slave）的响应。<br>一旦连接建立，外设将会给中心设备建议一个连接间隔（Connection Interval）,这样，中心设备就会在每个连接间隔尝试去重新连接，检查是否有新的数据。但是，这个连接间隔只是一个建议，你的中心设备可能并不会严格按照这个间隔来执行，例如你的中心设备正在忙于连接其他的外设，或者中心设备资源太忙。<br>下图展示一个外设（GATT 服务端）和中心设备（GATT 客户端）之间的数据交换流程，可以看到的是，每次都是主设备发起请求：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GATT_MasterSlaveTransactions.jpg" alt="外设与中心设备数据交换"><h3 id="3-3-GATT结构"><a href="#3-3-GATT结构" class="headerlink" title="3.3 GATT结构"></a>3.3 GATT结构</h3>GATT 通信事务是建立在嵌套的Profiles, Services 和 Characteristics之上的的，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GATT_Structure.jpg" alt="GATT结构"></li><li><code>Profile</code> Profile 并不是实际存在于 BLE 外设上的，它只是一个被 Bluetooth SIG 或者外设设计者预先定义的 Service 的集合。例如心率Profile（Heart Rate Profile）就是结合了 Heart Rate Service 和 Device Information Service。所有官方通过 GATT Profile 的列表可以从<a href="http://developer.bluetooth.org/TechnologyOverview/Pages/Profiles.aspx#GATT" target="_blank" rel="noopener">这里</a>找到。 </li><li><code>Service</code> Service 是把数据分成一个个的独立逻辑项，它包含一个或者多个 Characteristic。每个 Service 有一个 UUID 唯一标识。 UUID 有 16 bit 的，或者 128 bit 的。16 bit 的 UUID 是官方通过认证的，需要花钱购买，128 bit 是自定义的，这个就可以自己随便设置。<br>官方通过了一些标准 Service，完整列表在<a href="https://developer.bluetooth.org/gatt/services/Pages/ServicesHome.aspx" target="_blank" rel="noopener">这里</a>。以 Heart Rate Service为例，可以看到它的官方通过 16 bit UUID 是 0x180D，包含 3 个 Characteristic：Heart Rate Measurement, Body Sensor Location 和 Heart Rate Control Point，并且定义了只有第一个是必须的，它是可选实现的。</li><li><code>Characteristic</code> 在 GATT 事务中的最低界别的是 Characteristic，Characteristic 是最小的逻辑数据单元，当然它可能包含一个组关联的数据，例如加速度计的 X/Y/Z 三轴值。<br>与 Service 类似，每个 Characteristic 用 16 bit 或者 128 bit 的 UUID 唯一标识。你可以免费使用 Bluetooth SIG 官方定义的标准 Characteristic，使用官方定义的，可以确保 BLE 的软件和硬件能相互理解。当然，你可以自定义 Characteristic，这样的话，就只有你自己的软件和外设能够相互理解。<br>实际上，和 BLE 外设打交道，主要是通过 Characteristic。你可以从 Characteristic 读取数据，也可以往 Characteristic 写数据。这样就实现了双向的通信。所以你可以自己实现一个类似串口（UART）的 Sevice，这个 Service 中包含两个 Characteristic，一个被配置只读的通道（RX），另一个配置为只写的通道（TX）。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BLE学习笔记1-Android开发前言</title>
      <link href="/2020/07/05/diary-20200705-1/"/>
      <url>/2020/07/05/diary-20200705-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、相关介绍"><a href="#一、相关介绍" class="headerlink" title="一、相关介绍"></a>一、相关介绍</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><p>本文主要描述Android BLE的一些基础知识及相关操作流程，不牵扯具体的业务实现，其中提供了针对广播包及响应包的解析思路。<br>蓝牙的创始公司是爱立信。1994年爱立信开始对小范围无线通信技术进行研发，在1997年，爱立信的研究激发了其他公司的浓厚兴趣，于是1998年2月，一些跨国大公司包括诺基亚、苹果、三星组成的一个特殊兴趣小组（SIG），他们共同的目标是建立一个全球性的小范围无线通信技术，该项技术就是蓝牙。</p><p>蓝牙无线技术是一种全球通用的短距离无线技术，通过蓝牙技术能够实现多种电子设备间的相互连接，特别是在小型无线电、耗电量低、成本低、安全性、稳定性、易用性以及特别的联网能力等固有的优势上，蓝牙无线技术发展迅速。</p><h3 id="1-2分类"><a href="#1-2分类" class="headerlink" title="1.2分类"></a>1.2分类</h3><p>蓝牙分为三种：Bluetooth Smart Ready、Bluetooth Smart（Smart是低功耗蓝牙的标识）、以及标准 Bluetooth。根据 Bluetooth SIG的说法，这样是为了要分辨装置间的相容性以及标识各版本的传输频率。基本上来说，Bluetooth Smart Ready适用于任何双模蓝牙4.0的电子产品,而Bluetooth Smart是应用在心率监视器或计步器等使用扭扣式电池并传输单一的装置。Bluetooth Smart Ready的相容性最高，可与Bluetooth Smart及标准蓝牙相通。标准蓝牙则无法与Bluetooth Smart相通。</p><h3 id="1-3BLE分类"><a href="#1-3BLE分类" class="headerlink" title="1.3BLE分类"></a>1.3BLE分类</h3><p>BLE是Bluetooth Low Energy的缩写，又叫蓝牙4.0，区别于蓝牙3.0和之前的技术。BLE前身是NOKIA开发的Wibree技术，主要用于实现移动智能终端与周边配件之间的持续连接，是功耗极低的短距离无线通信技术，并且有效传输距离被提升到了100米以上，同时只需要一颗纽扣电池就可以工作数年之久。BLE是在蓝牙技术的基础上发展起来的，既同于蓝牙，又区别于传统蓝牙。BLE设备分单模和双模两种，双模简称BR，商标为Bluetooth Smart Ready，单模简称BLE或者LE,商标为Bluetooth Smart。Android是在4.3后才支持BLE，这说明不是所有蓝牙手机都支持BLE，而且支持BLE的蓝牙手机一般是双模的。双模兼容传统蓝牙，可以和传统蓝牙通信，也可以和BLE通信，常用在手机上，android4.3和IOS4.0之后版本都支持BR，也就是双模设备。单模只能和BR和单模的设备通信，不能和传统蓝牙通信，由于功耗低，待机长，所以常用在手环的智能设备上。</p><h3 id="1-4蓝牙的工作原理"><a href="#1-4蓝牙的工作原理" class="headerlink" title="1.4蓝牙的工作原理"></a>1.4蓝牙的工作原理</h3><h4 id="1-4-1-蓝牙通信的主从关系"><a href="#1-4-1-蓝牙通信的主从关系" class="headerlink" title="1.4.1 蓝牙通信的主从关系"></a>1.4.1 蓝牙通信的主从关系</h4><p>蓝牙技术规定每一对设备之间进行蓝牙通讯时，必须一个为主角色，另一为从角色，才能进行通信，通信时，必须由主端进行查找，发起配对，建链成功后，双方即可收发数据。理论上，一个蓝牙主端设备，可同时与7个蓝牙从端设备进行通讯。一个具备蓝牙通讯功能的设备，可以在两个角色间切换，平时工作在从模式，等待其它主设备来连接，需要时，转换为主模式，向其它设备发起呼叫。一个蓝牙设备以主模式发起呼叫时，需要知道对方的蓝牙地址，配对密码等信息，配对完成后，可直接发起呼叫。这可以解释为什么有时无法连接蓝牙，有可能是连接的蓝牙设备过多。</p><h4 id="1-4-2-蓝牙的呼叫过程"><a href="#1-4-2-蓝牙的呼叫过程" class="headerlink" title="1.4.2 蓝牙的呼叫过程"></a>1.4.2 蓝牙的呼叫过程</h4><p>蓝牙主端设备发起呼叫，首先是查找，找出周围处于可被查找的蓝牙设备。主端设备找到从端蓝牙设备后，与从端蓝牙设备进行配对，此时需要输入从端设备的PIN码，也有设备不需要输入PIN码。配对完成后，从端蓝牙设备会记录主端设备的信任信息，此时主端即可向从端设备发起呼叫，已配对的设备在下次呼叫时，不再需要重新配对。已配对的设备，做为从端的蓝牙耳机也可以发起建链请求，但做数据通讯的蓝牙模块一般不发起呼叫。链路建立成功后，主从两端之间即可进行双向的数据或语音通讯。在通信状态下，主端和从端设备都可以发起断链，断开蓝牙链路。</p><h4 id="1-4-3-蓝牙一对一的串口数据传输应用"><a href="#1-4-3-蓝牙一对一的串口数据传输应用" class="headerlink" title="1.4.3 蓝牙一对一的串口数据传输应用"></a>1.4.3 蓝牙一对一的串口数据传输应用</h4><p>蓝牙数据传输应用中，一对一串口数据通讯是最常见的应用之一，蓝牙设备在出厂前即提前设好两个蓝牙设备之间的配对信息，主端预存有从端设备的PIN码、地址等，两端设备加电即自动建链，透明串口传输，无需外围电路干预。一对一应用中从端设备可以设为两种类型，一是静默状态，即只能与指定的主端通信，不被别的蓝牙设备查找；二是开发状态，既可被指定主端查找，也可以被别的蓝牙设备查找建链。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><h3 id="2-1-Generic-Access-Profile-GAP"><a href="#2-1-Generic-Access-Profile-GAP" class="headerlink" title="2.1 Generic Access Profile(GAP)"></a>2.1 Generic Access Profile(GAP)</h3><p>用来控制设备连接和广播，GAP使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互。    </p><h3 id="2-2-Generic-Attribute-Profile-GATT"><a href="#2-2-Generic-Attribute-Profile-GATT" class="headerlink" title="2.2 Generic Attribute Profile(GATT)"></a>2.2 Generic Attribute Profile(GATT)</h3><p>通过BLE连接，读写属性类数据的Profile通用规范，现在所有的BLE应用Profile都是基于GATT的。     </p><h3 id="2-3-Attribute-Protocol-ATT"><a href="#2-3-Attribute-Protocol-ATT" class="headerlink" title="2.3 Attribute Protocol (ATT)"></a>2.3 Attribute Protocol (ATT)</h3><p>GATT是基于ATTProtocol的，ATT针对BLE设备做了专门的优化，具体就是在传输过程中使用尽量少的数据，每个属性都有一个唯一的UUID，属性将以characteristics and services的形式传输。    </p><h3 id="2-4-Characteristic"><a href="#2-4-Characteristic" class="headerlink" title="2.4 Characteristic"></a>2.4 Characteristic</h3><p>Characteristic可以理解为一个数据类型，它包括一个value和0至多个对次value的描述（Descriptor）。</p><h3 id="2-5-Descriptor"><a href="#2-5-Descriptor" class="headerlink" title="2.5 Descriptor"></a>2.5 Descriptor</h3><p>对Characteristic的描述，例如范围、计量单位等。</p><h3 id="2-6-Service"><a href="#2-6-Service" class="headerlink" title="2.6 Service"></a>2.6 Service</h3><p>Characteristic的集合。例如一个service叫做“Heart Rate Monitor”，它可能包含多个Characteristics，其中可能包含一个叫做“heart ratemeasurement”的Characteristic。 </p><h3 id="2-7-UUID"><a href="#2-7-UUID" class="headerlink" title="2.7 UUID"></a>2.7 UUID</h3><p>唯一标示符，每个Service，Characteristic，Descriptor，都是由一个UUID定义。</p><h3 id="2-8-角色和职责"><a href="#2-8-角色和职责" class="headerlink" title="2.8 角色和职责"></a>2.8 角色和职责</h3><p>Android设备与BLE设备交互有两组角色</p><ul><li>中心设备和外围设备（Central vs. peripheral）</li></ul><p>Central角色负责scan advertisement。而peripheral角色负责make advertisement。<br>这两种角色取决于BLE连接成功后，两个设备间通信的方式。<br>现有一个活动追踪的BLE设备和一个支持BLE的Android设备。Android设备支持Central角色，而BLE设备支持peripheral角色。创建一个BLE连接需要这两个角色都存在，都仅支持Central角色或者都仅支持peripheral角色则无法建立连接。<br>当连接建立后，它们之间就需要传输GATT数据。谁做server，谁做client，则取决于具体数据传输的情况。例如，如果活动追踪的BLE设备需要向 Android设备传输sensor数据，则活动追踪器自然成为了server端；而如果活动追踪器需要从Android设备获取更新信息，则 Android设备作为server端可能更合适。</p><h3 id="2-9-权限及feature"><a href="#2-9-权限及feature" class="headerlink" title="2.9 权限及feature"></a>2.9 权限及feature</h3><p>和经典蓝牙一样，应用使用蓝牙，需要声明BLUETOOTH权限，如果需要扫描设备或者操作蓝牙设置，则还需要BLUETOOTH_ADMIN权限：</p><pre><code>&lt;uses-permissionandroid:name="android.permission.BLUETOOTH"/&gt;&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/&gt;</code></pre><p>除了蓝牙权限外，如果需要BLE feature则还需要声明uses-feature：</p><pre><code>&lt;uses-featureandroid:name="android.hardware.bluetooth_le"android:required="true"/&gt;</code></pre><p>按时required为true时，则应用只能在支持BLE的Android设备上安装运行；required为false时，Android设备均可正常安装运行，需要在代码运行时判断设备是否支持BLE feature：</p><pre><code>// Use this check to determine whether BLE is supportedon the device. Then// you can selectively disable BLE-related features.if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)){    Toast.makeText(this, R.string.ble_not_supported,Toast.LENGTH_SHORT).show();    finish();}</code></pre><h2 id="三、Android-BLE-API"><a href="#三、Android-BLE-API" class="headerlink" title="三、Android BLE API"></a>三、Android BLE API</h2><h3 id="3-1-BluetoothGatt"><a href="#3-1-BluetoothGatt" class="headerlink" title="3.1 BluetoothGatt"></a>3.1 BluetoothGatt</h3><p>继承BluetoothProfile，通过BluetoothGatt可以连接设备（connect）,发现服务（discoverServices），并把相应地属性返回到BluetoothGattCallback，可以看成蓝牙设备从连接到断开的生命周期。</p><h3 id="3-2-BluetoothGattCharacteristic"><a href="#3-2-BluetoothGattCharacteristic" class="headerlink" title="3.2 BluetoothGattCharacteristic"></a>3.2 BluetoothGattCharacteristic</h3><p>相当于一个数据类型，可以看成一个特征或能力，它包括一个value和0~n个value的描述（BluetoothGattDescriptor）。</p><h3 id="3-3-BluetoothGattDescriptor"><a href="#3-3-BluetoothGattDescriptor" class="headerlink" title="3.3 BluetoothGattDescriptor"></a>3.3 BluetoothGattDescriptor</h3><p>描述符，对Characteristic的描述，包括范围、计量单位等。</p><h3 id="3-4-BluetoothGattService"><a href="#3-4-BluetoothGattService" class="headerlink" title="3.4 BluetoothGattService"></a>3.4 BluetoothGattService</h3><p>服务，Characteristic的集合。</p><h3 id="3-5-BluetoothProfile"><a href="#3-5-BluetoothProfile" class="headerlink" title="3.5 BluetoothProfile"></a>3.5 BluetoothProfile</h3><p>一个通用的规范，按照这个规范来收发数据。 </p><h3 id="3-6-BluetoothManager"><a href="#3-6-BluetoothManager" class="headerlink" title="3.6 BluetoothManager"></a>3.6 BluetoothManager</h3><p>通过BluetoothManager来获取BluetoothAdapter。</p><pre><code>BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);</code></pre><h3 id="3-7-BluetoothAdapter"><a href="#3-7-BluetoothAdapter" class="headerlink" title="3.7 BluetoothAdapter"></a>3.7 BluetoothAdapter</h3><p>代表了移动设备的本地的蓝牙适配器, 通过该蓝牙适配器可以对蓝牙进行基本操作，一个Android系统只有一个BluetoothAdapter，通过BluetoothManager获取。</p><pre><code>BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();</code></pre><h3 id="3-8-BluetoothDevice"><a href="#3-8-BluetoothDevice" class="headerlink" title="3.8 BluetoothDevice"></a>3.8 BluetoothDevice</h3><p>扫描后发现可连接的设备，获取已经连接的设备。 </p><pre><code>BluetoothDevice bluetoothDevice = bluetoothAdapter.getRemoteDevice(address);</code></pre><h3 id="3-9-BluetoothGattCallback"><a href="#3-9-BluetoothGattCallback" class="headerlink" title="3.9 BluetoothGattCallback"></a>3.9 BluetoothGattCallback</h3><p>已经连接上设备，对设备的某些操作后返回的结果。 </p><pre><code>BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback(){    //实现回调方法，根据业务做相应处理};BluetoothGatt bluetoothGatt = bluetoothDevice.connectGatt(this, false, bluetoothGattCallback);</code></pre><h2 id="四、操作流程"><a href="#四、操作流程" class="headerlink" title="四、操作流程"></a>四、操作流程</h2><h3 id="4-1-开启蓝牙"><a href="#4-1-开启蓝牙" class="headerlink" title="4.1 开启蓝牙"></a>4.1 开启蓝牙</h3><p>在使用蓝牙BLE之前，需要确认Android设备是否支持BLE feature(required为false时)，另外要需要确认蓝牙是否打开。如果发现不支持BLE，则不能使用BLE相关的功能；如果支持BLE，但是蓝牙没打开，则需要打开蓝牙。代码示例如下：</p><pre><code>//是否支持蓝牙模块@TargetApi(18)public static boolean isSupportBle(Context context) {    if(context != null &amp;&amp; context.getPackageManager().hasSystemFeature("android.hardware.bluetooth_le")) {        BluetoothManager manager = (BluetoothManager)context.getSystemService("bluetooth");        return manager.getAdapter() != null;    } else {        return false;    }}//是否开启蓝牙@TargetApi(18)public static boolean isBleEnable(Context context) {    if(!isSupportBle(context)) {        return false;    } else {        BluetoothManager manager = (BluetoothManager)context.getSystemService("bluetooth");        return manager.getAdapter().isEnabled();    }}//开启蓝牙public static void enableBle(Activity act, int requestCode) {    Intent mIntent = new Intent("android.bluetooth.adapter.action.REQUEST_ENABLE");    act.startActivityForResult(mIntent, requestCode);}//蓝牙开启过程if(isSupportBle(mContext)){    //支持蓝牙模块    if(!isBleEnable(mContext)){        //没开启蓝牙则开启        enableBle(mSelfActivity, 1);    }} else{    //不支持蓝牙模块处理}//蓝牙开启回调@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {    //判断requestCode是否为开启蓝牙时传进去的值，再做相应处理    if(requestCode == 1){        //蓝牙开启成功后的处理    }    super.onActivityResult(requestCode, resultCode, data);}</code></pre><h3 id="4-2-设备搜索"><a href="#4-2-设备搜索" class="headerlink" title="4.2 设备搜索"></a>4.2 设备搜索</h3><ul><li><p>BluetoothAdapter.startDiscovery在大多数手机上是可以同时发现经典蓝牙和Ble的，但是startDiscovery的回调无法返回Ble的广播，所以无法通过广播识别设备，且startDiscovery扫描Ble的效率比StartLeScan低很多。所以在实际应用中，还是StartDiscovery和StartLeScan分开扫，前者扫传统蓝牙，后者扫低功耗蓝牙。</p></li><li><p>由于搜索需要尽量减少功耗，因此在实际使用时需要注意：当找到对应的设备后，立即停止扫描；不要循环搜索设备，为每次搜索设置适合的时间限制，避免设备不在可用范围的时候持续不停扫描，消耗电量。 </p></li><li><p>通过调用BluetoothAdapter的 startLeScan() 搜索BLE设备。调用此方法时需要传入 BluetoothAdapter.LeScanCallback 参数。具体代码示例如下：</p><pre><code>BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();bluetoothAdapter.startLeScan(new BluetoothAdapter.LeScanCallback() {  @Override  public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {      //对扫描到的设备进行处理，可以依据BluetoothDevice中的信息、信号强度rssi以及广播包和响应包组成的scanRecord字节数组进行分析  }});</code></pre><h3 id="4-3-设备通信"><a href="#4-3-设备通信" class="headerlink" title="4.3 设备通信"></a>4.3 设备通信</h3><p>两个设备通过BLE通信，首先需要建立GATT连接，这里我们讲的是Android设备作为client端，连接GATT Server。连接GATT Server，需要调用BluetoothDevice的connectGatt()方法，此函数带三个参数：Context、autoConnect(boolean)和 BluetoothGattCallback 对象。调用后返回BluetoothGatt对象，它是GATT profile的封装，通过这个对象，我们就能进行GATT Client端的相关操作。如断开连接<code>bluetoothGatt.disconnect()</code>，发现服务 <code>bluetoothGatt.discoverServices()</code> 等等。示例代码如下： </p><pre><code>BluetoothDevice bluetoothDevice = bluetoothAdapter.getRemoteDevice(address);BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback(){  @Override  public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {      super.onConnectionStateChange(gatt, status, newState);  }  @Override  public void onServicesDiscovered(BluetoothGatt gatt, int status) {      super.onServicesDiscovered(gatt, status);  }  @Override  public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {      super.onCharacteristicRead(gatt, characteristic, status);  }  @Override  public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {      super.onCharacteristicWrite(gatt, characteristic, status);  }  @Override  public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {      super.onCharacteristicChanged(gatt, characteristic);  }  @Override  public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {      super.onDescriptorRead(gatt, descriptor, status);  }  @Override  public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {      super.onDescriptorWrite(gatt, descriptor, status);  }  @Override  public void onReliableWriteCompleted(BluetoothGatt gatt, int status) {      super.onReliableWriteCompleted(gatt, status);  }  @Override  public void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) {      super.onReadRemoteRssi(gatt, rssi, status);  }  @Override  public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) {      super.onMtuChanged(gatt, mtu, status);  }};BluetoothGatt bluetoothGatt = bluetoothDevice.connectGatt(this, false, bluetoothGattCallback);</code></pre></li></ul><p>//以下为获得Gatt后的相关操作对应的响应方法<br>//notification to onCharacteristicChanged；<br>bluetoothGatt.setCharacteristicNotification(characteristic, true);</p><p>//readCharacteristic to onCharacteristicRead；<br>bluetoothGatt.readCharacteristic(characteristic);</p><p>//writeCharacteristic to onCharacteristicWrite；<br>bluetoothGatt.wirteCharacteristic(mCurrentcharacteristic);</p><p>//connect and disconnect to onConnectionStateChange；<br>bluetoothGatt.connect();<br>bluetoothGatt.disconnect();</p><p>//readDescriptor to onDescriptorRead；<br>bluetoothGatt.readDescriptor(descriptor);</p><p>//writeDescriptor to onDescriptorWrite；<br>bluetoothGatt.writeDescriptor(descriptor);</p><p>//readRemoteRssi to onReadRemoteRssi；<br>bluetoothGatt.readRemoteRssi();</p><p>//executeReliableWrite to onReliableWriteCompleted；<br>bluetoothGatt.executeReliableWrite();</p><p>//discoverServices to onServicesDiscovered;<br>bluetoothGatt.discoverServices();</p><pre><code>### 4.4 数据解析 - BLE中有两种角色Central和Peripheral，也就是中心设备和外围设备，中心设备可以主动连接外围设备，外围设备发送广播或者被中心设备连接，外围通过广播被中心设备发现，广播中带有外围设备自身的相关信息。- 数据包有两种：广播包（Advertising Data）和响应包（Scan Response），其中广播包是每个设备必须广播的，而响应包是可选的。![数据包格式](https://gitee.com/seanzs/pic/raw/master/img/data_format.jpg)数据包的格式为每个包都是 31 字节，数据包中分为有效数据（significant）和无效数据（non-significant）两部分。- 有效数据部分：包含若干个广播数据单元，称为AD Structure。如图中所示，AD Structure的组成是：第一个字节是长度值Len，表示接下来的Len个字节是数据部分。数据部分的第一个字节表示数据的类型AD Type，剩下的Len - 1个字节是真正的数据AD data。其中AD type非常关键，决定了AD Data的数据代表的是什么和怎么解析，这个在后面会详细讲；- 无效数据部分：因为广播包的长度必须是31字节，如果有效数据部分不到31字节，剩下的就用0补齐，这部分的数据是无效的，解析的时候，直接忽略即可。- 查看Nordic的SDK中的定义，AD type的定义在程序的“ble_gap.h”头文件中。定义如下：</code></pre><p>#define BLE_GAP_AD_TYPE_FLAGS                               0x01 //&lt; Flags for discoverability.<br>#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE   0x02 //&lt; Partial list of 16 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE         0x03 //&lt; Complete list of 16 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_MORE_AVAILABLE   0x04 //&lt; Partial list of 32 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_COMPLETE         0x05 //&lt; Complete list of 32 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE  0x06 //&lt; Partial list of 128 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE        0x07 //&lt; Complete list of 128 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME                    0x08 //&lt; Short local device name.<br>#define BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME                 0x09 //&lt; Complete local device name.<br>#define BLE_GAP_AD_TYPE_TX_POWER_LEVEL                      0x0A //&lt; Transmit power level.<br>#define BLE_GAP_AD_TYPE_CLASS_OF_DEVICE                     0x0D //&lt; Class of device.<br>#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C               0x0E //&lt; Simple Pairing Hash C.<br>#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R         0x0F //&lt; Simple Pairing Randomizer R.<br>#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_TK_VALUE           0x10 //&lt; Security Manager TK Value.<br>#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_OOB_FLAGS          0x11 //&lt; Security Manager Out Of Band Flags.<br>#define BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE     0x12 //&lt; Slave Connection Interval Range.<br>#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT       0x14 //&lt; List of 16-bit Service Solicitation UUIDs.<br>#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT      0x15 //&lt; List of 128-bit Service Solicitation UUIDs.<br>#define BLE_GAP_AD_TYPE_SERVICE_DATA                        0x16 //&lt; Service Data - 16-bit UUID.<br>#define BLE_GAP_AD_TYPE_PUBLIC_TARGET_ADDRESS               0x17 //&lt; Public Target Address.<br>#define BLE_GAP_AD_TYPE_RANDOM_TARGET_ADDRESS               0x18 //&lt; Random Target Address.<br>#define BLE_GAP_AD_TYPE_APPEARANCE                          0x19 //&lt; Appearance.<br>#define BLE_GAP_AD_TYPE_ADVERTISING_INTERVAL                0x1A //&lt; Advertising Interval.<br>#define BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS         0x1B //&lt; LE Bluetooth Device Address.<br>#define BLE_GAP_AD_TYPE_LE_ROLE                             0x1C //&lt; LE Role.<br>#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C256            0x1D //&lt; Simple Pairing Hash C-256.<br>#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R256      0x1E //&lt; Simple Pairing Randomizer R-256.<br>#define BLE_GAP_AD_TYPE_SERVICE_DATA_32BIT_UUID             0x20 //&lt; Service Data - 32-bit UUID.<br>#define BLE_GAP_AD_TYPE_SERVICE_DATA_128BIT_UUID            0x21 //&lt; Service Data - 128-bit UUID.<br>#define BLE_GAP_AD_TYPE_3D_INFORMATION_DATA                 0x3D //&lt; 3D Information Data.<br>#define BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA          0xFF //&lt; Manufacturer Specific Data.</p><pre><code>- 所有的 AD Type 的定义在文档[Core Specification Supplement](https://www.bluetooth.com/specifications/adopted-specifications)中，根据上面头文件中的定义，AD Type包括如下类型：- `Flags`     1. TYPE = 0x01： 这个数据用来标识设备 LE 物理连接的功能，DATA 是 0 到多个字节的 Flag 值，每个 bit 上用 0 或者 1 来表示是否为 True。如果有任何一个 bit 不为 0，并且广播包是可连接的，就必须包含此数据。各 bit 的定义如下：    ```    bit 0: LE有限发现模式    bit 1: LE普通发现模式    bit 2: 不支持BR/EDR    bit 3: 对Same Device Capable(Controller)同时支持BLE和BR/EDR    bit 4: 对Same Device Capable(Host)同时支持BLE和BR/EDR    bit 5..7: 预留    ```    - `Service UUID`广播数据中一般都会把设备支持的 GATT Service 广播出来，用来告诉外面本设备所支持的 Service。有三种类型的 UUID：16 bit, 32bit, 128 bit。广播中，每种类型类型有有两个类别：完整和非完整的。这样就共有 6 种 AD Type2. TYPE = 0x02：非完整的16 bit UUID列表3. TYPE = 0x03：完整的16 bit UUID列表4. TYPE = 0x04：非完整的32 bit UUID列表5. TYPE = 0x05：完整的32 bit UUID列表6. TYPE = 0x06：非完整的128 bit UUID列表7. TYPE = 0x07：完整的128 bit UUID列表 - `Local Name`设备名字，DATA 是名字的字符串。 Local Name 可以是设备的全名，也可以是设备名字的缩写，其中缩写必须是全名的前面的若干字符。     8. TYPE = 0x08：设备简称     9. TYPE = 0x09：设备全名 - `TX Power Leve`    10. TYPE = 0x0A：表示设备发送广播包的信号强度,DATA部分是一个字节，表示 -127 到 + 127 dBm。- `设备类别`    11. TYPE = 0x0D：设备类别- `设备配对的Hash值`    12. TYPE = 0x0E：设备配对的Hash值 - `设备配对的随机值`        13. TYPE = 0x0F：设备配对的随机值- `TK安全管理`    14. TYPE = 0x10：TK安全管理（Security Manager TK Value）- `带外安全管理`    15. TYPE = 0x11：带外安全管理（Security Manager Out of Band）,DATA 也是 Flag，每个 bit 表示一个功能：，各bit定义如下：    ```    bit 0: OOB Flag，0-表示没有OOB数据，1-表示有    bit 1: 支持LE    bit 2: 对Same Device Capable(Host)同时支持BLE和BR/EDR    bit 3: 地址类型，0-表示公开地址，1-表示随机地址    ```    - `外设（Slave）连接间隔范围`    16. TYPE = 0x12：外设（Slave）连接间隔范围，数据中定义了Slave最大和最小连接间隔，数据包含4个字节：前两字节定义最小连接间隔，取值范围：0x0006 ~ 0x0C80，而0xFFFF表示未定义；后两字节，定义最大连接间隔，取值范围同上，不过需要保证最大连接间隔大于或者等于最小连接间隔。- `服务搜寻` 外围设备可以要请中心设备提供相应的 Service。其数据定义和前面的 Service UUID 类似：    17. TYPE = 0x14：服务搜寻16 bit UUID列表    18. TYPE = 0x15：服务搜寻128 bit UUID列表    19. TYPE = 0x16：16 bit UUID Service，前两个字节是UUID，后面是Service的数据- `公开目标地址`     20. TYPE = 0x17：公开目标地址，表示希望这个广播包被指定的目标设备处理，此设备绑定了公开地址，DATA 是目标地址列表，每个地址 6 字节。- `随机目标地址`    21. TYPE = 0x18：随机目标地址，表示希望这个广播包被指定的目标设备处理，此设备绑定了随机地址，DATA 是目标地址列表，每个地址 6 字节。- `Appearance`    22. TYPE = 0x19：表示设备的外观 - `广播区间`    23. TYPE = 0x1A：广播区间- `LE设备地址`        24. TYPE = 0x1B：LE设备地址 - `LE设备角色`        25. TYPE = 0x1C：LE设备角色 - `256位设备配对的Hash值`        26. TYPE = 0x1D：256位设备配对的Hash值 - `256位设备配对的随机值`        27. TYPE = 0x1E：256位设备配对的随机值- `32bit UUID Service`            28. TYPE = 0x20：32 bit UUID Service，前4个字节是UUID，后面是Service的数据- `128bit UUID Service`        29. TYPE = 0x21：128 bit UUID Service，前16个字节是UUID，后面是Service的数据 - `3D信息数据`    30. TYPE = 0x3D：3D信息数据 - `厂商自定义数据`    31. TYPE = 0xFF：厂商自定义数据，厂商自定义的数据中，前两个字节表示厂商ID，剩下的是厂商自己按照需求添加，里面的数据内容自己定义。### 4.5 举例说明解析的思路搜索设备获取的数据包如下：</code></pre><p>02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35 09 03 E7 FE 12 FF 0F 18 0A 18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p><pre><code>根据解析规则，可分成如下部分：1.  广播数据 </code></pre><p>02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35</p><pre><code>2. 响应数据 </code></pre><p>09 03 E7 FE 12 FF 0F 18 0A 18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p><pre><code>3. 有效数据 </code></pre><p>02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35 09 03 E7 FE 12 FF 0F 18 0A 18</p><pre><code>4. 无效数据 </code></pre><p>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p><pre><code>其中的有效数据又可分为如下几个数据单元：</code></pre><p>02 01 06<br>14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23<br>06 08 48 45 54 2D 35<br>09 03 E7 FE 12 FF 0F 18 0A 18</p><pre><code>根据上面定义的AD Type分别解析如下：第一组数据告诉我们该设备属于LE普通发现模式，不支持BR/EDR；第二组数据告诉我们该数据为厂商自定义数据，一般是必须解析的，可根据协议规则进行解析获取对应的所需信息；第三组数据告诉我们该设备的简称为HET-5，其中对应的字符是查找[ASCII表](http://baike.baidu.com/link?url=_TISWJN8T3JSHi5A8OrhuBNyzLLAf006twuPA8wIWtdDG7UbyTfenCFaGWMxJCfXXmZp3SFMTHirjsKx0pTRua)得出；第四组数据告诉我们UUID为E7FE-12FF-0F18-0A18(此处有疑，类型03表示的是16位的UUID，对应的两个字节，而此处有8个字节，估计是设备烧录时把字节位数理解为了字符位数导致的问题).</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>4月以来的两月瘦了20斤</title>
      <link href="/2020/06/16/diary-20200616/"/>
      <url>/2020/06/16/diary-20200616/</url>
      
        <content type="html"><![CDATA[<h3 id="1-空"><a href="#1-空" class="headerlink" title="1.空"></a>1.空</h3><p align="center">不过是大梦一场空</p><p align="center">不过是孤影照惊鸿</p><p align="center">不过是白驹之过一场梦</p><p align="center">梦里有一些相逢</p><p align="center">有道是万物皆虚空</p><p align="center">有道是苦海最无穷</p><p align="center">有道是人生得意须尽欢</p><p align="center">难得最是心从容</p><p align="center">你每天都要求自己拒绝</p><p align="center">碌碌生活的平庸</p><p align="center">人潮挤散你的孤勇</p><p align="center">只留满夜星空</p><p align="center">让所有月色的朦胧</p><p align="center">都遮住现实里破碎的美梦</p><p align="center">而你的快乐正浓</p><p align="center">坠落在晚风</p><div align="center"><img width="500" height="350" src="https://gitee.com/seanzs/pic/raw/master/img/1138516029.jpg"></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>近期的工作学习计划</title>
      <link href="/2020/05/21/diary-20200521/"/>
      <url>/2020/05/21/diary-20200521/</url>
      
        <content type="html"><![CDATA[<h3 id="emsp-emsp-近期装修是最重要的事，买东西肉疼。另外近期的学习计划"><a href="#emsp-emsp-近期装修是最重要的事，买东西肉疼。另外近期的学习计划" class="headerlink" title="   近期装修是最重要的事，买东西肉疼。另外近期的学习计划:"></a>   近期装修是最重要的事，买东西肉疼。另外近期的学习计划:</h3><h4 id="1、web前端"><a href="#1、web前端" class="headerlink" title="1、web前端"></a>1、web前端</h4><h4 id="2、基于unity3d的图形学"><a href="#2、基于unity3d的图形学" class="headerlink" title="2、基于unity3d的图形学"></a>2、基于unity3d的图形学</h4><h4 id="3、UE4和UE5"><a href="#3、UE4和UE5" class="headerlink" title="3、UE4和UE5"></a>3、UE4和UE5</h4><h4 id="4、某服务器架构调试"><a href="#4、某服务器架构调试" class="headerlink" title="4、某服务器架构调试"></a>4、某服务器架构调试</h4><h4 id="5、MyBatis-半自动轻量级持久层框架"><a href="#5、MyBatis-半自动轻量级持久层框架" class="headerlink" title="5、MyBatis(半自动轻量级持久层框架)"></a>5、MyBatis(半自动轻量级持久层框架)</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>难搞哦</title>
      <link href="/2020/05/19/diary-20200519/"/>
      <url>/2020/05/19/diary-20200519/</url>
      
        <content type="html"><![CDATA[<p>   难搞哦</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一天</title>
      <link href="/2020/05/17/diary-20200517/"/>
      <url>/2020/05/17/diary-20200517/</url>
      
        <content type="html"><![CDATA[<p>  今天周日，第一次在这里从早上待到晚上，看着这夕阳，才下眉头，却上心头。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/646328966.jpg" width="80%" align="center"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>下班路上</title>
      <link href="/2020/05/11/diary-20200511/"/>
      <url>/2020/05/11/diary-20200511/</url>
      
        <content type="html"><![CDATA[<p>  下班路上<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/1775673119.jpg" width="80%" align="center"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>明天就要去公司上班了</title>
      <link href="/2020/05/10/diary-20200510/"/>
      <url>/2020/05/10/diary-20200510/</url>
      
        <content type="html"><![CDATA[<blockquote><p>人生路漫漫，很多事情都会不知不觉中忘记，但如果你把它记录下来了。等你老了翻开来看看，那是一笔无法用钱来衡量的财富。</p></blockquote><p>  明天结束居家办公去公司上班，今天上午把电脑搬去公司，顺便做个卫生，停车费有点贵呀；<br>  下午有空想去中国银行更新下身份证信息，结果银行今天没开门；<br>  因为泥工不在，装修今天也没有进场，说是要过两天；<br>  人都是站在自己角度看事物，疫情渐缓，样品柜子可能也不太想不挣钱的便宜处理。<br>  前两天风大，短袖出行回来今天晚上感觉有点受凉。喝了两包板蓝根。睡觉。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>江滩拍摄婚纱照</title>
      <link href="/2020/05/07/diary-20200507/"/>
      <url>/2020/05/07/diary-20200507/</url>
      
        <content type="html"><![CDATA[<p>  昨天来江汉路选婚纱照的服装，选了三套：主白纱、彩纱、室外纱。到时候现场拍摄现场再选古装和街拍服装。天气预报今天中雨，但拍摄时间仍预约今天，如果真一直下大雨就只拍室内的，室外的另订时间。</p><p>  今天天公作美，早上九点半到店里，给女士化妆，给我扑了点粉，准时开拍，因疫情原因，原定江夏的外景改成就近的江滩，各个方面也挺合适的，拍摄时一直配合摄影师的要求在摆姿势，“帅哥、美女，往老公这靠点，看着你老婆，太凶了，这是假笑，靠近点，走一步，挺胸，头歪了，闭眼了，好，别动，再来一次，笑的敷衍哦，笑太开了，高点，过来点，侧着点，行，不错，很好”。</p><p>  五套服装连贯拍完一直到了下午五点半左右，期间吃了点自己带的代餐面包和水。确实是体力活，有点累的。</p><p>  晚上微信视频里你葛优躺在床头调侃拍照除了费钱有什么作用，我说可能是为了发朋友圈，呵呵。</p><p>  照片将情感沉淀在今天定格的瞬间，翻阅照片就是品味往事，点点滴滴，从懵懂变清晰。生活也逐渐展开新的篇章。</p><blockquote><p>5月9号挑选精修及入册的照片，5月16号邮箱看效果，估计5月底能拿相册等东西</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/01/diary-0/"/>
      <url>/2020/05/01/diary-0/</url>
      
        <content type="html"><![CDATA[<p>  因疫情原因，从1月23号到4月6号的两个多月一直呆乡里，关注新闻、刷抖音、吃饭、锻炼、了解日落与星空，背单词，做卫生、烧火、买菜、挖蒲公英、犁地之类。。。</p><a id="more"></a><p>  复工一段时间后，5月1号发现过去买的域名今年3月份就过期了，过期时间过长无法续费，只能更高费用的赎回，那域名就不要算了。再加上旧服务器本来就慢。</p><p>  把旧服务器上花里胡哨的文件备份留存以后，就捣鼓了这个博客，重新开始。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
