<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基于vue的登陆页上下空白处自适应等高</title>
      <link href="/2020/08/04/diary-20200804-2/"/>
      <url>/2020/08/04/diary-20200804-2/</url>
      
        <content type="html"><![CDATA[<p>data中先定义</p><pre><code>    data() {        return {          windowHeight: "",           topHeight: ""        };    },</code></pre><p>mounted中：</p><pre><code>    mounted() {        this.windowHeight = window.innerHeight;  // 浏览器可见区域高度        this.topHeight = (this.windowHeight - 600) / 2 + "px"; // 浏览器可见区域高度 - 600为背景图高度 / 2 = 平均上下高度        window.onresize = () =&gt; {          return (() =&gt; {            this.windowHeight = window.innerHeight;            this.topHeight = (this.windowHeight - 600) / 2 + "px";          })();        };    }</code></pre><p>mouted为界面加载时执行的方法，那么，应该怎么监听到mouned中的 window.onresize呢？</p><pre><code>    // 使用vue的watch事件监听    watch: {         topHeight(val) {          this.topHeight = val;        }    },</code></pre><p>再在顶部元素中绑定style即可。</p><pre><code>    &lt;div :style="{height:topHeight}"&gt;        &lt;span&gt;xx管理平台&lt;/span&gt;    &lt;/div&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>婚礼流程细节安排参考</title>
      <link href="/2020/08/04/diary-20200804-1/"/>
      <url>/2020/08/04/diary-20200804-1/</url>
      
        <content type="html"><![CDATA[<p>史上最全结婚流程安排表 面对结婚这道“复杂”的工序，如果能有一张流程表，自上到下地列出什么时候该做什么，就不至于不知所措。小编为你罗列一个最详细的婚礼流程安排表。</p><p>这个流程表十分详细正式。各位在参考之时，可根据自己的实际情况，选择一些必要的步骤进行采纳哟 </p><ul><li><p>1.1.决定婚礼日期、地点、仪式及婚宴方式 </p></li><li><p>1.2.确定婚礼预算 </p></li><li><p>1.3.草拟客人名单 </p></li><li><p>1.4.召集好朋友讨论婚礼计划 </p></li><li><p>1.5.确定伴郎、伴娘 </p></li><li><p>1.6.确定主婚人、证婚人 </p></li><li><p>1.7.成立婚礼筹备组 制定婚礼项目计划书 明确筹备组分工  </p></li><li><p>2.1.与婚礼的所有项目干系人沟通 就婚礼筹备计划和进展与父母沟通 发喜贴给亲友 电话通知外地亲友 网上发布结婚通知 再次确认主、证婚人 及时反馈亲友受邀信息 对于重要亲友再次确认</p></li><li><p>2.2.结婚物品采购 新家布置用品 家电、家具 床上用品 彩色气球 彩灯（冷光） 纱 蜡烛 胶布 插线板 其他物品 婚礼用品订购 新郎新娘婚纱礼服 结婚戒指 新娘化妆品 喜贴、红包、喜字 彩带、拉花、喷物 烟、酒、饮料 糖、花生、瓜子、茶叶 录像带、胶卷 预定鲜花 预定蛋糕 水果 蜡烛 </p></li><li><p>2.3.新郎新娘形象准备 新娘开始皮肤保养 新郎剪头发 </p></li><li><p>2.4.拍婚纱照 挑选婚纱摄影 预约拍摄日期 拍照 选片 冲印或喷绘 </p></li><li><p>2.5.布置新房 请清洁公司彻底打扫新房 布置新房 </p></li><li><p>2.6.确定婚礼主持人 就婚礼当天计划与设想与之沟通 </p></li><li><p>2.7.婚宴预约 估计来宾人数 估计酒席数量 选择婚宴地点 确认酒席菜单、价格 确认婚宴现场的音响效果 与酒店协调婚宴布置等细节 预定酒席 </p></li><li><p>2.8.婚礼化妆预约 选择化妆地点 与发型师、化妆师沟通 确认婚礼当天的造型 预约化妆具体时间 </p></li><li><p>2.9.婚庆车辆预约 确定婚车数量 选定婚车司机 预约扎彩车时间地点 确定婚礼当天婚车行进路线及所需时间 预约婚车 </p></li><li><p>2.10.婚庆影像预约 确定摄影摄像数量 选定婚礼当天摄影摄像人员 安排摄影摄像分工 准备摄像器材 预约摄影摄像 </p></li><li><p>2.11.其他 调换崭新钞票 确定滚床儿童 为远道而来的亲友准备客房  </p></li><li><p>3.1.与婚礼的所有项目干系人沟通 就婚礼准备工作完成情况与父母沟通 就准备情况和婚礼当天分工与筹备组作最后沟通 根据准备情况就婚礼当天仪式进程与主持人作最后沟通 与伴郎伴娘再次沟通 最后确认帮忙的亲友 最后确认婚宴、车辆、影像、化妆等细节准备情况 </p></li><li><p>3.2.确认婚礼当天要发言人的准备情况 主证婚人发言准备情况 父母代表发言准备情况 来宾代表发言准备情况 抢亲时新娘提问准备 新郎新娘在仪式上或闹洞房可能会遇到的问题 </p></li><li><p>3.3.最后确认婚礼当天所有物品准备情况 最后试穿所有礼服 将婚礼当天要穿的所有服装分装口袋 准备两瓶假酒 准备婚礼当天新郎新娘的快餐干粮 最后检查所有物品并交于专人保管 新娘的新鞋 结婚证书 戒指 红包 要佩戴的首饰 新娘补妆盒 糖、烟、酒、茶、饮料 焰火道具 烛台、婚礼蜡烛 </p></li><li><p>3.4.新郎新娘特别准备 新郎新娘反复熟悉婚礼程序 预演背新娘动作 预演婚礼进行台步 预演交杯酒动作 放松心情，互相鼓励 注意睡眠，早点休息 </p></li><li><p>3.5.准备闹钟 一只正常工作的闹钟 将闹钟调到5点半  </p></li><li><p>4.1.化妆 5点30起床 7点新郎发型做好后到达女方娘家附近等待 7点45新娘妆完成，通知新郎 化妆师红包</p></li><li><p>4.2.婚车 6点30开始扎彩车 7点专车送新郎至女方娘家附近 7点30彩车完成 7点45专车送新娘回娘家（8：30前到达） 9点所有婚车到达女方娘家 司机红包 </p></li><li><p>4.3.抢新娘 8点伴郎准备好鲜花、红包 8点30新娘回到娘家，藏好新鞋 8点40新郎带领兄弟们开始抢人 8点45敲门、盘问、塞红包、挤门 8点55新郎找新鞋，向女方家人承诺 9点彩带师到位气球到位<br>9点5分新郎背新娘出门，彩带，踩气球 9点10车队出发 </p></li><li><p>4.4.迎新娘 10点车队到达男方家 </p></li><li><p>4.4.10点5新郎抱新娘进门，彩带，踩气球 10点10小孩子滚床 10点15伴娘准备好茶 10点20新娘给男方父母敬茶 10点40新郎新娘出发至酒店 </p></li><li><p>4.5.酒店准备 将糖、烟、酒、茶、饮料等带至酒店 10点10最后检查酒席安排、音响、签到处等细节 10点30准备好新郎新娘迎宾香烟火柴糖 10点45彩带师到位酒店门口</p></li><li><p>4.6.酒店迎宾 10点50新郎新娘到酒店，彩带 11点签到处人员就位 11点引导人员门口就位 11点新郎新娘门口迎宾 </p></li><li><p>4.7.婚礼仪式 12点15主持人准备 12点15音响准备 12点15结婚证书、戒指准备 12点15气球、彩带到位.12点20奏乐，新人入场，彩带、踩气球，主持人介绍，主婚人致词，证婚人宣读结婚证书，新人父母上台，新郎新娘交换戒指，三鞠躬，新人给父母敬茶，双方父母代表讲话，双方父母退场，开香槟，切蛋糕，喝交杯酒，游戏 13点婚宴正式开始 13点新郎新娘退场、速食，新娘换礼服 13点15新郎新娘逐桌敬酒 14点宴席结束，宾客与新人合影 </p></li><li><p>4.8.下午休息 14点宾客离开 14点30新郎新娘进餐、休息 14点30清点所剩烟酒糖等 14点30统计晚餐人数 </p></li><li><p>4.9.晚餐  17点通知酒店晚餐准备数量 18点请宾客进晚餐 20点清点所有物品，离开酒店 </p></li><li><p>4.10.闹洞房 21点开始闹洞房，女方藏结婚证，新郎找结婚证，其它节目自由发挥 22点30宾客离开</p></li><li><p>4.11.摄像摄影 摄像a从新娘化妆开始全程拍摄新娘 摄像b从新郎抢亲开始全程拍摄新郎 摄像c拍摄婚礼仪式全过程 摄影适时拍摄 摄影摄像人员红包  </p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="data:image/png;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/2wBDAAMCAgMCAgMDAwMEAwMEBQgFBQQEBQoHBwYIDAoMDAsKCwsNDhIQDQ4RDgsLEBYQERMUFRUVDA8XGBYUGBIUFRT/2wBDAQMEBAUEBQkFBQkUDQsNFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBT/wAARCABWAFgDASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9oADAMBAAIRAxEAPwD9Us4rj/iL8S/Dfwp8LXXiLxRq1voujWm1ZLidz/F91UVeWY9gOa62WZYkLN90DJPYCvlbw9pkH7RX7QUXjW/cX3w98MwS2XhuxuFJivb0n9/fiPoQoBjQnnuBTSb2A6LT/wBqHX/Gckc3gD4NeMvE2jld/wDa2oiLRYpV9YlunV5R74rUi+I3xtkb7Y/wh0xLHp/Z7+KIjf7fwj8jP/bSvbIolhULGoAA+6AB+AxwBVnYvpUgfP0/7WMPhS/ksviF8PfGfghtu6C4/syTV7ef2Elisyg/7+K2vC/7X3wb8YapBpemfELQzqk52JYXU5tZy/8Ad2SqrbvbGa9hMWY9oXb/ALPQD6cGuA8f/BHwJ8StOu7DxF4T0fUIrgDzJJLVFlDHgMsq4cGmB6Clwkqgh1IIBBB4welS5r4K+JHxH1T9kDxFbR6B8UB408K6T5J1jwXrz+ffWFkQq+dFdLyCqZKxtyx6Zr7l0/UoNUsbW8t33QXEYeMspGQRkH8uaALryYHFQSTqOrYonYoM4NYlzeHJHetIxTOCrX9nozYe7T1ornHu5D60VfIcDxljxb9s39oSf4O+CNR0jwzDHqPjTUtNvLiFJm2w2NrHGxlupT/dQAKq/wATMAOTWZ+y5pUvhb4BeAbWS5NxJFpdvM0g6MzgM5Le+6vz+/bH+M1x40sfEOsQs8c/jQrdpuyGi0O3kK2kXssxVpnA5IK9jX1t+zf4q1vTf2RfhnqmlWVzdzQi2huoljaa5a1E2yQxgA/wkEE9hV4dXlZn0lPc+7rOZbi3jlGPnWrVcP4S8RxQRx2kn+qP3JQ2R+ddturCcHCTRm1qKGBAIIINfG/7dn7ZEfwK0Wfwr4VvoX+IN9bl1BG5tOgkyBMffOSueuOK+pvGPiK08KeHb/V72Vbe2s4TcSyyDIVQMn8gDX4IfFv4m3Hx5/aA8X69b3RltdWvALKeZTuii/1MfHYBVZseppKN1ckueBvHmv6X4uu9RfxEov74yyahNrUv2hdRVvmkjmSXcsgZSAentX3r+xz+29YXUdp4d15xb6ECsEMrys7aQ5fCxux62pJIWQ/NGwWN9wCufzG1nR9Nmg1G5UXOpWenX89k9yc7BBG2yOcgcgncua3fhd4b1mx8U6daQ3IsNSOk3l3aISfLuP8ARzMYX/2Xi3KR1wBjmgOXU/oj3rMmdwwBnOe3r+lYGoWuyVjmvB/2FvjRffET4c3vhbxCk9r4y8G3A0y/t7o7pWhZd1vNnuGjx83QlR619CaqoD1UHc83GU+aFzG649+nvRUOp3sWlWkt1MsjxxDLeVC0shHsq80V1R2PnHofir8f9NstU8d+NLSG7hg07w4kegWVrIdrOlvGlqm1e+drOcetfZ//AATJ8Rvq/wCzhHpkt1JPdaLqtxZyRyLxEMI6KD3HzV8N/tAxCL45eNzE4e2vdSk1a1KnIe1uSJoyD34kUZFT+Avip8SvgnozWnhPWrzRrLWZftaxCGKUXMmETgyK395fyrKnPld7H2sZKD1P1rt73SfB+t2eiw2Q0+HUzLJbSjAie4z5kicE4f5t4/3SO1ey6Nrn2/SSgk8u8RNpJGcn1r4iudU+MPjPT7jwm+kaH4r1nRtNtpdT1PS7h9Ml0vVjEs8ccUjsyXD7Wjd1Cqo34PWvXPh78TpvGHw7utR1a3ufCviDSF+z63YoMS6bdIu5tuPvKD+8X+9HwM1p7Snifdg9UdU1zRTNz49WWo+KvhR400c3ciXU+j3UatuwFJi4P6H86/F2x+CPi/T/AAt8PNdm0O5aw8V309tp11pM3m3k4idUMflHgFfLcrjbu3Zr9odM8UL4t8O6wpdI9XsUmtb+NPuxzGPJxnqshIkz2BxXFfCrRvAVz4L+C2matPaWHiTR9P8A7V0axacZaQq0UroT99huyVGcGuLHVVRjHlW5Xs1KyPk/4I/CDwd8Xfjd+0H4as4J9M0jV9CS206y1G2a1ubZ3EeC0TgNmKWMEkDpuNfOHw30LV7n4wJGUMUHhG0jGpxupyq7UspgT2w1wmc9ARmv1x+I37Ofw6+JfjS21vxDphPiaKJEhntryS3n8obtvCMNyfO2QeeBXE/Bf9lXw/ceDvig0zG/u/FOoajYpfXwDTQ2+5YdjMvysfMtlfIXrXFhqjqOVyK0eVaHpfwa+GdtZWPgnxwFktNfk8M2+l6i6Llb6FVVkDgdTGwZlPUiRx6V6nqs++Rtp3ZyOPUdalsbEaPo1lYxjCWsEcCBegCrt/lWJf6Rb3V6t1PEZZUQxKWcgbG6qQO/vXqU42sfO4yq7WRieLLojUPDMYlwG1PLhTw6+S7bW9skflRXPeIfAWhReIfC1smnxrHLczM5MrkjbE3Tn3orpPEep+Vf7V3wa1v4XeOH0e7t3ZvDNsltbXBBLX2hhitvP/tGDeI3I6BATivGJL+7ZbYLcPvsmR7cNysDbi2B6jIX8q/c79ov9nDQP2h/CY07UmbT9YtGeXTdatQBPaORtI/2kZflZT1XpzX47fHH4DeKPgT4zk8PeINLNu4V5LS4hBa2vIR0lgOOM/xRnlO+K4U+nc+yaufdf7PX7dHwm1O1upPE91F8P/FuqtBNqzagxSzvbhIo4lmSUfKPkRAQ5HSui+IHjbwzd+NtS8a+B9Xs/GWiC0TRvG9noDC8eG3cbYbxdpIkaIMxYDnaSTwtfl98JPDtx8UPGd1Y6fIBHpcA1JEZQTcPEUXyVB+8XJAAHJJ4r9mL/wAY6z4e0XVdTsPhu9npVrBLdT7720tZ2RE3b2hU8ELx8zbvavJqJYaopwep6FN80bM8z+D/AIc1W2+GCfE1PEp1mWfR4UubK3sE8q4htWkRGzncZgmQWx82yu28H/BTw38Q/gd4P0fxt4biumtrJXi86SRbuzJO5SkyP5iPjkhGUZrp/gNpc1r8H/CdvdKpS50y3lZWAzmaMuy8cYHmmq/wNvru+8Fx6fPMoufD+o3uhXKtklxbzMsTZ9TF5Wfc1z1a9StB3ezNoR5XZh8N/wBnrwJ8JtXn1bw7pVwuqzxeS9/qOoXF9OU9A8zthfbGa3vgnqaWWr+OfCztm40vVnukGf8Alhdfv0I+jGb/AL5rqc+v1rmvhjohfxt4w8XBGSHVja2cAI+9FApXzPcFpGOf7qA96vATcpyJxSjGKPTbwlVYJgSH+90rhJZvExLCSDS87ugml/wrq769Uvxk1yGvePNI0O/NndS3IuQuSkNpNMoP1UV9HBM+KxVSMtEcr4huvECeMfCKSxaaXMl0yYL4z5Xf8xRUd74003WPiP4WS1F6/lwXRCtZTRnO1FzyvpRWx5h75sFeafGz4TeG/jD4Ev8ARfFCYtVRpo72NtstpKoysyOfulQMkHgivSfMwcd/SvFf2uPEkvh74D67DYTG31HWpINEs3U4bzbmVIQV9TtLHjsDXnPRXPtvI+Wv2K/2RdD8PPb/ABOmtY/P1C8lfTIgCP8AQY4jDFK2eN0zq1xj/bX0r6/8Z+GU8SeEdf0cMI21bTrix84Z+Uyxsu7PoMjmrXh/RIPDeg6dotpGIrfTbeO2jjXoAq7f5Vm3+p65olzNJ/Zo1mxc7kWyZIp4x6MhO1vwr5irUlOo29j2oRUIoveDtHl0PwroelTkedaWMNs5XplI1XI/Kvnz4VfFO/0jxv8AFyx0jwb4k8VwzeN7t7e40u3j+yxbbe3jlDySOigiRWJ2k4zXpXij4heOr61urHwV4A1KLWHjYxX+vvFa2sD/AN/Cl3k+gFaP7IOgafoX7P8A4Zkspmubi+E2oajcycvNfySN9qY+4kDrj/ZAr0cLh1KL9p1OKvWs1boavh3w5428V6gt34lhtvDejICw0e2uRdXF03/TeYKoVf8Apmmfd2r0ecQ20PlwKEjjXasaDAFXnnAQEDIryj4kfCfTPiTd28+o6n4k06S3RkjGh63c2K7fUpG6qTXsUaKpv3UeJjK8nGzZ2Tnc3O4UBZMkKrKr+gJP5kV5loXwB0bSJNieIvGlwn/PC48V3zJ+XmZrP8Qfsl+CPEV0bu4vPF8Ej/6w2vi/UkEn+8PN/lXZqjwIxU3dvQ63Wct8UfDSuCX+w3h5JHP7r0HsfyNFeWyfsN/DA3RnuW8U3kcaGIW9z4q1AxJn72MTbuaKXM+w3Gkn8X4H0hc6df3F99tt9Wkt7Pytv2TyVIzzzn8R+Vcf4m+CyeKTAdU8R6reCGVJokcx7UlVtwcDZ1HaiiuRbn1M0mtRT8OddsNqWHjG8+zt9xb6BJyn4nrTJ/C3jmAhE1vSHB7vaSZ/9CoorF0qbldol1ZxVovQcfh34rkiD3njEWyp/Bp9gi/qTWZ4d+BU3haAW+leMNYsLRZHdLeErsXe5dsfVix/GiitIRUF7pjPV6m1F8I1mkP2nxNr95dD/lsb9oh+SipLn4WXUS5i8Ya3H/vvHJ/NaKK0UmglShLdEJ+G3iMPtXx1fCD+79mj3fnVWD4YeLtMnlW18c3MsMva+iExX6Zooq+Zk+yglZI6DQ/CGuQJN/aGuR3m5NsPlWoh8s+px1ooopcz7kfV6T1cT//Z" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>低功耗蓝牙BLE的GATT协议和广播消息解析</title>
      <link href="/2020/07/30/diary-20200730-1/"/>
      <url>/2020/07/30/diary-20200730-1/</url>
      
        <content type="html"><![CDATA[<p>蓝牙作为短距离无线通讯技术，可实现设备与设备之间的数据交换。一般将蓝牙3.0之前的BR/EDR称为传统蓝牙，将蓝牙4.0规范的BLE蓝牙称为低功耗蓝牙。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/bluetoothtype.jpg" alt="蓝牙分类"></p><ul><li>现在蓝牙实际上分为三类：单模、双模和经典。</li><li>单模蓝牙(ble低功耗蓝牙)使用GATT传输协议进行数据传输，传统蓝牙通过Socket进行数据传输。因此Android用传统蓝牙链接方式无法和低功耗蓝牙ble建立通信通道。通信协议不同。</li><li>经典蓝牙发现其它经典蓝牙设备的方式是调用BluetoothAdapter的startDiscovery()方法。蓝牙最初的设计意图，是打电话放音乐。3.0版本以下的蓝牙，都称为“经典蓝牙”。功耗高、传输数据量大、传输距离只有10米。</li><li>低功耗蓝牙ble引入主设备Central和从设备Peripheral的概念。主设备调用发现设备的方法，通过BluetoothAdapter的startLeScan()方法实现。从设备作为被发现方，发出广播以供发现。这个startLeScan()方法仅能发现ble设备。低功耗，数据量小，距离50米左右。</li><li>Android4.3(API18)版本以下对应传统蓝牙，Android4.3引入BLE核心功能并提供相应api，应用程序通过这些API扫描蓝牙设备、查询服务services、读写设备属性特征characteristics。Android4.3及以上版本才支持低功耗ble的开发，而且Android4.3版本至5.0版本的调用方法和Android5.0以上版本的调用方法还不一样。Android6.0以上必须运行时申请模糊定位的权限开启才能扫描ble广播。</li></ul><h2 id="一、中央BluetoothGatt和周边BluetoothGattServer的实现"><a href="#一、中央BluetoothGatt和周边BluetoothGattServer的实现" class="headerlink" title="一、中央BluetoothGatt和周边BluetoothGattServer的实现"></a>一、中央BluetoothGatt和周边BluetoothGattServer的实现</h2><p>Android4.3规范了BLE的API，但是直到目前的Android4.4，还有些功能不完善。直到目前最新的Android4.4.2，Android手机只能作为中央来使用和处理数据；那数据从哪儿来？从BLE设备来，现在的很多可穿戴设备都是用BLE来提供数据的。一个中央可以同时连接多个周边，但是一个周边某一时刻只能连接一个中央。<br>Android BLE SDK的四个关键类(class):</p><ul><li>BluetoothGattServer作为周边来提供数据。代表周边。</li><li>BluetoothGattServerCallback返回周边的状态。</li><li>BluetoothGatt作为中央来使用和处理数据。代表中央。</li><li>BluetoothGattCallback返回中央的状态和周边提供的数据。</li></ul><h3 id="1-1-创建周边"><a href="#1-1-创建周边" class="headerlink" title="1.1 创建周边"></a>1.1 创建周边</h3><p>虽然周边API是在设备内工作，并不在Android手机上工作，但还是可以看看。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/zhoubianble.jpg" alt="周边"><br>每一个周边BluetoothGattServer，包含多个服务Service，每一个Service包含多个特征Characteristic。<br>new一个特征</p><pre><code>character = new BluetoothGattCharacteristic(UUID.fromString(characteristicUUID),BluetoothGattCharacteristic.PROPERTY_NOTIFY,BluetoothGattCharacteristic.PERMISSION_READ);</code></pre><p>new一个服务</p><pre><code>service = new BluetoothGattService(UUID.fromString(serviceUUID),BluetoothGattService.SERVICE_TYPE_PRIMARY);</code></pre><p>把特征添加到服务</p><pre><code>service.addCharacteristic(character);</code></pre><p>获取BluetoothManager</p><pre><code>manager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);</code></pre><p>获取/打开周边</p><pre><code>BluetoothGattServer server = manager.openGattServer(this,new BluetoothGattServerCallback(){...}); </code></pre><p>把service添加到周边</p><pre><code>server.addService(service);</code></pre><p>开始广播</p><pre><code>//Google还没有广播Service的API，等吧！！！！！//所以目前我们还不能让一个Android手机作为周边来提供数据。</code></pre><h3 id="1-2-创建中央"><a href="#1-2-创建中央" class="headerlink" title="1.2 创建中央"></a>1.2 创建中央</h3><p>在Android手机里运行，成功创建后可以连接到周边<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/centerble.jpg" alt="Center"></p><p>首先拿到BluetoothManager</p><pre><code>bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);</code></pre><p>再拿到BluetoothAdapt</p><pre><code>btAdapter = bluetoothManager.getAdapter();</code></pre><p>开始扫描</p><pre><code>btAdapter.startLeScan( BluetoothAdapter.LeScanCallback);</code></pre><p>从LeScanCallback中得到BluetoothDevice</p><pre><code>public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {.....}</code></pre><p>用BluetoothDevice得到BluetoothGatt</p><pre><code>gatt = device.connectGatt(this, true, gattCallback);</code></pre><p>终于拿到中央BluetoothGatt，通过调用BluetoothGatt的一堆方法api,通过BluetoothGattCallback和周边BluetoothGattServer交互进行通信。</p><h2 id="二、BLE数据发送"><a href="#二、BLE数据发送" class="headerlink" title="二、BLE数据发送"></a>二、BLE数据发送</h2><p>BluetoothGattCallback回调函数先准备好。</p><pre><code>    private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {    @Override    public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {//连接状态改变        Log.e("BluetoothGatt中中中", "连接状态:" + newState);        /**         * 连接状态：         *    * The profile is in disconnected state   *public static final int STATE_DISCONNECTED  = 0;         *    * The profile is in connecting state     *public static final int STATE_CONNECTING    = 1;         *    * The profile is in connected state      *public static final int STATE_CONNECTED    = 2;         *    * The profile is in disconnecting state  *public static final int STATE_DISCONNECTING = 3;         *         */        if (BluetoothGatt.STATE_CONNECTED == newState) {            Log.e("onConnec中中中", "连接成功:");            gatt.discoverServices();//必须有，可以让onServicesDiscovered显示所有Services            Toast.makeText(mContext, "连接成功", Toast.LENGTH_SHORT).show();        }else if (BluetoothGatt.STATE_DISCONNECTED == newState){            Log.e("断开 中中中", "断开连接:");            Toast.makeText(mContext, "断开连接", Toast.LENGTH_SHORT).show();        }    }    @Override    public void onServicesDiscovered(BluetoothGatt gatt, int status) {//发现服务，在蓝牙连接的时候会调用        List&lt;BluetoothGattService&gt; list = mBluetoothGatt.getServices();        for (BluetoothGattService bluetoothGattService:list){            String str = bluetoothGattService.getUuid().toString();            Log.e("onServicesDisc中中中", " ：" + str);            List&lt;BluetoothGattCharacteristic&gt; gattCharacteristics = bluetoothGattService.getCharacteristics();            for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) {                Log.e("onServicesDisc中中中", " ：" + gattCharacteristic.getUuid());                if("0000ffe1-0000-1000-8000-00805f9b34fb".equals(gattCharacteristic.getUuid().toString())){                    linkLossService=bluetoothGattService;                    alertLevel=gattCharacteristic;                    Log.e("daole",alertLevel.getUuid().toString());                }            }        }        enableNotification(true,gatt,alertLevel);//必须要有，否则接收不到数据    }    @Override    public void onCharacteristicRead(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status) {        Log.e("onCharacteristicRead中", "数据接收了哦"+bytesToHexString(characteristic.getValue()));    }    /**     *  发送数据后的回调     * @param gatt     * @param characteristic     * @param status     */    @Override    public void onCharacteristicWrite(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status) {//发送数据时调用        Log.e("onCharacteristicWrite中", "数据发送了哦");        Log.e("onCharacteristicWrite中", bytesToHexString(characteristic.getValue()));        if(status == BluetoothGatt.GATT_SUCCESS){//写入成功            Log.e("onCharacteristicWrite中", "写入成功");        }else if (status == BluetoothGatt.GATT_FAILURE){            Log.e("onCharacteristicWrite中", "写入失败");        }else if (status == BluetoothGatt.GATT_WRITE_NOT_PERMITTED){            Log.e("onCharacteristicWrite中", "没权限");        }    }    @Override    public void onDescriptorRead(BluetoothGatt gatt,BluetoothGattDescriptor descriptor, int status) {//descriptor读        //Log.e("onCDescripticRead中", "数据接收了哦"+bytesToHexString(characteristic.getValue()));    }    @Override    public void onCharacteristicChanged(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic) {// Characteristic 改变，数据接收会调用        Log.e("CharacteristicChanged中", "数据接收了哦"+bytesToHexString(characteristic.getValue()));        tx_receive.append(bytesToHexString(characteristic.getValue()) + "\n");    }    @Override    public void onDescriptorWrite(BluetoothGatt gatt,BluetoothGattDescriptor descriptor, int status) {//descriptor写    }    @Override    public void onReliableWriteCompleted(BluetoothGatt gatt, int status) {    }    @Override    public void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) { //读Rssi    }    @Override    public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) {    }};</code></pre><p>先要定义mBluetoothGatt ，然后在连接ble的时候写上上面这个回调函数。这样会把蓝牙的相关信息传到回调函数，才能进行接下来的数据发送与接收。<br>通过BluetoothDevice连接ble，得到mBluetoothGatt，如下</p><pre><code>    /**     * 蓝牙连接     * @param device     */    public void connect(BluetoothDevice device) {        Log.e("connect中中中","开始连接:");        mBluetoothGatt = device.connectGatt(mContext, false, mGattCallback);    }</code></pre><ul><li>BluetoothGattCallback回调中的onConnectionStateChange是判断蓝牙ble连接是否成功。</li><li>BluetoothGattCallback回调中的onServicesDiscovered先遍历ble设备的所有服务，然后遍历所有服务的所有特征。目的就是为了找到特定的服务和特征<pre><code>linkLossService=bluetoothGattService; alertLevel=gattCharacteristic;</code></pre>这两句，把需要的服务中的Characteristic找到，为什么呢，因为发送数据需要，如果你不知道你的设备中可读写的Characteristic的uuid你需要先知道目标特征的uuid是多少。<br>既然已经找到需要的特征Characteristic，那么就可以用于发送数据了。<pre><code>  /**   * 向蓝牙发送数据   */  public void dataSend(){      //byte[] send={(byte) 0xaa,0x01,0x01,(byte)0x81,(byte) 0xff};      byte[] send = new byte[20];      send = hexStringToBytes(et_send.getText().toString());      byte[] sendData=new byte[send.length+2];      sendData[0]=(byte) 0xaa;      sendData[sendData.length-1]=(byte) 0xff;      for(int i=1;i&lt;sendData.length-1;i++){          sendData[i]=send[i-1];      }      Log.e("dataSend", bytesToHexString(sendData));      Log.e("dataSend", linkLossService +"");      alertLevel.setValue(sendData);      boolean status = mBluetoothGatt.writeCharacteristic(alertLevel);      Log.e("dataSend", status+"");  }</code></pre></li></ul><p>硬件设备接收的都是byte类型的数据，所以我们发送的也就是byte，我这里是从editview中获取数据，然后加工成byte类型。这里我在每条指令前加了0xaa，末尾加了0xff，因为底层硬件要求的数据帧为这种格式，具体发送的时候要按照具体情况来。 </p><h2 id="三、BLE数据接收"><a href="#三、BLE数据接收" class="headerlink" title="三、BLE数据接收"></a>三、BLE数据接收</h2><p>想要接收到数据必须先要使能通知。</p><pre><code>        @Override        public void onServicesDiscovered(BluetoothGatt gatt, int status) {//发现服务，在蓝牙连接的时候会调用            List&lt;BluetoothGattService&gt; list = mBluetoothGatt.getServices();            for (BluetoothGattService bluetoothGattService:list){                String str = bluetoothGattService.getUuid().toString();                Log.e("onServicesDisc中中中", " ：" + str);                List&lt;BluetoothGattCharacteristic&gt; gattCharacteristics = bluetoothGattService.getCharacteristics();                for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) {                    Log.e("onServicesDisc中中中", " ：" + gattCharacteristic.getUuid());                    if("0000ffe1-0000-1000-8000-00805f9b34fb".equals(gattCharacteristic.getUuid().toString())){                        linkLossService=bluetoothGattService;                        alertLevel=gattCharacteristic;                        Log.e("daole",alertLevel.getUuid().toString());                    }                }            }            enableNotification(true,gatt,alertLevel);//必须要有，否则接收不到数据            //Log.e("onServicesDisc中中中", " ：" + mBluetoothGatt.getServices().toString());        }</code></pre><p>就是enableNotification(true,gatt,alertLevel);这句话，这个必须要有不然接收数据的那个回调函数会毫无反应。</p><pre><code>    private void enableNotification(boolean enable, BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {        if (gatt == null || characteristic == null)            return; //这一步必须要有 否则收不到通知         gatt.setCharacteristicNotification(characteristic, enable);    }</code></pre><p>这些都做完了以后，在发送了指令后，如果有数据返回，就会接收到数据</p><pre><code>    @Override    public void onCharacteristicChanged(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic) {// Characteristic 改变，数据接收会调用        Log.e("CharacteristicChanged中", "数据接收了哦"+bytesToHexString(characteristic.getValue()));        tx_receive.append(bytesToHexString(characteristic.getValue()) + "\n");    }</code></pre><p>下面是写入状态的回调函数，写入成功后就会显示写入成功与否</p><pre><code>    @Override    public void onCharacteristicWrite(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status) {//发送数据时调用        Log.e("onCharacteristicWrite中", "数据发送了哦");        Log.e("onCharacteristicWrite中", bytesToHexString(characteristic.getValue()));        if(status == BluetoothGatt.GATT_SUCCESS){//写入成功            Log.e("onCharacteristicWrite中", "写入成功");            tx_display.append("写入成功");        }else if (status == BluetoothGatt.GATT_FAILURE){            Log.e("onCharacteristicWrite中", "写入失败");        }else if (status == BluetoothGatt.GATT_WRITE_NOT_PERMITTED){            Log.e("onCharacteristicWrite中", "没权限");        }    }</code></pre><h2 id="四、BLE总结"><a href="#四、BLE总结" class="headerlink" title="四、BLE总结"></a>四、BLE总结</h2><p>(打开蓝牙-&gt;搜索设备-&gt;发现设备-&gt;建立连接-&gt;数据通信)</p><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/blekaifaliucheng2.jpg" alt="ble蓝牙开发流程"></p><h3 id="4-1-Android-BLE-API简介"><a href="#4-1-Android-BLE-API简介" class="headerlink" title="4.1 Android BLE API简介"></a>4.1 Android BLE API简介</h3><pre><code>+ GATT描述了一个框架，该框架定义了服务(Server)和服务属性(characteristic)的过程(Procedure)及格式Procedure定义了characteristic的发现、读、写、通知(Notifing)、指示(Indicating)及配置characteristic的广播。GATT中最上层是Profile，Profile由一个或多个服务(Service)组成服务是由Characteristics组成，或是其他服务的引用(Reference)Characteristic包含一个值(Value)，可能包含该Value的相关信息。+ Server一个低功耗蓝牙设备可以定义许多 Service, Service可以理解为一个功能的集合。设备中每一个不同的Service都有一个128bit的UUID作为这个Service的独立标志。蓝牙核心规范制定了两种不同的UUID，一种是基本的UUID，一种是代替基本UUID的16位UUID。所有的蓝牙技术联盟定义UUID共用了一个基本的UUID：0x0000xxxx-0000-1000-8000-00805F9B34FB，为了进一步简化基本UUID，每一个蓝牙技术联盟定义的属性有一个唯一的16位UUID，以代替上面的基本UUID的‘x’部分。例如，心率测量特性使用0X2A37作为它的16位UUID，因此它完整的128位UUID为：0x00002A37-0000-1000-8000-00805F9B34FB+ Characteristic在Service下面，又包括了许多的独立数据项，我们把这些独立的数据项称作Characteristic。同样的，每一个Characteristic也有一个唯一的UUID作为标识符。在Android开发中，建立蓝牙连接后，我们说的通过蓝牙发送数据给外围设备就是往这些Characteristic中的Value字段写入数据；外围设备发送数据给手机就是监听这些Charateristic中的Value字段有没有变化，如果发生了变化，手机的BLE API就会收到一个监听的回调。</code></pre><h4 id="4-1-1-BluetoothAdapter"><a href="#4-1-1-BluetoothAdapter" class="headerlink" title="4.1.1 BluetoothAdapter"></a>4.1.1 BluetoothAdapter</h4><p>拥有基本的蓝牙操作，例如开启蓝牙扫描，使用已知的MAC地址（BluetoothAdapter getRemoteDevice）实例化一个 BluetoothDevice用于连接蓝牙设备的操作等</p><h4 id="4-1-2-BluetoothDevice"><a href="#4-1-2-BluetoothDevice" class="headerlink" title="4.1.2 BluetoothDevice"></a>4.1.2 BluetoothDevice</h4><p>代表一个远程蓝牙设备。这个类可以让你连接所代表的蓝牙设备或者获取一些有关它的信息，例如它的名字，地址和绑定状态等等。</p><h4 id="4-1-3-BluetoothGatt"><a href="#4-1-3-BluetoothGatt" class="headerlink" title="4.1.3 BluetoothGatt"></a>4.1.3 BluetoothGatt</h4><p>提供了Bluetooth GATT的基本功能。例如重新连接蓝牙设备，发现蓝牙设备的 Service 等</p><h4 id="4-1-4-BluetoothGattService"><a href="#4-1-4-BluetoothGattService" class="headerlink" title="4.1.4 BluetoothGattService"></a>4.1.4 BluetoothGattService</h4><p>通过BluetoothGatt.getService获得，如果当前服务不可见那么将返回一个null。这一个类对应上面说过的Service。我们可以通过这个类的getCharacteristic(UUID uuid) 进一步获取 Characteristic 实现蓝牙数据的双向传输。</p><h4 id="4-1-5-BluetoothGattCharacteristic"><a href="#4-1-5-BluetoothGattCharacteristic" class="headerlink" title="4.1.5 BluetoothGattCharacteristic"></a>4.1.5 BluetoothGattCharacteristic</h4><p>对应上面提到的 Characteristic。通过这个类定义需要往外围设备写入的数据和读取外围设备发送过来的数据。</p><h2 id="五、蓝牙与BLE通讯"><a href="#五、蓝牙与BLE通讯" class="headerlink" title="五、蓝牙与BLE通讯"></a>五、蓝牙与BLE通讯</h2><h3 id="5-0思路步骤-梳理整体逻辑"><a href="#5-0思路步骤-梳理整体逻辑" class="headerlink" title="5.0思路步骤(梳理整体逻辑)"></a>5.0思路步骤(梳理整体逻辑)</h3><ul><li>权限问题<br>先判断手机是否满足android4.3以上版本，再判断手机是否开启蓝牙。Android6.0以上申请运行时定位权限。</li><li>搜索蓝牙<br>搜索蓝牙，回调接口中查看ble设备相关信息，一定时间停止扫描。</li><li>连接蓝牙<br>首先获取到ble设备的mac地址，然后调用connect()方法进行连接。</li><li>获取特征<br>蓝牙连接成功后，需要获取蓝牙的服务及特征等，然后开启接收设置。</li><li>发送消息<br>writeCharacteristic()方法，发送数据给ble设备。</li><li>接收消息<br>通过蓝牙的回调接口中onCharacteristicRead()方法，接收蓝牙收的消息。</li><li>释放资源<br>断开连接，关闭资源。</li></ul><h3 id="5-1声明权限"><a href="#5-1声明权限" class="headerlink" title="5.1声明权限"></a>5.1声明权限</h3><p>AndroidManifest.xml中声明权限</p><pre><code>&lt;!-- 蓝牙所需权限 --&gt;    &lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;    &lt;uses-feature        android:name="android.hardware.bluetooth_le"        android:required="true" /&gt;    &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/&gt;    &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/&gt;</code></pre><p>android.permission.BLUETOOTH允许程序连接到已配对的蓝牙设备。<br>android.permission.BLUETOOTH_ADMIN允许程序发现和配对蓝牙设备。<br>因为只有在API18(Android4.3)以上的手机才支持ble开发，所以还要声明一个feature。当required为true时，应用只能在支持BLE的Android设备上安装运行，required为false时，Android设备均可正常安装运行，需要在代码运行时判断设备是否支持BLE。<br>需要定位权限，不然扫描不到ble设备。</p><h3 id="5-2获取蓝牙适配器"><a href="#5-2获取蓝牙适配器" class="headerlink" title="5.2获取蓝牙适配器"></a>5.2获取蓝牙适配器</h3><pre><code>  BluetoothManager  mBluetoothManager =(BluetoothManager)context.getSystemService(Context.BLUETOOTH_SERVICE);  BluetoothAdapter  mBluetoothAdapter = mBluetoothManager.getAdapter();</code></pre><h3 id="5-3判断手机蓝牙是否打开"><a href="#5-3判断手机蓝牙是否打开" class="headerlink" title="5.3判断手机蓝牙是否打开"></a>5.3判断手机蓝牙是否打开</h3><pre><code>mBluetoothAdapter.isEnabled()</code></pre><p>如果返回true，开始扫描。如果返回false,调用系统方法让用户打开蓝牙。</p><h3 id="5-4开始扫描"><a href="#5-4开始扫描" class="headerlink" title="5.4开始扫描"></a>5.4开始扫描</h3><pre><code>    //10s后停止搜索    new Handler().postDelayed(new Runnable() {                    @Override                    public void run() {                        mBluetoothAdapter.stopLeScan(mLeScanCallback);                    }                }, 1000 * 10);    UUID[] serviceUuids = {UUID.fromString(service_uuid)};    mBluetoothAdapter.startLeScan(serviceUuids, mLeScanCallback);</code></pre><ul><li>startLeScan中，第一个参数是只扫描UUID是同一类的ble设备，第二个参数是扫描到设备后的回调。</li><li>因为蓝牙扫描比较耗电，建议设置扫描时间，一定时间后停止扫描。</li><li>如果不需要过滤扫描到的蓝牙设备，可用mBluetoothAdapter.startLeScan(mLeScanCallback);进行扫描。</li></ul><h3 id="5-5扫描的回调"><a href="#5-5扫描的回调" class="headerlink" title="5.5扫描的回调"></a>5.5扫描的回调</h3><pre><code>    //蓝牙扫描回调接口    private BluetoothAdapter.LeScanCallback mLeScanCallback = new BluetoothAdapter.LeScanCallback(){        @Override        public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) {            if (device.getName() == null) {                return;            }            Log.e("---&gt;搜索到的蓝牙名字：", device.getName());            //可以将扫描的设备弄成列表，点击设备连接，也可以根据每个设备不同标识，自动连接。        }    };</code></pre><h3 id="5-6连接蓝牙"><a href="#5-6连接蓝牙" class="headerlink" title="5.6连接蓝牙"></a>5.6连接蓝牙</h3><ul><li><p>获取设备的mac地址，然后连接。</p><pre><code>//获取所需地址String mDeviceAddress = device.getAddress();BluetoothGatt mBluetoothGatt = device.connectGatt(context, false, mGattCallback);</code></pre></li><li><p>onConnectionStateChange()被调用<br>连接状态改变时，mGattCallback中onConnectionStateChange()方法会被调用，当连接成功时，需要调用mBluetoothGatt.discoverServices();去获取服务。</p></li><li><p>onServicesDiscovered()被调用<br>调用mBluetoothGatt.discoverServices();方法后，onServicesDiscovered（）这个方法会被调用，说明发现当前设备了。然后我们就可以在里面去获取BluetoothGattService和BluetoothGattCharacteristic。</p></li></ul><p>下面就是mGattCallback回调方法。</p><pre><code>    // BLE回调操作    private BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {        @Override        public void onConnectionStateChange(BluetoothGatt gatt, int status,int newState){            super.onConnectionStateChange(gatt, status, newState);            if (newState == BluetoothProfile.STATE_CONNECTED) {                // 连接成功                mBluetoothGatt.discoverServices();            } else if (newState == BluetoothProfile.STATE_DISCONNECTED) {                // 连接断开               Log.d("TAG","onConnectionStateChange fail--&gt;" + status);            }        }        @Override        public void onServicesDiscovered(BluetoothGatt gatt, int status) {            super.onServicesDiscovered(gatt, status);            if (status == BluetoothGatt.GATT_SUCCESS) {                //发现设备，遍历服务，初始化特征                initBLE(gatt);            } else {               Log.d("TAG","onServicesDiscovered fail--&gt;" + status);            }        }        @Override        public void onCharacteristicRead(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status){            super.onCharacteristicRead(gatt, characteristic, status);            if (status == BluetoothGatt.GATT_SUCCESS) {                // 收到的数据                byte[] receiveByte = characteristic.getValue();            }else{               Log.d("TAG","onCharacteristicRead fail--&gt;" + status);            }        }        @Override        public void onCharacteristicChanged(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic){            super.onCharacteristicChanged(gatt, characteristic);            //当特征中value值发生改变        }        /**         * 收到BLE终端写入数据回调         * @param gatt         * @param characteristic         * @param status         */        @Override        public void onCharacteristicWrite(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status) {            super.onCharacteristicWrite(gatt, characteristic, status);            if (status == BluetoothGatt.GATT_SUCCESS) {             // 发送成功            } else {             // 发送失败            }        }        @Override        public void onDescriptorWrite(BluetoothGatt gatt,                                      BluetoothGattDescriptor descriptor, int status) {            super.onDescriptorWrite(gatt, descriptor, status);            if (status == BluetoothGatt.GATT_SUCCESS) {            }        }        @Override        public void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) {            super.onReadRemoteRssi(gatt, rssi, status);            if (status == BluetoothGatt.GATT_SUCCESS) {            }        }        @Override        public void onDescriptorRead(BluetoothGatt gatt,BluetoothGattDescriptor descriptor, int status) {            super.onDescriptorRead(gatt, descriptor, status);            if (status == BluetoothGatt.GATT_SUCCESS) {            }        }    };</code></pre><ul><li><p>获取特征<br>确认ble设备相关的uuid，不同的ble设备的uuid不相同，请根据自己的设备初始化uuid。</p><pre><code>  //写通道uuid  private static final UUID writeCharactUuid = UUID.fromString("0000fff6-0000-1000-8000-00805f9b34fb");  //通知通道 uuid  private static final UUID notifyCharactUuid =UUID.fromString( "0000fff7-0000-1000-8000-00805f9b34fb");</code></pre><p>获取bluetoothGattCharacteristic（因为有的设备可能存在双服务的情况，所以这里遍历所有服务）</p><pre><code>  //初始化特征  public void initBLE(BluetoothGatt gatt) {      if (gatt == null) {          return;      }      //遍历所有服务      for (BluetoothGattService BluetoothGattService : gatt.getServices()) {          Log.e(TAG, "---&gt;BluetoothGattService" + BluetoothGattService.getUuid().toString());          //遍历所有特征          for (BluetoothGattCharacteristic bluetoothGattCharacteristic : BluetoothGattService.getCharacteristics()) {              Log.e("----&gt;gattCharacteristic", bluetoothGattCharacteristic.getUuid().toString());              String str = bluetoothGattCharacteristic.getUuid().toString();              if (str.equals(writeCharactUuid)) {                  //根据写UUID找到写特征                  mBluetoothGattCharacteristic = bluetoothGattCharacteristic;              } else if (str.equals(notifyCharactUuid)) {                  //根据通知UUID找到通知特征                  mBluetoothGattCharacteristicNotify = bluetoothGattCharacteristic;              }          }      }  }</code></pre><p>开启通知，设置开启通知之后，才能在onCharacteristicRead()这个方法中收到数据。</p><pre><code>  mBluetoothGatt.setCharacteristicNotification(mGattCharacteristicNotify, true);</code></pre></li><li><p>发送消息</p><pre><code>  mGattCharacteristicWrite .setValue(sData);  if (mBluetoothGatt != null) {      mBluetoothGatt.setCharacteristicNotification(notifyCharactUuid , true);      mBluetoothGatt.writeCharacteristic(mGattCharacteristicWrite );  } </code></pre></li><li><p>接收消息<br>接收到数据后，mGattCallback 中的onCharacteristicRead()这个方法会被调用。</p><pre><code>      @Override      public void onCharacteristicRead(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status){          super.onCharacteristicRead(gatt, characteristic, status);          if (status == BluetoothGatt.GATT_SUCCESS) {              // 收到的数据              byte[] receiveByte = characteristic.getValue();          }else{             Log.d("TAG","onCharacteristicRead fail--&gt;" + status);          }      }</code></pre></li><li><p>释放资源<br>断开连接，关闭资源。</p><pre><code>  public boolean disConnect() {      if (mBluetoothGatt != null) {          mBluetoothGatt.disconnect();          mBluetoothGatt.close();          mBluetoothGatt = null;          return true;      }      return false;  }</code></pre></li></ul><h2 id="六、常见问题"><a href="#六、常见问题" class="headerlink" title="六、常见问题"></a>六、常见问题</h2><ul><li>通知开启后，才能读到数据，否则读不到。</li><li>发送数据时，如果一包数据超过20字节，需要分包发送，一次最多发送二十字节。</li><li>接收数据时，一次最多也只接收20字节的数据，需要将接收到的数据拼接起来，在数据的结尾弄一个特定的标识，去判断数据是否接受完毕。</li><li>每次发送数据或者数据分包发送时， 操作间要有至少15ms的间隔。</li><li>如果出现扫描不到的情况，那是因为手机没有开启定位权限，清单文件中写上定位权限，代码中在动态获取下就OK</li></ul><h2 id="七、我的例子"><a href="#七、我的例子" class="headerlink" title="七、我的例子"></a>七、我的例子</h2><h3 id="7-1-扫描ble设备并解析广播消息"><a href="#7-1-扫描ble设备并解析广播消息" class="headerlink" title="7.1 扫描ble设备并解析广播消息"></a>7.1 扫描ble设备并解析广播消息</h3><p>AndroidManifest.xml</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="my.compancy1.mybluetooth"&gt;    &lt;uses-feature        android:name="android.hardware.bluetooth_le"        android:required="true" /&gt;    &lt;uses-permission android:name="android.permission.BLUETOOTH" /&gt;    &lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN" /&gt;    &lt;uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" /&gt;    &lt;uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" /&gt;    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;    &lt;application        android:networkSecurityConfig="@xml/network"        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/AppTheme"        android:usesCleartextTraffic="true"&gt;        &lt;meta-data            android:name="com.google.android.actions"            android:resource="@xml/network" /&gt;        &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>入口函数MainActivity.java</p><pre><code>package my.compancy1.mybluetooth;import androidx.annotation.RequiresApi;import androidx.appcompat.app.AppCompatActivity;import androidx.core.app.ActivityCompat;import androidx.core.content.ContextCompat;import android.Manifest;import android.bluetooth.BluetoothAdapter;import android.bluetooth.BluetoothDevice;import android.bluetooth.BluetoothGatt;import android.bluetooth.BluetoothGattCallback;import android.bluetooth.BluetoothGattCharacteristic;import android.bluetooth.BluetoothGattDescriptor;import android.bluetooth.BluetoothGattService;import android.bluetooth.BluetoothManager;import android.bluetooth.BluetoothProfile;import android.bluetooth.le.AdvertiseCallback;import android.bluetooth.le.AdvertiseData;import android.bluetooth.le.AdvertiseSettings;import android.bluetooth.le.BluetoothLeAdvertiser;import android.content.Context;import android.content.Intent;import android.content.pm.PackageManager;import android.os.Build;import android.os.Bundle;import android.os.ParcelUuid;import android.provider.SyncStateContract;import android.text.method.HideReturnsTransformationMethod;import android.util.Log;import android.view.View;import android.widget.Adapter;import android.widget.ArrayAdapter;import android.widget.Button;import android.widget.ListView;import android.widget.SimpleAdapter;import android.widget.TextView;import android.widget.Toast;import org.json.JSONException;import org.json.JSONObject;import java.io.IOException;import java.io.InputStream;import java.lang.reflect.Array;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.net.URLEncoder;import java.sql.BatchUpdateException;import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.HashMap;import java.util.List;import java.util.UUID;import okhttp3.Call;import okhttp3.Callback;import okhttp3.FormBody;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;public class MainActivity extends AppCompatActivity {    TextView textViewDebug;    ListView listView_content;    Button btnTest;    private String[] data={};    private  ArrayList&lt;String&gt; list;    ArrayAdapter&lt;String&gt; adapter;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        btnTest=this.findViewById(R.id.addItem);        btnTest.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Log.d("LLL","alfjl");              //  adapter.add("xxxxxxxx");              //  Toast.makeText(getApplicationContext(),"测试",Toast.LENGTH_SHORT).show();            }        });        Button btnConnect=findViewById(R.id.buttonConnect);        btnConnect.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Toast.makeText(getApplicationContext(),"click me",Toast.LENGTH_SHORT).show();                bleRemote= mBluetoothAdapter.getRemoteDevice("E4:B5:4A:3B:A8:55");                if(bleRemote==null){                    Log.d("zz","Device not found,Unable to connect.");                }else{                    bleRemote.connectGatt(getApplicationContext(),false,mGattCallback);                    Log.d("zz","Trying to create a new connection");                }            }        });        textViewDebug=(TextView) this.findViewById(R.id.textViewDebug);        listView_content=(ListView) this.findViewById(R.id.contentScan);        list=new ArrayList&lt;String&gt;();        Collections.addAll(list,data);        adapter=new ArrayAdapter&lt;String&gt;(MainActivity.this,R.layout.scan_item,list);        //ArrayAdapter&lt;String&gt; adapter=new ArrayAdapter&lt;String&gt;(MainActivity.this,R.layout.scan_item,data);        listView_content.setAdapter(adapter);       // arrayAdapter=new MyAdapter(list,MainActivity.this);       // listView_content.setAdapter(arrayAdapter);       // showErrorText("开始");        InitBluetooth();        GetAccessFineLocation();        PrepareDiscovery();    }    BluetoothAdapter mBluetoothAdapter;    private void InitBluetooth(){        final BluetoothManager bluetoothManager=(BluetoothManager)getSystemService(Context.BLUETOOTH_SERVICE);        mBluetoothAdapter= bluetoothManager.getAdapter();        if(mBluetoothAdapter==null||!mBluetoothAdapter.isEnabled()){            mBluetoothAdapter.enable();        }    }    Button btnStartDiscovery;    private void PrepareDiscovery(){        btnStartDiscovery=this.findViewById(R.id.btnStartD);        btnStartDiscovery.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                Toast.makeText(getApplicationContext(),"准备扫描",Toast.LENGTH_SHORT).show();                if(mBluetoothAdapter.isDiscovering()){                    mBluetoothAdapter.stopLeScan(mLeScanCallback);                }                //Log.d("MyZS","开始扫描");               // textViewDebug.setText("开始扫描");                mBluetoothAdapter.startLeScan(mLeScanCallback);            }        });    }    ArrayList&lt;String&gt; arr;    private String ParseAdMsg(String _msg){        /*        020105030309B0040954583111FF0000003400005049470C2D002403D7180000000000000000000000000000000000000000000000000000000000000000        * */        String msg=_msg.substring(24,60);        arr=new ArrayList&lt;String&gt;();        arr.add(msg.substring(0,2));        arr.add(msg.substring(2,4));        arr.add(msg.substring(4,6));        arr.add(msg.substring(6,8));        arr.add(msg.substring(8,10));        arr.add(msg.substring(10,12));        arr.add(msg.substring(12,14));        arr.add(msg.substring(14,16));        arr.add(msg.substring(16,18));        arr.add(msg.substring(18,20));        arr.add(msg.substring(20,22));        arr.add(msg.substring(22,24));        arr.add(msg.substring(24,26));        arr.add(msg.substring(26,28));        arr.add(msg.substring(28,30));        arr.add(msg.substring(30,32));        arr.add(msg.substring(32,34));        arr.add(msg.substring(34,36));        String resStr="";        if(arr.get(7).equals("00")){            resStr+=" 充电:false 佩戴:false ";        }        if(arr.get(7).equals("01")){            resStr+=" 充电:true 佩戴:false ";        }        if(arr.get(7).equals("02")){            resStr+=" 充电:false 佩戴:true ";        }        if(arr.get(7).equals("03")){            resStr+=" 充电:true 佩戴:true ";        }        int WenDuZ=Integer.parseInt(arr.get(14),16);        int WenDuX=Integer.parseInt(arr.get(15),16);        resStr+=" 体温: "+WenDuZ+"."+WenDuX+" ";        int dianLiang=Integer.parseInt(arr.get(8),16);        resStr+=" 电量: "+dianLiang+"% ";        int jiBu=Integer.parseInt(arr.get(4)+arr.get(5),16);        resStr+=" 计步: "+jiBu+" ";        int hours=Integer.parseInt(arr.get(11),16);        int minutes=Integer.parseInt(arr.get(12),16);        resStr+=" 时间  "+hours+":"+minutes;        return resStr;    }    private String ParseAdMsgWeb(String _mac, String _msg){        /*        020105030309B0040954583111FF0000003400005049470C2D002403D7180000000000000000000000000000000000000000000000000000000000000000        * */        String msg=_msg.substring(24,60);        arr=new ArrayList&lt;String&gt;();        arr.add(msg.substring(0,2));        arr.add(msg.substring(2,4));        arr.add(msg.substring(4,6));        arr.add(msg.substring(6,8));        arr.add(msg.substring(8,10));        arr.add(msg.substring(10,12));        arr.add(msg.substring(12,14));        arr.add(msg.substring(14,16));        arr.add(msg.substring(16,18));        arr.add(msg.substring(18,20));        arr.add(msg.substring(20,22));        arr.add(msg.substring(22,24));        arr.add(msg.substring(24,26));        arr.add(msg.substring(26,28));        arr.add(msg.substring(28,30));        arr.add(msg.substring(30,32));        arr.add(msg.substring(32,34));        arr.add(msg.substring(34,36));        String battery_charging="";        String worn="";        String temperature="";        String electric_quantity="";        String step_num="";        String device_time="";        String resStr="";        if(arr.get(7).equals("00")){            resStr+=" 充电false 佩戴false ";            battery_charging="未充电";            worn="未佩戴";        }        if(arr.get(7).equals("01")){            resStr+=" 充电true 佩戴false ";            battery_charging="充电中";            worn="未佩戴";        }        if(arr.get(7).equals("02")){            resStr+=" 充电false 佩戴true ";            battery_charging="未充电";            worn="佩戴中";        }        if(arr.get(7).equals("03")){            resStr+=" 充电true 佩戴true ";            battery_charging="充电中";            worn="佩戴中";        }        int WenDuZ=Integer.parseInt(arr.get(14),16);        int WenDuX=Integer.parseInt(arr.get(15),16);        resStr+=" 体温"+WenDuZ+"."+WenDuX+" ";        temperature=WenDuZ+"."+WenDuX;        int dianLiang=Integer.parseInt(arr.get(8),16);        resStr+=" 电量"+dianLiang+"";        electric_quantity=dianLiang+"%";        int jiBu=Integer.parseInt(arr.get(4)+arr.get(5),16);        resStr+=" 计步"+jiBu+"";        step_num=jiBu+"";        int hours=Integer.parseInt(arr.get(11),16);        int minutes=Integer.parseInt(arr.get(12),16);        resStr+=" 时间"+hours+":"+minutes;        device_time=hours+":"+minutes;        // String battery_charging,worn,temperature,electric_quantity,step_num,device_time;        JSONObject json=new JSONObject();        try{            json.put("mac_address",_mac);            json.put("battery_charging",battery_charging);            json.put("worn",worn);            json.put("temperature",temperature);            json.put("electric_quantity",electric_quantity);            json.put("step_num",step_num);            json.put("device_time",device_time);        }catch (JSONException e){            e.printStackTrace();        }        return String.valueOf(json);     //   return resStr;    }    public static String str2HexStr(String str) {        char[] chars = "0123456789ABCDEF".toCharArray();        StringBuilder sb = new StringBuilder("");        byte[] bs = str.getBytes();        int bit;        for (int i = 0; i &lt; bs.length; i++) {            bit = (bs[i] &amp; 0x0f0) &gt;&gt; 4;            sb.append(chars[bit]);            bit = bs[i] &amp; 0x0f;            sb.append(chars[bit]);            sb.append(' ');        }        return sb.toString().trim();    }    private  int tempi=0;    private BluetoothDevice bleRemote;    private  BluetoothGatt mBluetoothGatt;    private BluetoothDevice remoteBluetoothDevice=null;    private BluetoothAdapter.LeScanCallback mLeScanCallback=new BluetoothAdapter.LeScanCallback() {        @RequiresApi(api = Build.VERSION_CODES.M)        @Override        public void onLeScan(final BluetoothDevice bluetoothDevice, int i, byte[] bytes) {            Log.d("MyScanRSSI_ZZ:",bluetoothDevice.getAddress()+"    "+bluetoothDevice.getName()+"  ad:  "+bytesToHex(bytes));            handleScanResult(bytes);            if(bluetoothDevice.getName()!=null){                Log.d("ZZZZZZ",bytesToHex(bytes).substring(0,25));                //if(bluetoothDevice.getName().equals("TX1")){                    if(bytesToHex(bytes).substring(0,24).equals("020105030309B00409545831")){               //     adapter.add(bluetoothDevice.getAddress()+"    "+bluetoothDevice.getName()+"  数据:  "+bytesToHex(bytes));           //         adapter.add(bluetoothDevice.getAddress()+"    "+Integer.parseInt("0034",16) +"  截取:  "+ParseAdMsg(bytesToHex(bytes))+"  数据:  "+bytesToHex(bytes));              //      adapter.add(bluetoothDevice.getAddress()+"  截取:  "+ParseAdMsg(bytesToHex(bytes))+"  数据:  "+bytesToHex(bytes));//1.1 描述一个蓝牙设备，提供设备Mac地址和设备名称。                   String msg="设备地址-&gt; "+bluetoothDevice.getAddress()+" 设备名-&gt; "+bluetoothDevice.getName()+" 设备信息-&gt; "+ParseAdMsg(bytesToHex(bytes));                  String msgjson=ParseAdMsgWeb(bluetoothDevice.getAddress().toString(),bytesToHex(bytes));                    adapter.add(msg);//1.2 准备连接蓝牙设备                    /*                    if(tempi&lt;1){                        tempi++;                        bleRemote= mBluetoothAdapter.getRemoteDevice(bluetoothDevice.getAddress());                        if(bleRemote==null){                            Log.d("Tag","Device not found,Unable to connect.");                        }else{                            bleRemote.connectGatt(getApplicationContext(),false,mGattCallback);                            Log.d("TAG","Trying to create a new connection");                        }                    }                    */                 //   getWebReq("Address-"+bluetoothDevice.getAddress()+"Name-"+bluetoothDevice.getName()+""+ParseAdMsg(bytesToHex(bytes)));                 mypost(msgjson);                }            }           //     showErrorText(bytesToHex(bytes));          //  if(bluetoothDevice.getName().equals())            runOnUiThread(new Runnable() {                @Override                public void run() {                      //  Log.d("MyScanRSSI:",bluetoothDevice.getAddress()+"    "+bluetoothDevice.getName());                }            });        }    };    private void mypost(String str){        String url="http://192.168.31.112:8181";        OkHttpClient okHttpClient=new OkHttpClient();        FormBody.Builder formBody=new FormBody.Builder();        formBody.add("username","关云长");        formBody.add("msg",str);        Request request=new Request.Builder()                .url(url)                .post(formBody.build())                .build();        Call call=okHttpClient.newCall(request);        //异步请求，通过接口回调告知用户http的异步执行结果        call.enqueue(new Callback() {            @Override            public void onFailure(Call call, IOException e) {                Log.d("OKHttpFailed",e.getMessage());            }            @Override            public void onResponse(Call call, Response response) throws IOException {                if(response.isSuccessful()){                    Log.d("OKHttp",response.body().toString());                }            }        });    }    private void getWebReq(String _p){        String login_url="http://192.168.31.112:8081/wen.html";       // String p=new String(_p.getBytes("GBK"),"UTF-8");        try {            String lastUrl = login_url + "?dat="+ URLEncoder.encode(_p, "utf-8");            Log.d("西瓜",lastUrl);            URL url = new URL(lastUrl);            HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();//开发访问此连接            //设置访问时长和相应时长            urlConn.setConnectTimeout(5*1000);//设置连接时间为5秒            urlConn.setReadTimeout(6*1000);//设置读取时间为5秒            int code = urlConn.getResponseCode();//获得相应码            if(code == 200){//相应成功，获得相应的数据                InputStream is = urlConn.getInputStream();//得到数据流（输入流）                byte[] buffer = new byte[1024];                int length = 0;                String data = "";                while((length = is.read(buffer)) != -1){                    String str = new String(buffer,0,length);                    data += str;                }                Log.d("main", data);                //解析json，展示在ListView（GridView）            }        } catch (MalformedURLException e) {            // TODO Auto-generated catch block            e.printStackTrace();        } catch (IOException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }    private void GetAccessFineLocation(){        //动态申请定位权限        if(ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.ACCESS_FINE_LOCATION)                != PackageManager.PERMISSION_GRANTED){//未开启定位权限            //开启定位权限,200是标识码            ActivityCompat.requestPermissions(MainActivity.this,new String[]{Manifest.permission.ACCESS_FINE_LOCATION},200);        }else{            // startLocaion();//开始定位            // GetBLUETOOTH_ADMIN();            Toast.makeText(MainActivity.this,"已开启定位权限",Toast.LENGTH_LONG).show();        }    }    private void showErrorText(String messageId) {        TextView view = (TextView) findViewById(R.id.textViewDebug);        view.setText(messageId);    }    //字节数据转化为Hex    static final char[] hexArray="0123456789ABCDEF".toCharArray();    private static  String bytesToHex(byte[] bytes){        char[] hexChars=new char[bytes.length*2];        for(int j=0;j&lt;bytes.length;j++){            int v=bytes[j]&amp;0xFF;            hexChars[j*2]=hexArray[v&gt;&gt;&gt;4];            hexChars[j*2+1]=hexArray[v&amp;0x0F];        }        return new String(hexChars);    }    //格式化UUID    public String parseUUID(String data){        String uuid="";        if(data.length()==32){            uuid=data.substring(0,8)+"-"                    +data.substring(8,12)+"-"                    +data.substring(12,16)+"-"                    +data.substring(16,20)+"-"                    +data.substring(20);        }else{            Toast.makeText(getApplicationContext(),"UUID未发现",Toast.LENGTH_SHORT).show();        }        return uuid;    }    //处理广播数据    private void handleScanResult(byte[] scanRecord){    }    /*    * GATT    * */    //1.3 连接到设备之后，获取设备服务Service和服务对应的Characteristic    //1.4 写入成功后，开始读取设备返回来的数据    private final BluetoothGattCallback mGattCallback=new BluetoothGattCallback() {        //判断连接是否成功        @Override        public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {            super.onConnectionStateChange(gatt, status, newState);            String intentAction;            if(status==BluetoothGatt.GATT_SUCCESS){                //连接成功时                Log.d("ZS","连接到GATT服务器");                //立即去执行发现服务                mBluetoothGatt=gatt;                gatt.discoverServices();            }else if(newState== BluetoothProfile.STATE_DISCONNECTED){                //断开连接                mBluetoothGatt=null;                Log.d("ZS","与Gatt服务器断开连接");            }        }        //发现服务        @Override        public void onServicesDiscovered(BluetoothGatt gatt, int status) {            super.onServicesDiscovered(gatt, status);            List&lt;BluetoothGattService&gt; services=gatt.getServices();            for(BluetoothGattService service:services){                List&lt;BluetoothGattCharacteristic&gt; characteristics=service.getCharacteristics();                for(BluetoothGattCharacteristic character:characteristics){                    Log.d("发现服务",gatt+" serviceUUID:  "+service.getUuid()+"  characterUUID:  "+character.getUuid());                }            }            if(status==BluetoothGatt.GATT_SUCCESS){                Log.d("ZZ","发现服务是可以的");            }else{                Log.d("ZZ","发现接收到的服务:"+status);            }        }        //数据读取  从特征中读取数据        @Override        public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {            super.onCharacteristicRead(gatt, characteristic, status);            Log.d("读取出来的值",gatt+"  "+characteristic+"  "+status);        }        //向特征中写入数据        @Override        public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {            super.onCharacteristicWrite(gatt, characteristic, status);        }        //数据改变  连接成功后回调该方法        @Override        public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {            super.onCharacteristicChanged(gatt, characteristic);            byte[] value=characteristic.getValue();            for(int i=0;i&lt;value.length;i++){                Log.d("BLE","character_value="+value[i]);            }        }        //数据描述读取        @Override        public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {            super.onDescriptorRead(gatt, descriptor, status);        }        @Override        public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {            super.onDescriptorWrite(gatt, descriptor, status);            UUID uuid=descriptor.getCharacteristic().getUuid();            if(uuid.equals(UUID.fromString("0000cd01-0000-1000-8000-00805f9b34fb"))){            }        }    };    //获得特征之后，找到服务可以向下位机写指令的特征，向该特征写入指令    public void wirteCharacteristic(BluetoothGattCharacteristic characteristic){        if(mBluetoothAdapter==null||mBluetoothGatt==null){            Log.d("TAG","BluetoothAdapter not initialized");            return;        }        mBluetoothGatt.writeCharacteristic(characteristic);    }}</code></pre><h3 id="7-2-协议说明与操作结果"><a href="#7-2-协议说明与操作结果" class="headerlink" title="7.2 协议说明与操作结果"></a>7.2 协议说明与操作结果</h3><p>厂家协议说明和nRFConnect软件实际操作结果对比，如图：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/documentinstruct1.jpg" alt="协议说明"><br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/nrfconnectres2.jpg" alt="nRF Connect操作结果"></p><h2 id="八、GATT读写操作的一点说明"><a href="#八、GATT读写操作的一点说明" class="headerlink" title="八、GATT读写操作的一点说明"></a>八、GATT读写操作的一点说明</h2><p>bluetoothDevice.connectGatt（）方法返回的对象BluetoothGatt，这个BluetoothGatt对象非常重要，甚至可以说是最重要的。一般都是单独声明成全局变量来使用的，因为我们设备的读、写和订阅等操作都需要用到这个对象。<br>发现服务后才可以进行读写订阅等操作。读写订阅操作通过服务Service和特征值Characteristic来操作，如何获得对应的服务和特征值呢？一般硬件工程师会预先定义好uuid并告诉我们。我们通过如下方法获得服务和特征值：</p><pre><code>//write_UUID_service和write_UUID_chara是硬件工程师告诉我们的 BluetoothGattService service=mBluetoothGatt.getService(write_UUID_service); BluetoothGattCharacteristic charaWrite=service.getCharacteristic(write_UUID_chara);</code></pre><p>读取数据 </p><pre><code>private void readData() {        BluetoothGattCharacteristic characteristic=mBluetoothGatt.getService(read_UUID_service).getCharacteristic(read_UUID_chara);        mBluetoothGatt.readCharacteristic(characteristic);}</code></pre><p>读取数据用的少，一般我们都是先订阅，再写入，在订阅的回调里进行数据交互。</p><p>写入数据</p><pre><code>private void writeData(){        BluetoothGattService service=mBluetoothGatt.getService(write_UUID_service);        BluetoothGattCharacteristic charaWrite=service.getCharacteristic(write_UUID_chara);        byte[] data=HexUtil.hexStringToBytes(hex);        if (data.length&gt;20){//数据大于个字节 分批次写入            Log.e(TAG, "writeData: length="+data.length);            int num=0;            if (data.length%20!=0){                num=data.length/20+1;            }else{                num=data.length/20;            }            for (int i=0;i&lt;num;i++){                byte[] tempArr;                if (i==num-1){                    tempArr=new byte[data.length-i*20];                    System.arraycopy(data,i*20,tempArr,0,data.length-i*20);                }else{                    tempArr=new byte[20];                    System.arraycopy(data,i*20,tempArr,0,20);                }                charaWrite.setValue(tempArr);                mBluetoothGatt.writeCharacteristic(charaWrite);            }        }else{            charaWrite.setValue(data);            mBluetoothGatt.writeCharacteristic(charaWrite);        }    }</code></pre><p>写操作的回调</p><pre><code>        @Override        public void onCharacteristicWrite(BluetoothGatt gatt,BluetoothGattCharacteristic characteristic, int status) {                super.onCharacteristicWrite(gatt, characteristic, status);                Log.e(TAG,"onCharacteristicWrite()  status="+status+",value="+HexUtil.encodeHexStr(characteristic.getValue()));        }</code></pre><p>订阅回调</p><pre><code>//订阅通知mBluetoothGatt.setCharacteristicNotification(mBluetoothGatt.getService(notify_UUID_service).getCharacteristic(notify_UUID_chara),true);</code></pre><p>注意一定要写在写入之前，要不然就收不到写入的数据，我一般都是在发现服务之后就订阅。关于订阅收不到这里，需要注意一下，首先你写入的和订阅的Characteristic对象一定要属于同一个Service对象，另外就是保证你写入的数据没问题，否则就可能收不到订阅回调。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> BLE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio快速实现二维码功能</title>
      <link href="/2020/07/28/diary-20200728-1/"/>
      <url>/2020/07/28/diary-20200728-1/</url>
      
        <content type="html"><![CDATA[<h3 id="1-1-AndroidManifest-xml内添加权限"><a href="#1-1-AndroidManifest-xml内添加权限" class="headerlink" title="1.1 AndroidManifest.xml内添加权限"></a>1.1 AndroidManifest.xml内添加权限</h3><pre><code>    &lt;uses-permission android:name="android.permission.CAMERA" /&gt;    &lt;uses-permission android:name="android.permission.FLASHLIGHT" /&gt;    &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt;    &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;    &lt;uses-feature android:name="android.hardware.camera" /&gt;    &lt;uses-feature android:name="android.hardware.camera.autofocus" /&gt;    &lt;uses-permission android:name="android.permission.VIBRATE" /&gt;    &lt;uses-permission android:name="android.permission.WAKE_LOCK" /&gt;</code></pre><h3 id="1-2-在build-gradle-Module-app-中添加"><a href="#1-2-在build-gradle-Module-app-中添加" class="headerlink" title="1.2 在build.gradle(Module:app)中添加"></a>1.2 在build.gradle(Module:app)中添加</h3><p>在build.gradle(Module:app)的dependencies{}中添加 implementation “cn.yipianfengye.android:zxing-library:2.2”</p><pre><code>    dependencies {        implementation fileTree(dir: "libs", include: ["*.jar"])        implementation 'androidx.appcompat:appcompat:1.1.0'        implementation 'androidx.constraintlayout:constraintlayout:1.1.3'        testImplementation 'junit:junit:4.12'        androidTestImplementation 'androidx.test.ext:junit:1.1.1'        androidTestImplementation 'androidx.test.espresso:espresso-core:3.2.0'        implementation "cn.yipianfengye.android:zxing-library:2.2"    }</code></pre><h3 id="1-3-入口函数里初始化"><a href="#1-3-入口函数里初始化" class="headerlink" title="1.3 入口函数里初始化"></a>1.3 入口函数里初始化</h3><p>在MainActivity的onCreate里初始化，执行ZXingLibrary.initDisplayOpinion(this);<br>Android6.0以后需要动态运行时权限。<br>MainActivity.java如下</p><pre><code>package com.compancy1.myqrcode;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import android.Manifest;import android.content.Intent;import android.content.pm.PackageManager;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.os.Build;import android.os.Bundle;import android.text.TextUtils;import android.view.View;import android.widget.Button;import android.widget.EditText;import android.widget.ImageView;import android.widget.Toast;import com.uuzuche.lib_zxing.activity.CaptureActivity;import com.uuzuche.lib_zxing.activity.CodeUtils;import com.uuzuche.lib_zxing.activity.ZXingLibrary;public class MainActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        getRuntimePermission();    }    private void getRuntimePermission(){        if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.M){            String[] perms={Manifest.permission.CAMERA,Manifest.permission.WRITE_EXTERNAL_STORAGE,Manifest.permission.READ_EXTERNAL_STORAGE};            if(checkSelfPermission(perms[0])== PackageManager.PERMISSION_DENIED||checkSelfPermission(perms[1])==PackageManager.PERMISSION_DENIED||checkSelfPermission(perms[2])==PackageManager.PERMISSION_DENIED){                requestPermissions(perms,200);            }else{                DoReallyThing();            }        }    }    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        switch(requestCode){            case 200:{                for(int i:grantResults){                    if(i==PackageManager.PERMISSION_DENIED){                        Toast.makeText(this,"权限拒绝",Toast.LENGTH_SHORT).show();                        return;                    }                }                DoReallyThing();                break;            }        }    }    private void DoReallyThing(){        ZXingLibrary.initDisplayOpinion(getApplicationContext());        Button btnStartQR=findViewById(R.id.btn);        btnStartQR.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                //打开摄像头识别二维码                Intent intent =new Intent(MainActivity.this, CaptureActivity.class);                startActivityForResult(intent,250);            }        });        Button btnGenerateQR=findViewById(R.id.btn2);        final EditText yourInputText=(EditText)findViewById(R.id.yourinput);        final ImageView imageView=(ImageView)findViewById(R.id.imageView1);        btnGenerateQR.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                String textContent=yourInputText.getText().toString();                if(TextUtils.isEmpty(textContent)){                    Toast.makeText(getApplicationContext(),"您的输入为空!",Toast.LENGTH_SHORT).show();                    return;                }                yourInputText.setText("");                Bitmap bitmap=CodeUtils.createImage(textContent,400,400, null);                imageView.setImageBitmap(bitmap);            }        });    }    @Override    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {        super.onActivityResult(requestCode, resultCode, data);        if(requestCode==250){            Bundle bundle=data.getExtras();            if(bundle==null){                return;            }            if(bundle.getInt(CodeUtils.RESULT_TYPE)==CodeUtils.RESULT_SUCCESS){                String result=bundle.getString(CodeUtils.RESULT_STRING);                Toast.makeText(this,"解析结果:"+result,Toast.LENGTH_LONG).show();            }else if(bundle.getInt(CodeUtils.RESULT_TYPE)==CodeUtils.RESULT_FAILED){                Toast.makeText(this,"解析失败",Toast.LENGTH_SHORT).show();            }        }    }}</code></pre><p>布局文件activity_main.xml如下：</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent" android:layout_height="wrap_content"    xmlns:android="http://schemas.android.com/apk/res/android"    android:orientation="vertical"&gt;    &lt;Button        android:id="@+id/btn"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:text="开启相机识别二维码" /&gt;    &lt;Button        android:id="@+id/btn2"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:layout_weight="1"        android:text="生成二维码" /&gt;    &lt;EditText        android:id="@+id/yourinput"        android:layout_width="match_parent"        android:layout_height="wrap_content" /&gt;    &lt;ImageView        android:id="@+id/imageView1"        android:layout_width="match_parent"        android:layout_height="wrap_content"        tools:srcCompat="@tools:sample/avatars" /&gt;&lt;/LinearLayout&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidStudio </tag>
            
            <tag> 二维码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio开发记录1-运行时权限</title>
      <link href="/2020/07/27/diary-20200727-1/"/>
      <url>/2020/07/27/diary-20200727-1/</url>
      
        <content type="html"><![CDATA[<h2 id="申请运行时权限"><a href="#申请运行时权限" class="headerlink" title="申请运行时权限"></a>申请运行时权限</h2><p>Android 6.0以后加入了运行时权限这一概念。对于危险权限，应用必须在使用的时候进行申请。</p><h3 id="1-1-AndroidManifest-xml内添加权限"><a href="#1-1-AndroidManifest-xml内添加权限" class="headerlink" title="1.1 AndroidManifest.xml内添加权限"></a>1.1 AndroidManifest.xml内添加权限</h3><pre><code>    &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" /&gt;    &lt;uses-permission android:name="android.permission.CAMERA" /&gt;</code></pre><h3 id="1-2-获得运行时权限"><a href="#1-2-获得运行时权限" class="headerlink" title="1.2 获得运行时权限"></a>1.2 获得运行时权限</h3><p>入口处添加执行函数(以下运行时权限其实是批量申请的，String[] perms里可以添加多个)。</p><pre><code>    private void getRuntimePermission(){        if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.M){            String[] perms={Manifest.permission.CAMERA,Manifest.permission.WRITE_EXTERNAL_STORAGE};            if(checkSelfPermission(perms[0])==PackageManager.PERMISSION_DENIED||checkSelfPermission(perms[1])==PackageManager.PERMISSION_DENIED){                requestPermissions(perms,200);            }else{                jumpDoSomethingReally();            }        }    }    @Override    public void onRequestPermissionsResult(int resquestCode,@NonNull String[] permissions,@NonNull int[] grantResults){        switch(resquestCode){            case 200:{                for(int i:grantResults){                    if(i==PackageManager.PERMISSION_DENIED){                        Toast.makeText(this,"权限拒绝",Toast.LENGTH_SHORT).show();                        return;                    }                }                jumpDoSomethingReally();                break;            }        }    }</code></pre><h2 id="使用第三方jar包或类库"><a href="#使用第三方jar包或类库" class="headerlink" title="使用第三方jar包或类库"></a>使用第三方jar包或类库</h2><ul><li>File-&gt;New-&gt;Import Module 导入第三方类库文件</li><li>File-&gt;Project Structure 在出现的界面中选择Properties、SDK version、Build Tools Version。尽量把自己新建的程序和导入类库的SDK版本BuildToolsVersion版本一致。</li><li>将第三方类库和自己新建的安卓程序设置关联关系，File-&gt;Prject Structure-&gt;自己的项目-&gt;Dependencies-&gt;点击+ -&gt;Module dependence -&gt;在之后出现的界面选择导入的第三方类库，点击ok确认。</li><li>导入类库文件比较容易出问题的地方就是SDK版本和Build Tools Version版本了，上面也记录了怎么修改版本。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android调用摄像头拍照，保存至相册并显示在当前界面</title>
      <link href="/2020/07/23/diary-20200723-4/"/>
      <url>/2020/07/23/diary-20200723-4/</url>
      
        <content type="html"><![CDATA[<p>测试的功能就是界面一个按钮，点击调用摄像头拍照，在onActivityResult回调方法里对图片处理显示在当前界面并保存在相册。<br>直接上代码。</p><p>Android应用的清单文件AndroidManifest.xml</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="com.compancy1.usecamera"&gt;    &lt;uses-permission android:name="android.permission.CAMERA"/&gt;    &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;    &lt;application        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/AppTheme"&gt;        &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>布局文件activity_main.xml</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:app="http://schemas.android.com/apk/res-auto"    xmlns:tools="http://schemas.android.com/tools"    android:layout_width="match_parent"    android:layout_height="wrap_content"    android:orientation="vertical"    xmlns:android="http://schemas.android.com/apk/res/android"&gt;    &lt;Button        android:id="@+id/btn_take_photo"        android:layout_width="match_parent"        android:layout_height="wrap_content"        android:text="拍照" /&gt;    &lt;ImageView        android:id="@+id/picture"        android:layout_width="wrap_content"        android:layout_height="wrap_content"        tools:srcCompat="@tools:sample/avatars" /&gt;&lt;/LinearLayout&gt;</code></pre><p>入口MainActivity.java</p><pre><code>package com.compancy1.usecamera;import androidx.annotation.NonNull;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import androidx.core.app.ActivityCompat;import androidx.core.content.ContextCompat;import androidx.core.content.FileProvider;import android.Manifest;import android.app.Activity;import android.content.ContentUris;import android.content.ContentValues;import android.content.Context;import android.content.Intent;import android.content.pm.PackageManager;import android.database.Cursor;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.net.Uri;import android.os.Build;import android.os.Bundle;import android.os.Environment;import android.provider.MediaStore;import android.util.Log;import android.view.View;import android.widget.Button;import android.widget.ImageView;import android.widget.Toast;import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;public class MainActivity extends AppCompatActivity {    public static  final int TAKE_PHOTO=1;    public static  final int TAKE_PHOTO_2=2;    private ImageView pictureShow;    private String mFilePath;    private String fileName;    private Context mContext;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Button takePhoto=findViewById(R.id.btn_take_photo);        pictureShow=findViewById(R.id.picture);        mContext=MainActivity.this;        takePhoto.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                if(ContextCompat.checkSelfPermission(mContext, Manifest.permission.CAMERA)!= PackageManager.PERMISSION_GRANTED){                    ActivityCompat.requestPermissions((Activity)mContext,new String[]{Manifest.permission.CAMERA},100);                }else{                    startCamera2();                }            }        });    }    @Override    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {        super.onRequestPermissionsResult(requestCode, permissions, grantResults);        switch (requestCode){            case 100:                startCamera2();                break;            default:        }    }    private void startCamera(){        Intent intent=new Intent("android.media.action.IMAGE_CAPTURE");        startActivityForResult(intent,TAKE_PHOTO);    }    private void  startCamera2(){        //拍摄的照片保存到本地相册        File fileDir=new File(Environment.getExternalStorageState(),"Pictures");        if(!fileDir.exists()){            fileDir.mkdir();        }        fileName="IMG_"+System.currentTimeMillis()+".jpg";        mFilePath=fileDir.getAbsolutePath()+"/"+fileName;        Uri uri=null;        ContentValues contentValues=new ContentValues();        contentValues.put(MediaStore.Images.Media.DISPLAY_NAME,fileName);        if(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.Q){            contentValues.put(MediaStore.Images.Media.RELATIVE_PATH,"DCIM/Pictures");        }else{            contentValues.put(MediaStore.Images.Media.DATA,mFilePath);        }        contentValues.put(MediaStore.Images.Media.MIME_TYPE,"image/JPEG");        uri=getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,contentValues);        Intent intent=new Intent(MediaStore.ACTION_IMAGE_CAPTURE);//启动系统相机        intent.putExtra(MediaStore.EXTRA_OUTPUT,uri);        startActivityForResult(intent,TAKE_PHOTO_2);    }    @Override    protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {        super.onActivityResult(requestCode, resultCode, data);        switch (requestCode){            case TAKE_PHOTO:                break;            case TAKE_PHOTO_2:                //将拍摄的照片显示在当前界面                String selection=MediaStore.Images.Media.DISPLAY_NAME+"=?";                Cursor cursor=getContentResolver().query(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,new String[]{MediaStore.Images.Media._ID},selection,new String[]{fileName},null);                if(cursor!=null&amp;&amp;cursor.moveToFirst()){                    do{                        Uri uri= ContentUris.withAppendedId(MediaStore.Images.Media.EXTERNAL_CONTENT_URI,cursor.getLong(0));                        Log.i("luingssd","@"+uri);                        try {                            InputStream inputStream=getContentResolver().openInputStream(uri);                            Bitmap bitmap= BitmapFactory.decodeStream(inputStream);                            pictureShow.setImageBitmap(bitmap);                        } catch (FileNotFoundException e) {                            e.printStackTrace();                        }                    }while (cursor.moveToNext());                }else{                    Toast.makeText(this, "no photo", Toast.LENGTH_SHORT).show();                }                break;                default:        }    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Nodejs+Mongodb+Android+Vue的一个应用</title>
      <link href="/2020/07/23/diary-20200723-3/"/>
      <url>/2020/07/23/diary-20200723-3/</url>
      
        <content type="html"><![CDATA[<p>最近数据联通验证了一个应用。</p><ul><li>手环作为ble设备，时刻通过蓝牙向外广播信息。</li><li>运行起来MongoDB数据库,用于接收存储手环信息，如体温步数等。</li><li>Android应用，通过手机蓝牙扫描，收集手环信息，通过http发往服务器。</li><li>服务端NodeJS,监听http，一方面接收Android应用传过来的信息并存储，另一方面提供信息给web端管理页面显示。</li><li>Web端管理页面，基于Vue的网页通过服务端，数据库展示信息。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/bleAppWeb.jpg" alt="ble设备在Web端的展示管理"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue常用功能之2-验证码</title>
      <link href="/2020/07/23/diary-20200723-2/"/>
      <url>/2020/07/23/diary-20200723-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、验证码的实现"><a href="#一、验证码的实现" class="headerlink" title="一、验证码的实现"></a>一、验证码的实现</h2><h3 id="1-1新建组件identify-vue"><a href="#1-1新建组件identify-vue" class="headerlink" title="1.1新建组件identify.vue"></a>1.1新建组件identify.vue</h3><pre><code>    &lt;template&gt;      &lt;div class="s-canvas"&gt;        &lt;canvas id="s-canvas" :width="contentWidth" :height="contentHeight"&gt;&lt;/canvas&gt;      &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;    export default {        name: 'SIdentify',        props: {            identifyCode: { // 默认注册码                type: String,                default: '1234'            },        fontSizeMin: { // 字体最小值            type: Number,            default: 25        },        fontSizeMax: { // 字体最大值            type: Number,            default: 35        },        backgroundColorMin: { // 验证码图片背景色最小值            type: Number,            default: 200        },        backgroundColorMax: { // 验证码图片背景色最大值            type: Number,            default: 220        },        dotColorMin: { // 背景干扰点最小值            type: Number,            default: 60        },        dotColorMax: { // 背景干扰点最大值            type: Number,            default: 120        },        contentWidth: { // 容器宽度            type: Number,            default: 116        },        contentHeight: { // 容器高度            type: Number,            default: 38        }      },      methods: {        // 生成一个随机数        randomNum (min, max) {            return Math.floor(Math.random() * (max - min) + min)        },        // 生成一个随机的颜色        randomColor (min, max) {            let r = this.randomNum(min, max)            let g = this.randomNum(min, max)            let b = this.randomNum(min, max)            return 'rgb(' + r + ',' + g + ',' + b + ')'        },        drawPic () {            let canvas = document.getElementById('s-canvas')            let ctx = canvas.getContext('2d')            ctx.textBaseline = 'bottom'          // 绘制背景            ctx.fillStyle = this.randomColor(this.backgroundColorMin, this.backgroundColorMax)            ctx.fillRect(0, 0, this.contentWidth, this.contentHeight)          // 绘制文字            for (let i = 0; i &lt; this.identifyCode.length; i++) {                this.drawText(ctx, this.identifyCode[i], i)            }            this.drawLine(ctx)            this.drawDot(ctx)        },        drawText (ctx, txt, i) {          ctx.fillStyle = this.randomColor(50, 160) // 随机生成字体颜色          ctx.font = this.randomNum(this.fontSizeMin, this.fontSizeMax) + 'px SimHei' // 随机生成字体大小          let x = (i + 1) * (this.contentWidth / (this.identifyCode.length + 1))          let y = this.randomNum(this.fontSizeMax, this.contentHeight - 5)          var deg = this.randomNum(-30, 30)          // 修改坐标原点和旋转角度          ctx.translate(x, y)          ctx.rotate(deg * Math.PI / 180)          ctx.fillText(txt, 0, 0)          // 恢复坐标原点和旋转角度          ctx.rotate(-deg * Math.PI / 180)          ctx.translate(-x, -y)        },        drawLine (ctx) {          // 绘制干扰线          for (let i = 0; i &lt; 4; i++) {            ctx.strokeStyle = this.randomColor(100, 200)            ctx.beginPath()            ctx.moveTo(this.randomNum(0, this.contentWidth), this.randomNum(0, this.contentHeight))            ctx.lineTo(this.randomNum(0, this.contentWidth), this.randomNum(0, this.contentHeight))            ctx.stroke()          }        },        drawDot (ctx) {          // 绘制干扰点          for (let i = 0; i &lt; 30; i++) {            ctx.fillStyle = this.randomColor(0, 255)            ctx.beginPath()            ctx.arc(this.randomNum(0, this.contentWidth), this.randomNum(0, this.contentHeight), 1, 0, 2 * Math.PI)            ctx.fill()          }        }      },      watch: {        identifyCode () {          this.drawPic()        }      },      mounted () {        this.drawPic()      }    }    &lt;/script&gt;    &lt;style scoped&gt;    &lt;/style&gt;</code></pre><h3 id="1-2在需要的页面中使用验证码组件"><a href="#1-2在需要的页面中使用验证码组件" class="headerlink" title="1.2在需要的页面中使用验证码组件"></a>1.2在需要的页面中使用验证码组件</h3><pre><code>&lt;template&gt;  &lt;div class="pageLogin"&gt;    &lt;div class="pageInner"&gt;    &lt;el-form :model="loginfrom" :rules="rules" ref="loginfrom" label-width="0px" class="demo-ruleForm"&gt;        &lt;el-form-item prop="username"&gt;             &lt;el-input v-model="loginfrom.username" placeholder="账号"&gt;             &lt;i slot="prepend" class="el-icon-s-custom"/&gt;             &lt;/el-input&gt;        &lt;/el-form-item&gt;        &lt;el-form-item prop="password"&gt;             &lt;el-input :type="passw" placeholder="密码" v-model="loginfrom.password"&gt;             &lt;i slot="prepend" class="el-icon-lock"/&gt;             &lt;/el-input&gt;        &lt;/el-form-item&gt;        &lt;el-form-item prop="code"&gt;             &lt;el-row :span="24"&gt;             &lt;el-col :span="12"&gt;             &lt;el-input v-model="loginfrom.code" auto-complete="off" placeholder="请输入验证码" maxlength="4"              &gt;&lt;/el-input&gt;             &lt;/el-col&gt;             &lt;el-col :span="12"&gt;             &lt;div class="login-code" @click="changeCode()"&gt;                    &lt;identify :identifyCode="identifyCode"&gt;&lt;/identify&gt;                &lt;/div&gt;             &lt;/el-col&gt;             &lt;/el-row&gt;        &lt;/el-form-item&gt;        &lt;el-form-item&gt;            &lt;el-col :span="8"&gt;                &lt;span&gt;&lt;/span&gt;            &lt;/el-col&gt;            &lt;el-col :span="8"&gt;                &lt;div class="login-btn"&gt;                    &lt;el-button type="primary" @click="submitForm('loginfrom')"&gt;登录&lt;/el-button&gt;                &lt;/div&gt;            &lt;/el-col&gt;            &lt;el-col :span="8"&gt;                &lt;i&gt;&lt;router-link to="Register"&gt;我要注册&lt;/router-link&gt;&lt;/i&gt;            &lt;/el-col&gt;                    &lt;/el-form-item&gt;    &lt;/el-form&gt;    &lt;/div&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Qs from 'qs';import Mock from 'mockjs';import store from "@/vuex/store";import identify from '@/components/identify';export default {    created(){        this.identifyCode = ''        this.makeCode(this.identifyCodes, 4);        Mock.mock('http://unExist.net/assessment/unExistLogin.php',{            'objs':[                {                    'msg':'欢迎你的登陆'                },                {                    'msg':'这是一条测试信息'                }            ]        });    },    components:{        identify    },    store,    name: 'Login',    data () {        return {            loginfrom: {                username: '',                password:'',                code:''            },                        rules: {                username: [                { required: true, message: '请输入账号', trigger: 'blur' },                { min: 3, max: 15, message: '长度在 3 到 15 个字符', trigger: 'blur' }                ],                password: [                { required: true, message: '请输入密码', trigger: 'blur' },                { min: 3, max: 15, message: '长度在 3 到 15 个字符', trigger: 'blur' }                ],             },            passw:"password",            identifyCode:'',            identifyCodes:'1234567890abcdefghijkmnpstuwxyz',            username:'',            password:'',            rememberPw:false        }    },    methods:{        onClickLogin:function(){            var _this=this;             var data=Qs.stringify({                user:this.username,                pass:this.password            });                        this.$axios.post('http://unExist.net/assessment/unExistLogin.php',data,{headers:{}}).then(function(res){                console.log(res);                _this.loginSuccess();            }).catch(function(err){                console.log(err);            });        },        loginSuccess:function(){            console.log(this.$store.state.count);        },        submitForm(formName) {            this.$refs[formName].validate((valid) =&gt; {                if (valid) {                    console.log('success validate');                    if(this.identifyCode.toLowerCase()==this.loginfrom.code.toLowerCase()){                        console.log('success code');                        this.onClickLogin();                        this.$router.push("/admin").catch(error =&gt; error);                    }else{                        console.log('error code');                    }                } else {                    console.log('error validate');                    return false;                }            });        },        changeCode(){            //点击验证码刷新验证码            this.identifyCode='';            this.makeCode(this.identifyCodes,4);        },        randomNum(min,max){            //生成随机整数            max=max+1;            return Math.floor(Math.random()*(max-min)+min);        },        makeCode(data,len){            //生成随机验证码字符串            for(let i =0;i&lt;len;i++)            {                this.identifyCode+=data[this.randomNum(0,data.length-1)];            }        },        showPass(){            if(this.passw=="text"){                this.passw="password";                this.icon="el-input__icon el-icon-view";            }else{                this.passw="text";                this.icon="el-input__icon el-icon-lock";            }        }    }}&lt;/script&gt;&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;&lt;style lang="scss" scoped&gt;    body{        text-align:center;    }    .pageInner{        width:300px;        height:220px;        margin:25px auto;        padding:0 0;    }  .pageLogin{    width:400px;    height:280px;    margin:160px auto;    padding:5px 0px;    background-color:#f5f5f5;    .el-col{        border: 1px solid transparent;    }  }&lt;/style&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue常用功能之1-轮询</title>
      <link href="/2020/07/23/diary-20200723-1/"/>
      <url>/2020/07/23/diary-20200723-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、轮询的实现"><a href="#一、轮询的实现" class="headerlink" title="一、轮询的实现"></a>一、轮询的实现</h2><p>添加定义，方法。</p><pre><code>    data(){        return{            timer:null,        }    }        ......    ......    methods:{        setTimer(intMilliecond){            this.timer=setInterval(()=&gt;{                this.whatDoIDo();            },intMilliecond);        },        whatDoIDo:function(){            console.log("what can i do");        }    }    </code></pre><p>调用轮询方法之前，先clearInterval(this.timer)；关闭网页前要清理本次轮询</p><pre><code>    created:function(){        if(this.timer!=null){            clearInterval(this.timer);        }        this.setTimer(3000);            },    ......    ......    destroyed(){        clearInterval(this.timer);    }</code></pre><h2 id="二、常见问题"><a href="#二、常见问题" class="headerlink" title="二、常见问题"></a>二、常见问题</h2><h3 id="2-1-定时器里的this"><a href="#2-1-定时器里的this" class="headerlink" title="2.1 定时器里的this"></a>2.1 定时器里的this</h3><p>定时器里的this是指向window的，导致定时器里this.属性是访问不了Vue在data里定义的属性的。解决方法是提前把vue对象this以参数的形式传进定时器里</p><pre><code>    created:function(){        var that=this;                if(this.timer!=null){            clearInterval(this.timer);        }        this.setTimer(3000,that);            },    ......    ......    methods:{        setTimer(intMilliecond,_t){            this.timer=setInterval(()=&gt;{                this.whatDoIDo(_t);            },intMilliecond);        },        whatDoIDo:function(_this){            console.log("what can i do");            console.log(_this.VueData属性);        }    }</code></pre><h3 id="2-2完整demo"><a href="#2-2完整demo" class="headerlink" title="2.2完整demo"></a>2.2完整demo</h3><p>以下是我一个vue轮询使用的例子</p><pre><code>&lt;style lang="scss" scoped&gt; .pageorder{    height:100%; }&lt;/style&gt;&lt;template&gt;    &lt;div class="pageorder"&gt;           &lt;h1&gt;设备管理&lt;/h1&gt;        &lt;data-list-table             :list="listA"             :total-num="listA.length"&gt;&lt;/data-list-table&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Qs from 'qs';import Mock from 'mockjs';import DataListTable from '@/components/DataListTable'export default {    data(){        return{            timer:null,            listA:[],        }    },    name: 'order',    components:{        'data-list-table':DataListTable        },    created:function(){        //[]里从数组的第2个开始删除1个元素        //this.listA.splice(2,1);        var that=this;        if(this.timer!=null){            clearInterval(this.timer);        }        this.setTimer(3000,that);            },    methods:{        setTimer(intMilliecond,_t){            this.timer=setInterval(()=&gt;{                this.whatDoIDo(_t);            },intMilliecond);        },        whatDoIDo:function(_this){                        this.$axios({                url:'http://127.0.0.1:8181',                method:'get',                params:{                    action:'getble'                }            }).then(function(res){                //console.log(res);                                console.log(res.data.length);                for(var i=0;i&lt;res.data.length;i++){                                        var jsonprepare=JSON.parse(res.data[i].msg);                    var jsonObj=eval("("+jsonprepare+")");                    jsonObj["student_id"]="No0001";                    for(var j in _this.listA){                    if(_this.listA[j]["mac_address"]==jsonObj["mac_address"]){                            _this.listA.splice(j,1,jsonObj);                                                    return;                        }                    }                    _this.listA.push(jsonObj);                }                /*                var jsonprepare=JSON.parse(res.data[0].msg);                //console.log(jsonprepare);                var jsonObj=eval("("+jsonprepare+")");                jsonObj["student_id"]="No0001";                console.log(jsonObj);                for(var j in _this.listA){                    if(_this.listA[j]["mac_address"]==jsonObj["mac_address"]){                        console.log("找到相同的mac address");                                                //将数组中第i个元素起第1个元素，替换为jsonObj                        _this.listA.splice(j,1,jsonObj);                                                return;                    }                }                console.log("没有相同的mac address，添加记录");                _this.listA.push(jsonObj);                */            }).catch(function(err){                console.log("attenation!!!+ "+err);            });        }    },    destroyed(){        clearInterval(this.timer);    }}&lt;/script&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB实践之2-nodejs连接mongodb数据库</title>
      <link href="/2020/07/20/diary-20200720-2/"/>
      <url>/2020/07/20/diary-20200720-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础操作"><a href="#一、基础操作" class="headerlink" title="一、基础操作"></a>一、基础操作</h2><h3 id="1-1初始化nodejs工程"><a href="#1-1初始化nodejs工程" class="headerlink" title="1.1初始化nodejs工程"></a>1.1初始化nodejs工程</h3><p>在项目根目录下初始化一个package.json文件</p><pre><code>    npm init -y</code></pre><h3 id="1-2安装mongodb模块"><a href="#1-2安装mongodb模块" class="headerlink" title="1.2安装mongodb模块"></a>1.2安装mongodb模块</h3><pre><code>    npm install --save-dev mongodb</code></pre><h3 id="1-3基础增删改查操作"><a href="#1-3基础增删改查操作" class="headerlink" title="1.3基础增删改查操作"></a>1.3基础增删改查操作</h3><p>建立index.js进行代码编写，对数据库进行连接操作。node index.js运行。</p><pre><code>    const mongodbClient=require("mongodb").MongoClient;    const url="mongodb://127.0.0.1:27017";    mongodbClient.connect(url,        {            useUnifiedTopology:true        },        (err,client)=&gt;{        if(err){            console.log("连接失败:"+err);        }else{            console.log("连接成功:"+url);        }    });    mongodbClient.connect(        url,        {            useUnifiedTopology:true        },        (err,client)=&gt;{            if(err){                console.log("连接失败:"+err);            }else{                //连接到该数据库服务器下数据库tablihi中的表biao1,获取表后，对表进行操作。                const collection=client.db("tablehi").collection("biao1");                //增                //collection.save(                //    {                //        "name":"赵四",                //        "password":"safs56"                //    },(err,result)=&gt;{                //        //client.close();                //    }                //);                //删                //collection.remove(                //    {                //        "name":"张三"                //    },()=&gt;{                //        //client.close();                //    }                //);                //改                //collection.update(                //    {                //        "name":"王五"                //    },                //    {                //        "$set":{"password":"wangwu"}                //    }                //);                //查                collection.find().toArray((err,data)=&gt;{                    console.log(data);                    client.close();                });            }        }    );</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB实践之1-安装及命令行登录</title>
      <link href="/2020/07/20/diary-20200720-1/"/>
      <url>/2020/07/20/diary-20200720-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/gainianmongodb1.jpg" alt="MongoDB相关概念1"><br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/gainianmongodb2.jpg" alt="MongoDB相关概念直观示意"></p><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><h2 id="二、解压版MongoDB配置使用"><a href="#二、解压版MongoDB配置使用" class="headerlink" title="二、解压版MongoDB配置使用"></a>二、解压版MongoDB配置使用</h2><p>官方下载地址 <a href="http://dl.mongodb.org/dl/win32/x86_64" target="_blank" rel="noopener">http://dl.mongodb.org/dl/win32/x86_64</a></p><h3 id="2-1-创建mongodb目录"><a href="#2-1-创建mongodb目录" class="headerlink" title="2.1 创建mongodb目录"></a>2.1 创建mongodb目录</h3><p>下载mongodb-win32-x86_64-2008plus-ssl-v4.0-latest.zip，解压到当前目录后更改文件夹名称为mongodb（名称可随意）。<br>在解压后的文件夹内新建data、log两个文件夹<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/jiayainstallmongodb1.jpg" alt="创建mongodb目录"></p><h3 id="2-2-创建配置文件"><a href="#2-2-创建配置文件" class="headerlink" title="2.2 创建配置文件"></a>2.2 创建配置文件</h3><p>mongodb目录下创建conf文件夹，其内创建mongodb.config</p><pre><code>dbpath=D:\mdb\mongodb\data                            #数据库路径logpath=D:\mdb\mongodb\log\mongodb.log                #日志输出文件路径logappend=true                                        #日志采用追加模式，mongodb的日志会追加到现有日志文件里，而不是重新创建一个新文件journal=true                                        #启用日志quiet=true                                            #过滤掉一些无用日志信息，若需调试请设置为falseport=27017                                            #端口号 默认为27017bind_ip_all=true                                    #允许所有地址访问</code></pre><h3 id="2-3手动启动"><a href="#2-3手动启动" class="headerlink" title="2.3手动启动"></a>2.3手动启动</h3><p>管理员cmd模式下进入mongodb目录 D:\mdb\mongodb\bin下</p><h4 id="运行mongodb"><a href="#运行mongodb" class="headerlink" title="运行mongodb"></a>运行mongodb</h4><pre><code>mongod --config "D:/mdb/mongodb/conf/mongodb.config"</code></pre><h4 id="查看mongodb版本"><a href="#查看mongodb版本" class="headerlink" title="查看mongodb版本"></a>查看mongodb版本</h4><pre><code>mongod --version</code></pre><h3 id="2-4命令行登录db"><a href="#2-4命令行登录db" class="headerlink" title="2.4命令行登录db"></a>2.4命令行登录db</h3><p>mongodb运行后，重新另起一个cmd模式进入 D:\mdb\mongodb\bin，可以登录测试mongodb是否起来了</p><pre><code>mongo 127.0.0.1:27017</code></pre><h3 id="2-5命令行登录mongodb后的操作"><a href="#2-5命令行登录mongodb后的操作" class="headerlink" title="2.5命令行登录mongodb后的操作"></a>2.5命令行登录mongodb后的操作</h3><h4 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h4><p>show dbs;</p><h4 id="切换-创建数据库"><a href="#切换-创建数据库" class="headerlink" title="切换/创建数据库"></a>切换/创建数据库</h4><p>use dancy;<br>如果use后面的数据库存在则切换到该数据库，如果不存在则创建</p><h4 id="查看当前数据库"><a href="#查看当前数据库" class="headerlink" title="查看当前数据库"></a>查看当前数据库</h4><p>db;</p><h4 id="查看当前库有多少集合"><a href="#查看当前库有多少集合" class="headerlink" title="查看当前库有多少集合"></a>查看当前库有多少集合</h4><p>show collections;</p><h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h4><p>db.createCollection(某collection名)</p><h4 id="查询某个集合的内容"><a href="#查询某个集合的内容" class="headerlink" title="查询某个集合的内容"></a>查询某个集合的内容</h4><p>db.”某collection名(类似某表名)”.find();</p><h4 id="往某集合里插入一条文档数据"><a href="#往某集合里插入一条文档数据" class="headerlink" title="往某集合里插入一条文档数据"></a>往某集合里插入一条文档数据</h4><p>db.”某collection名(类似某表名)”.insert({“name”: “dancy”})</p><h4 id="删除当前数据库db-dropDatabase"><a href="#删除当前数据库db-dropDatabase" class="headerlink" title="删除当前数据库db.dropDatabase()"></a>删除当前数据库db.dropDatabase()</h4><h4 id="查看集合内文档-db-集合名-find"><a href="#查看集合内文档-db-集合名-find" class="headerlink" title="查看集合内文档 db.集合名.find()"></a>查看集合内文档 db.集合名.find()</h4><p>find方法里面可以传递参数（查询条件）</p><h4 id="查看已插入集合的所有文档（格式化输出）"><a href="#查看已插入集合的所有文档（格式化输出）" class="headerlink" title="查看已插入集合的所有文档（格式化输出）"></a>查看已插入集合的所有文档（格式化输出）</h4><p>db.集合名.find().pretty()</p><h4 id="删除一个文档"><a href="#删除一个文档" class="headerlink" title="删除一个文档"></a>删除一个文档</h4><p>db.集合名.deleteOne({“name”: “lotus”}) , 括号内参数为删除条件。</p><h4 id="删除所有文档："><a href="#删除所有文档：" class="headerlink" title="删除所有文档："></a>删除所有文档：</h4><p>db.集合名.deleteMany({})</p><pre><code>db.adminCommand()               db.dbEval()                     db.getFreeMonitoringStatus()    db.getSiblingDB()               db.isMaster()                   db.revokePrivilegesFromRole()   db.stats()db.aggregate()                  db.disableFreeMonitoring()      db.getLastError()               db.getSisterDB()                db.killOP()                     db.revokeRolesFromRole()        db.toLocaleString()db.auth()                       db.dropAllRoles()               db.getLastErrorCmd()            db.getSlaveOk()                 db.killOp()                     db.revokeRolesFromUser()        db.toString()db.changeUserPassword()         db.dropAllUsers()               db.getLastErrorObj()            db.getUser()                    db.listCommands()               db.runCommand()                 db.tojson()db.cloneCollection()            db.dropDatabase(               db.getLogComponents(           db.getUsers()                   db.loadServerScripts()          db.runCommandWithMetadata()     db.unsetWriteConcern()db.cloneDatabase()              db.dropRole()                   db.getMongo()                   db.getWriteConcern()            db.logout()                     db.runReadCommand()             db.updateRole()db.commandHelp()                db.dropUser()                   db.getName()                    db.grantPrivilegesToRole()      db.printCollectionStats()       db.serverBits()                 db.updateUser()db.constructor                 db.enableFreeMonitoring()       db.getPrevError()               db.grantRolesToRole()           db.printReplicationInfo()       db.serverBuildInfo()            db.valueOfdb.copyDatabase()               db.eval()                       db.getProfilingLevel()          db.grantRolesToUser()           db.printShardingStatus()        db.serverCmdLineOpts()          db.version()db.createCollection()           db.forceError()                 db.getProfilingStatus()         db.group()                      db.printSlaveReplicationInfo()  db.serverStatus()db.createRole()                 db.fsyncLock()                  db.getQueryOptions()            db.groupcmd()                   db.propertyIsEnumerable        db.setLogLevel()db.createUser()                 db.fsyncUnlock()                db.getReplicationInfo()         db.groupeval()                  db.prototype                   db.setProfilingLevel()db.createView()                 db.getCollection()              db.getRole()                    db.hasOwnProperty              db.removeUser()                 db.setSlaveOk()db.currentOP()                  db.getCollectionInfos()         db.getRoles()                   db.help()                       db.repairDatabase()             db.setWriteConcern()db.currentOp()                  db.getCollectionNames()         db.getSession()                 db.hostInfo()                   db.resetError()                 db.shutdownServer()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android网络请求框架OkHttp的使用</title>
      <link href="/2020/07/17/diary-20200717-1/"/>
      <url>/2020/07/17/diary-20200717-1/</url>
      
        <content type="html"><![CDATA[<ul><li>okhttp-3.9.0.jar</li><li>okio-1.13.0.jar(配套必须包含)</li></ul><h2 id="一、关于OkHttp"><a href="#一、关于OkHttp" class="headerlink" title="一、关于OkHttp"></a>一、关于OkHttp</h2><p> OkHttp 是 Square 公司开源的针对 Java 和 Android 程序，封装的一个高性能 http 请求库。支持spdy、http2.0、websocket，支持同步、异步，而且OkHttp又封装了线程池，封装了数据转换，封装了参数使用、错误处理等，api使用起来更加方便。可以把它理解成是一个封装之后的类似HttpUrlConnection的一个东西，但是你在使用的时候仍然需要自己再做一层封装，这样才能像使用一个框架一样更加顺手。</p><h2 id="二、安装使用"><a href="#二、安装使用" class="headerlink" title="二、安装使用"></a>二、安装使用</h2><h3 id="2-1-添加库的引用"><a href="#2-1-添加库的引用" class="headerlink" title="2.1 添加库的引用"></a>2.1 添加库的引用</h3><p>将okhttp-3.9.0.jar和okio-1.13.0.jar放入AndroidStudio的Project/app/libs/目录下，并右键点击“Add As Library”。</p><h3 id="2-2-添加网络访问权限"><a href="#2-2-添加网络访问权限" class="headerlink" title="2.2 添加网络访问权限"></a>2.2 添加网络访问权限</h3><p>在AndroidManifest.xml里添加权限</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="com.compancy1.yibuhttp"&gt;    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;    &lt;application        android:networkSecurityConfig="@xml/network"        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/AppTheme"&gt;        &lt;meta-data            android:name="com.google.android.actions"            android:resource="@xml/network" /&gt;        &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><h3 id="2-3-Activity代码中使用"><a href="#2-3-Activity代码中使用" class="headerlink" title="2.3 Activity代码中使用"></a>2.3 Activity代码中使用</h3><pre><code>public class MainActivity extends AppCompatActivity {    Button btn;         @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        btn=(Button) findViewById(R.id.btn1);        btn.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                myPost();            }        });    }    private void myPost(){        String url="http://192.168.31.112:8181";        OkHttpClient okHttpClient=new OkHttpClient();        FormBody.Builder formBody=new FormBody.Builder();        formBody.add("username","关云长");        formBody.add("password","a123321b");        Request request=new Request.Builder()                .url(url)                .post(formBody.build())                .build();        Call call=okHttpClient.newCall(request);        //异步请求，通过接口回调告知用户http的异步执行结果        call.enqueue(new Callback() {            @Override            public void onFailure(Call call, IOException e) {                Log.d("OKHttpFailed",e.getMessage());            }            @Override            public void onResponse(Call call, Response response) throws IOException {                if(response.isSuccessful()){                    Log.d("OKHttp",response.body().toString());                }            }        });    }}</code></pre><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>由于Android P以后网络访问安全策略升级引起的错误，报错CLEARTEXT communication to “ “ not permitted by network security policy 。<br>解决方法:添加res/xml/network.xml文件后，在Androidmanifest.xml中设置networkSecurity指向该文件即可。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/notpermittedbynetworksecuritypolicy.jpg" alt="网络访问安全策略修改"><br>network.xml如下</p><pre><code>&lt;?xml version ="1.0" encoding ="utf-8"?&gt;&lt;network-security-config&gt;    &lt;base-config cleartextTrafficPermitted="true"  /&gt;&lt;/network-security-config&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidStudio </tag>
            
            <tag> OkHttp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用socket.io和nodeJS的websocket实践</title>
      <link href="/2020/07/16/diary-20200716-2/"/>
      <url>/2020/07/16/diary-20200716-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于socket-IO"><a href="#一、关于socket-IO" class="headerlink" title="一、关于socket.IO"></a>一、关于socket.IO</h2><p>socket.IO是一个websocket库，包括了客户端的js和服务器端的nodejs。官方地址：<a href="http://socket.io" target="_blank" rel="noopener">http://socket.io</a> </p><h2 id="二、socket-io提供给客户端的websock服务"><a href="#二、socket-io提供给客户端的websock服务" class="headerlink" title="二、socket.io提供给客户端的websock服务"></a>二、socket.io提供给客户端的websock服务</h2><p>去github clone socket.io的最新版本，或者直接饮用使用socket.io的CDN服务：</p><pre><code>    &lt;script src="https://lib.baomitu.com/socket.io/2.3.0/socket.io.js"&gt;&lt;/script&gt;</code></pre><p>以下是使用socket.io库来创建客户端</p><pre><code>    &lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script src="https://lib.baomitu.com/socket.io/2.3.0/socket.io.js"&gt;&lt;/script&gt;    &lt;script&gt;        var socket=io.connect('http://localhost:8081');        socket.on('message',function(data){            console.log('Receive message from server,'+data);            socket.emit('message',{nihao:'helloworld'});            socket.emit('storeClientInfo',{customId:"000CustomIdHere1234"});        });        socket.on('connect',function(){            alert("连接成功");        });        socket.on('disconnect',function(){            console.log("断开连接");        });    &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;</code></pre><h2 id="三、socket-io提供给服务器端搭建websock服务"><a href="#三、socket-io提供给服务器端搭建websock服务" class="headerlink" title="三、socket.io提供给服务器端搭建websock服务"></a>三、socket.io提供给服务器端搭建websock服务</h2><h3 id="创建空的项目文件夹"><a href="#创建空的项目文件夹" class="headerlink" title="创建空的项目文件夹"></a>创建空的项目文件夹</h3><pre><code>    mkdir socketserver    cd socketserver</code></pre><h3 id="在项目内安装socket-io"><a href="#在项目内安装socket-io" class="headerlink" title="在项目内安装socket.io"></a>在项目内安装socket.io</h3><pre><code>    npm install socket.io</code></pre><h3 id="搭建服务器环境"><a href="#搭建服务器环境" class="headerlink" title="搭建服务器环境"></a>搭建服务器环境</h3><p>通过nodejs的http模块就可以方便的搭建websocket服务器环境</p><pre><code>    // 引入需要的模块：http和socket.io    var http=require('http');    var io=require('socket.io');    // 创建server，Socket服务器还是构建于HTTP服务器之上，因此先调用 http.createServer()    var server=http.createServer();    server.on('request',function(req,res){        res.writeHead(200,{'Content-Type':'text/html'});        res.end('&lt;h1&gt;Hello,Socket&lt;/h1&gt;');    });    //http端口8081    server.listen(8081);    console.log("-- http listen on port :8081 --");    var clients=[];    //创建socket，交由Socket.io接管    var socket=io.listen(server);    //添加连接监听，Socket.io 真正的连接事件    socket.on('connection',function(client){        //服务端这边的客户端对象代表接受客户端发过来的信息        client.on('message',function(obj){            console.log("Receive message from client,"+obj.nihao);        });        //客户端断开连接时，在服务器端的列表里删除相应对象代表        client.on('disconnect',function(){            //console.log('server has disconnected');            for(var i=0,len=clients.length;i&lt;len;++i){                var c=clients[i];                if(c.clientId==client.id){                    clients.splice(i,1);                    console.log(clients.length);                    break;                }            }        });        //服务端这边的监听客户端对象代表接受客户端发过来的自定义事件        client.on('storeClientInfo',function(data){            var clientInfo=new Object();            clientInfo.customId=data.customId;            clientInfo.clientId=client.id;            clients.push(clientInfo);            console.log(clients.length);        });        //服务端通过客户端对象代表向该客户端发送信息message        client.send("welcome my friend");    });    console.log("-- socket listen on port :8081 --");</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> socket.io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速搭建在线文档的实践</title>
      <link href="/2020/07/16/diary-20200716-1/"/>
      <url>/2020/07/16/diary-20200716-1/</url>
      
        <content type="html"><![CDATA[<ul><li>Vue v2.9.6</li><li>Node v12.16.3</li></ul><h2 id="一、关于vuepress："><a href="#一、关于vuepress：" class="headerlink" title="一、关于vuepress："></a>一、关于vuepress：</h2><p>vuepress项目的文档结构，都必须按照官方文档的格式进行制作。比如说你想修改整体的主题颜色，你就必须修改styles文件夹下的palette.styl。你想在markdown中添加vue组件，vue组件必须放在components文件夹下，诸如此类。等到vuepress在打包的时候，它会遍历特定的路径和文件名称，读取内容生成页面结构和样式。</p><h2 id="二、开始制作"><a href="#二、开始制作" class="headerlink" title="二、开始制作"></a>二、开始制作</h2><h3 id="创建空的项目文件夹"><a href="#创建空的项目文件夹" class="headerlink" title="创建空的项目文件夹"></a>创建空的项目文件夹</h3><pre><code>    mkdir vuepressdemo    cd vuepressdemo</code></pre><h3 id="全局安装vuepress"><a href="#全局安装vuepress" class="headerlink" title="全局安装vuepress"></a>全局安装vuepress</h3><pre><code>    npm install -g vuepress</code></pre><h3 id="初始化项目信息"><a href="#初始化项目信息" class="headerlink" title="初始化项目信息"></a>初始化项目信息</h3><pre><code>    npm init -y</code></pre><p>创建完成后，进入我们的pageckage.json文件，在scripts中添加两条命令</p><pre><code>"scripts": {    "dev": "vuepress dev docs",         //用于实时预览    "build": "vuepress build docs"      //用于打包项目}</code></pre><h3 id="按规则创建vuepress项目结构的文件夹和文件"><a href="#按规则创建vuepress项目结构的文件夹和文件" class="headerlink" title="按规则创建vuepress项目结构的文件夹和文件"></a>按规则创建vuepress项目结构的文件夹和文件</h3><p>有现成的就直接复制docs目录吧。<br>或者对照<a href="https://vuepress.vuejs.org/zh/guide/directory-structure.html" target="_blank" rel="noopener">官方的目录结构</a></p><pre><code>├── docs│   ├── .vuepress  //存放核心内容的文件夹│   │   ├── components  //存放你需要添加的vue组件│   │   ├── public  //存放静态文件，如图片等│   │   ├── styles  //存放需要定制的样式│   │   │   └── palette.styl  //配置页面主题颜色的文件│   │   └── config.js   //设定顶部导航栏、侧边导航栏等项目配置的核心文件│   ├── pages   //存放markdown文件，用于设置其他页面内容│   ├── README.md   //首页展示用的markdown文件├── deploy.sh     //之后用于编写上传、发布脚本的文件└── package.json  //之前创建的Node.js项目描述文件</code></pre><h3 id="开发、部署"><a href="#开发、部署" class="headerlink" title="开发、部署"></a>开发、部署</h3><p>CMD进入在package.json同层目录里执行命令。</p><pre><code>    npm run dev    用于开发实时预览    npm run build  用于打包项目输出静态网页于docs/.vuepress/dist/处。</code></pre><p>如果不部署在服务器根目录，需要在docs/.vuepress/config.js里添加base信息。</p><pre><code>//config.jsmodule.exports = {    title: '我的首页', // 显示在左上角的网页名称以及首页在浏览器标签显示的title名称    description: '我的首页记录', // meta 中的描述文字，用于SEO    // 注入到当前页面的 HTML &lt;head&gt; 中的标签    head: [        ['link', { rel: 'icon', href: '/egg.png' }],  //浏览器的标签栏的网页图标    ],    markdown: {        lineNumbers: true    },    serviceWorker: true,    themeConfig: {            logo: '/egg.png',        lastUpdated: 'lastUpdate', // string | boolean        nav: [            { text: '首页', link: '/' },            {                text: '分类',                ariaLabel: '分类',                items: [                    { text: '文章', link: '/pages/folder1/test1.md' },                    { text: '琐碎', link: '/pages/folder2/test4.md' },                ]            },            { text: '功能演示', link: '/pages/folder1/test3.md' },            { text: '联系我', link: 'https://www.baidu.com' },        ],        sidebar: {            '/pages/folder1/':[                {                    title: '测试菜单1',   // 必要的一级菜单名称                    collapsable: false, // 可选的, 默认值是 true折叠,                    sidebarDepth: 1,    // 可选的, 设置侧边导航自动提取markdown文件标题的层级，默认1为h2层级                    children: [                        ['test1.md', '子菜单1'],    //菜单名称为'子菜单1'，跳转至/pages/folder1/test1.md                        ['test3.md', '子菜单2']                    ]                },                {                    title: '测试菜单2',                    collapsable: false, // 可选的, 默认值是 true,                    children: [                        ['test2.md', '子菜单1']                    ]                }            ],            //...可添加多个不同的侧边栏，不同页面会根据路径显示不同的侧边栏        }    },    base: '/mydoc/'  //部署时服务器的发布目录}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中ListView的用法</title>
      <link href="/2020/07/15/diary-20200715-1/"/>
      <url>/2020/07/15/diary-20200715-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ListView的作用："><a href="#一、ListView的作用：" class="headerlink" title="一、ListView的作用："></a>一、ListView的作用：</h2><p>将数据填充到布局，处理用户的选择点击操作。<br>创建ListView需要3个元素：</p><ol><li>ListView中的每一列的View。</li><li>填入View的数据或图片资源等。</li><li>连接数据与ListView的适配器。</li></ol><h2 id="二、什么是适配器？"><a href="#二、什么是适配器？" class="headerlink" title="二、什么是适配器？"></a>二、什么是适配器？</h2><p>适配器是一个连接数据资源和AdapterView（如ListView）的桥梁，使用适配器能实现数据与AdapterView的分离，使AdapterView与数据的绑定更加简单，修改更加方便。<br>Android中常用的适配器Adapter有：</p><ul><li>ArrayAdapter<t>：用于绑定数组，支持泛型操作</t></li><li>SimpleAdapte：用于绑定在xml中定义的控件对应的数据</li><li>SimpleCursorAdapter：用于绑定游标得到的数据</li><li>BaseAdapter：通用的基础适配器</li></ul><h3 id="2-1-ArrayAdapter："><a href="#2-1-ArrayAdapter：" class="headerlink" title="2.1 ArrayAdapter："></a>2.1 ArrayAdapter<t>：</t></h3><p>用ArrayAdapter可实现简单的ListView数据绑定。默认情况下，ArrayAdapter绑定每个对象的toString值到layout中预先定义的TextView控件上。还可以实现带RadioButton和CheckBox的ListView。<br>在布局文件中添加一个ListView控件。</p><pre><code>&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;LinearLayoutxmlns:android="http://schemas.android.com/apk/res/android"    android:layout_width="fill_parent"    android:layout_height="fill_parent"    &gt;    &lt;ListView         android:id="@+id/lv"        android:layout_width="fill_parent"        android:layout_height="fill_parent"    /&gt;&lt;/LinearLayout&gt;</code></pre><p>然后在Activity中初始化。</p><pre><code>publicclass MyListView extends Activity {    privatestaticfinal String[] strs = new String[] {        "first", "second", "third", "fourth", "fifth"    };    //定义一个String数组用来显示ListView的内容    private ListView lv;    /** Called when the activity is first created. */    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        lv = (ListView) findViewById(R.id.lv);        //得到ListView对象的引用        /*为ListView设置Adapter来绑定数据*/        lv.setAdapter(new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1, strs));        /*处理用户的操作。通过如下的代码就可以为ListView绑定一个点击监听器*/        lv.setOnItemClickListener(new OnItemClickListener() {            @Override            publicvoid onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2,long arg3) {                //点击后在标题上显示点击了第几行                setTitle("你点击了第"+arg2+"行");            }        });    }}</code></pre><p>其中R.layout.simple_list_item_1是一个自定义的layout文件xml,必须要有TextView控件。比如长下面这个样子：</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;TextView xmlns:android="http://schemas.android.com/apk/res/android"    android:layout_width="match_parent"    android:layout_height="wrap_content"    android:orientation="vertical"&gt;&lt;/TextView&gt;</code></pre><p>分析一下以上简单的使用步骤：</p><ul><li>定义一个数组来存放ListView中item的内容。</li><li>通过实现ArrayAdapter的构造函数来创建一个ArrayAdapter的对象。</li><li>通过ListView的setAdapter()方法绑定ArrayAdapter。<br>其中第二步有必要说一下的是，ArrayAdapter有多个构造函数，例子中实现的是最常用的一种。第一个参数为上下文，第二个参数为一个包含TextView，用来填充ListView的每一行的布局资源ID。第三个参数为ListView的内容。其中第二个参数可以自定义一个layout，但是这个layout必须要有TextView控件。通常我们使用Android提供的资源，除了例子中所用的，常用的还有如下几种，可实现带RadioButton和CheckBox的ListView。</li></ul><h3 id="2-2-SimpleAdapter："><a href="#2-2-SimpleAdapter：" class="headerlink" title="2.2 SimpleAdapter："></a>2.2 SimpleAdapter：</h3><p>使用SimpleAdapter可以自定义实现ListView中的item的内容，比如图片、多选框等。使用simpleAdapter的数据一般都是用HashMap构成的列表，列表的每一节对应ListView的每一行。通过SimpleAdapter的构造函数，将HashMap的每个键的数据映射到布局文件中对应控件上。<br>很多时候需要在列表中展示一些除了文字以外的东西，比如图片等。这时候可以使用SimpleAdapter。SimpleAdapter的使用也非常简单，同时它的功能也非常强大。可以通过它自定义ListView中的item的内容，比如图片、多选框等。接下来这个例子，实现一个每一行都有一个ImageView和TextView的ListView。<br>在布局文件中添加一个ListView控件。</p><pre><code>&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;LinearLayoutxmlns:android="http://schemas.android.com/apk/res/android"    android:layout_width="fill_parent"    android:layout_height="fill_parent"    &gt;    &lt;ListView         android:id="@+id/lv"        android:layout_width="fill_parent"        android:layout_height="fill_parent"    /&gt;&lt;/LinearLayout&gt;</code></pre><p>定义一个ListView中每一行的布局item.xml，用RelativeLayout来实现一个带两行字和一个图片的布局。</p><pre><code>&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;RelativeLayoutxmlns:android="http://schemas.android.com/apk/res/android"    android:layout_height="fill_parent"    android:layout_width="fill_parent"    &gt;    &lt;ImageView android:layout_alignParentRight="true"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:id="@+id/ItemImage"    /&gt;    &lt;TextView android:id="@+id/ItemTitle"    android:layout_height="wrap_content"    android:layout_width="fill_parent"    android:textSize="20sp"/&gt;    &lt;TextViewandroid:id="@+id/ItemText"    android:layout_height="wrap_content"    android:layout_width="fill_parent"    android:layout_below="@+id/ItemTitle"    /&gt;&lt;/RelativeLayout&gt;</code></pre><p>配置完毕，就可以在Activity中为ListView绑定数据。</p><pre><code>    public class MyListViewSimple extends Activity {        private ListView lv;        /** Called when the activity is first created. */        @Override        public void onCreate(Bundle savedInstanceState) {            super.onCreate(savedInstanceState);            setContentView(R.layout.main);            lv = (ListView) findViewById(R.id.lv);            /*定义一个动态数组*/            ArrayList&lt;HashMap&lt;String, Object&gt;&gt; listItem = new ArrayList&lt;HashMap&lt;String,Object&gt;&gt;();            /*在数组中存放数据*/            for(int i=0;i&lt;10;i++)            {                HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();                map.put("ItemImage", R.drawable.icon);//加入图片                map.put("ItemTitle", "第"+i+"行");                map.put("ItemText", "这是第"+i+"行");                listItem.add(map);            }            SimpleAdapter mSimpleAdapter = new SimpleAdapter(this,listItem,R.layout.item,new String[] {"ItemImage","ItemTitle", "ItemText"},new int[] {R.id.ItemImage,R.id.ItemTitle,R.id.ItemText});            lv.setAdapter(mSimpleAdapter);//为ListView绑定适配器            lv.setOnItemClickListener(new OnItemClickListener() {                 @Override                public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2,long arg3) {                    setTitle("你点击了第"+arg2+"行");//设置标题栏显示点击的行                }            });            }    }</code></pre><p>使用simpleAdapter的数据一般都是用HashMap构成的列表，列表的每一节对应ListView的每一行。通过SimpleAdapter的构造函数，将HashMap的每个键的数据映射到布局文件中对应控件上。这个布局文件一般根据自己的需要来自己定义。梳理一下使用SimpleAdapter的步骤。</p><ul><li>根据需要定义ListView每行所实现的布局。</li><li>定义一个HashMap构成的列表，将数据以键值对的方式存放在里面。</li><li>构造SimpleAdapter对象。</li><li>将LsitView绑定到SimpleAdapter上。</li></ul><h3 id="2-3-BaseAdapter"><a href="#2-3-BaseAdapter" class="headerlink" title="2.3 BaseAdapter:"></a>2.3 BaseAdapter:</h3><p>当ListView不只是用于展示数据，还需要加入按钮等控件获取焦点时，使用BaseAdapter，因为SimpleAdapter添加一个按钮到ListView的条目中时，无法获得焦点，点击操作会被ListView的Item所覆盖。<br><font color="red">使用BaseAdapter必须写一个类继承它</font>，同时BaseAdapter是一个抽象类，继承它必须实现它的方法。BaseAdapter的灵活性就在于它要重写很多方法，以下是必须实现的方法</p><ul><li>***Adapter(Content)</li><li>getCount():int</li><li>getItem(int):Object</li><li>getItemId(int):long</li><li>getView(int,View,ViewGroup):View<br>其中最重要的即为getView()方法。这些方法都有什么作用呢？我们通过分析ListView的原理来揭晓。<br>当系统开始绘制ListView的时候，首先调用getCount()方法。得到它的返回值，即ListView的长度。然后系统调用getView()方法，根据这个长度逐一绘制ListView的每一行。也就是说，如果让getCount()返回1，那么只显示一行。而getItem()和getItemId()则在需要处理和取得Adapter中的数据时调用。那么getView如何使用呢？如果有10000行数据，就绘制10000次？这肯定会极大的消耗资源，导致ListView滑动非常的慢，那应该怎么做呢？通过一个例子来讲解如何在使用BaseAdapter的时候优化ListView的显示。例子中将上一节中的ImageView换成Button，并且处理Button的点击事件，其中对ListView的显示做了优化。<br>例子的布局文件同上一个例子类似，这里只给出Activity类。<pre><code>public class MyListViewBase extends Activity {  private ListView lv;  /*定义一个动态数组*/  ArrayList&lt;HashMap&lt;String, Object&gt;&gt;listItem;  /** Called when the activity is first created. */  @Override  public void onCreate(Bundle savedInstanceState) {      super.onCreate(savedInstanceState);      setContentView(R.layout.main);      lv = (ListView)findViewById(R.id.lv);      MyAdapter mAdapter = new MyAdapter(this);//得到一个MyAdapter对象      lv.setAdapter(mAdapter);//为ListView绑定Adapter      /*为ListView添加点击事件*/      lv.setOnItemClickListener(new OnItemClickListener() {          @Override          public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2,long arg3) {              Log.v("MyListViewBase", "你点击了ListView条目" + arg2);//在LogCat中输出信息          }      });  }  /*添加一个得到数据的方法，方便使用*/  private ArrayList&lt;HashMap&lt;String, Object&gt;&gt; getDate(){      ArrayList&lt;HashMap&lt;String,Object&gt;&gt; listItem = new ArrayList&lt;HashMap&lt;String,Object&gt;&gt;();      /*为动态数组添加数据*/          for(int i=0;i&lt;30;i++)      {          HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();          map.put("ItemTitle", "第"+i+"行");          map.put("ItemText", "这是第"+i+"行");          listItem.add(map);                 }      return listItem;  }  /* 新建一个类继承BaseAdapter，实现视图与数据的绑定     */  private class MyAdapter extends BaseAdapter {      private LayoutInflater mInflater;//得到一个LayoutInfalter对象用来导入布局      /*构造函数*/      public MyAdapter(Context context) {          this.mInflater = LayoutInflater.from(context);      }      @Override      public int getCount() {          return getDate().size();//返回数组的长度      }      @Override      public Object getItem(int position) {          return null;      }      @Override      public long getItemId(int position) {          return 0;      }      /*书中详细解释该方法*/      @Override      public View getView(finalint position, View convertView, ViewGroup parent) {          ViewHolder holder;                      //观察convertView随ListView滚动情况          Log.v("MyListViewBase", "getView " + position + " " + convertView);          if (convertView == null) {              convertView = mInflater.inflate(R.layout.item,null);              holder = new ViewHolder();              /*得到各个控件的对象*/              holder.title = (TextView) convertView.findViewById(R.id.ItemTitle);              holder.text = (TextView) convertView.findViewById(R.id.ItemText);              holder.bt = (Button) convertView.findViewById(R.id.ItemButton);              convertView.setTag(holder);//绑定ViewHolder对象          }else{              holder = (ViewHolder)convertView.getTag();//取出ViewHolder对象          }          /*设置TextView显示的内容，即我们存放在动态数组中的数据*/          holder.title.setText(getDate().get(position).get("ItemTitle").toString());          holder.text.setText(getDate().get(position).get("ItemText").toString());          /*为Button添加点击事件*/          holder.bt.setOnClickListener(new OnClickListener() {              @Override              public void onClick(View v) {                  Log.v("MyListViewBase", "你点击了按钮" + position);//打印Button的点击信息              }          });          return convertView;      }  }  /*存放控件*/  public final class ViewHolder{      public TextView title;      public TextView text;      public Button bt;  }}</code></pre>还需要注意的是，Button会抢夺ListView的焦点，需要将Button设置为没有焦点。设置非常简单，只需要在xml的Button标签下加入一行：android:focusable=“false”代码就可以了。<br>代码中getView()方法不容易理解。其实完全可以不用所谓的convertView和ViewHolder，直接导入布局并且设置控件显示的内容就可以了。但是这意味着有多少行数据就需要绘制多少行ListView，这显然是不可取的。这里采用了一种优化的方法。代码中，在getView()方法中加入了一行log输出convertView的内容。滚动ListView。<br>当启动Activity呈现第一屏ListView的时候，convertView为零。当用户向下滚动ListView时，上面的条目变为不可见，下面出现新的条目。这时候convertView不再为空，而是创建了一系列的convertView的值。当又往下滚一屏的时候，发现第11行的容器用来容纳第22行，第12行的容器用来容纳第23行。也就是说convertView相当于一个缓存，开始为0，当有条目变为不可见，它缓存了它的数据，后面再出来的条目只需要更新数据就可以了，这样大大节省了系统资料的开销。<br>还可以继续优化。虽然重复利用了已经绘制的view，但是要得到其中的控件，需要在控件的容器中通过findViewById的方法来获得。如果这个容器非常复杂，这显然会增加系统资源的开销。在上面的例子中，引入了Tag的概念。或许不是最好的办法，但是它确实能使ListView变得更流畅。代码中，当convertView为空时，用setTag()方法为每个View绑定一个存放控件的ViewHolder对象。当convertView不为空，重复利用已经创建的view的时候，使用getTag()方法获取绑定的ViewHolder对象，这样就避免了findViewById对控件的层层查询，而是快速定位到控件。<br>总结一下，这节介绍了用BaseAdapter来绑定ListView的数据。因为BaseAdapter非常灵活，使用也相对较其他控件麻烦。同时ListView的优化问题也值得读者去研究，一个流畅的ListView会带来更好的用户体验。</li></ul><h3 id="2-4-SimpleCursorAdapter："><a href="#2-4-SimpleCursorAdapter：" class="headerlink" title="2.4 SimpleCursorAdapter："></a>2.4 SimpleCursorAdapter：</h3><p>在SQLite中使用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熬过无人问津的日子，才有诗和远方</title>
      <link href="/2020/07/06/diary-20200706/"/>
      <url>/2020/07/06/diary-20200706/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/644219926.jpg" alt=""></p><center>推开世界的门</center><center>你是站在门外最孤单的人</center><center>捧着一颗不懂计较的认真</center><center>路过你的时候 时间多残忍</center><center>左手的泥呀 右手的泥呀</center><center>多泪的花衣裳</center><center>世界本该是你醒来的模样</center><center>左眼的悲伤 右眼的倔强</center><center>看起来都一样</center><center>原来你就是我自负的胆量</center><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BLE学习笔记3-BLE广播数据解析</title>
      <link href="/2020/07/05/diary-20200705-3/"/>
      <url>/2020/07/05/diary-20200705-3/</url>
      
        <content type="html"><![CDATA[<p>BLE设备工作的第一步就是向外广播数据。广播数据中带有设备相关的信息。本文主要说一下 BLE 的广播中的数据的规范以及广播包的解析。</p><h2 id="一、广播模式"><a href="#一、广播模式" class="headerlink" title="一、广播模式"></a>一、广播模式</h2><p>BLE 中有两种角色 Central 和 Peripheral ，也就是中心设备和外围设备。中心设备可以主动连接外围设备，外围设备发送广播或者被中心设备连接。外围通过广播被中心设备发现，广播中带有外围设备自身的相关信息。<br>广播包有两种： 广播包 （Advertising Data）和 响应包 （Scan Response），其中广播包是每个设备必须广播的，而响应包是可选的。 数据包的格式如下图所示<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/data_format.jpg" alt="数据包格式"><br>每个包都是 31 字节，数据包中分为有效数据（significant）和无效数据（non-significant）两部分。</p><ul><li>有效数据部分：包含若干个广播数据单元，称为 AD Structure。如图中所示，AD Structure 的组成是：第一个字节是长度值 Len，表示接下来的 Len 个字节是数据部分。数据部分的第一个字节表示数据的类型 AD Type，剩下的 Len - 1 个字节是真正的数据 AD data。其中 AD type 非常关键，决定了 AD Data 的数据代表的是什么和怎么解析，这个在《BLE学习笔记1-Android开发前言》里详细讲；</li><li>无效数据部分 ：因为广播包的长度必须是 31 个 byte，如果有效数据部分不到 31 自己，剩下的就用 0 补全。这部分的数据是无效的，解释的时候，忽略即可。<h2 id="二、广播数据解析"><a href="#二、广播数据解析" class="headerlink" title="二、广播数据解析"></a>二、广播数据解析</h2>在 Android 可以使用 BluetoothAdapter 来发起扫描。基本用法如下：<pre><code>BluetoothAdapter.LeScanCallback mLeScanCallback =    new BluetoothAdapter.LeScanCallback() {      @Override      public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) {          // 解析广播数据          parseAdvData(scanRecord);      }  };</code></pre></li></ul><p>mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();<br>// 开始扫描设备<br>mBluetoothAdapter.startLeScan(mLeScanCallback);<br>…<br>// 停止扫描设备<br>mBluetoothAdapter.stopLeScan(mLeScanCallback);  </p><pre><code>当扫描到设备以后，就会回调 onLeScan(...)，这里的参数 scanRecord 就是广播数据，这里同时包含广播数据和扫描相应数据（如果有的话），所以长度一般就是 62 字节。据上一节的广播数据格式的说明，可以实现解析广播数据函数 parseAdvData(scanRecord);，下面的代码实现了解析几个我关心的数据：</code></pre><p>public static ParsedAd parseData(byte[] adv_data) {<br>    ParsedAd parsedAd = new ParsedAd();<br>    ByteBuffer buffer = ByteBuffer.wrap(adv_data).order(ByteOrder.LITTLE_ENDIAN);<br>    while (buffer.remaining() &gt; 2) {<br>        byte length = buffer.get();<br>        if (length == 0)<br>            break;</p><pre><code>    byte type = buffer.get();    length -= 1;    switch (type) {        case 0x01: // Flags            parsedAd.flags = buffer.get();            length--;            break;        case 0x02: // Partial list of 16-bit UUIDs        case 0x03: // Complete list of 16-bit UUIDs        case 0x14: // List of 16-bit Service Solicitation UUIDs            while (length &gt;= 2) {                parsedAd.uuids.add(UUID.fromString(String.format(                        "%08x-0000-1000-8000-00805f9b34fb", buffer.getShort())));                length -= 2;            }            break;        case 0x04: // Partial list of 32 bit service UUIDs        case 0x05: // Complete list of 32 bit service UUIDs            while (length &gt;= 4) {                parsedAd.uuids.add(UUID.fromString(String.format(                        "%08x-0000-1000-8000-00805f9b34fb", buffer.getInt())));                length -= 4;            }            break;        case 0x06: // Partial list of 128-bit UUIDs        case 0x07: // Complete list of 128-bit UUIDs        case 0x15: // List of 128-bit Service Solicitation UUIDs            while (length &gt;= 16) {                long lsb = buffer.getLong();                long msb = buffer.getLong();                parsedAd.uuids.add(new UUID(msb, lsb));                length -= 16;            }            break;        case 0x08: // Short local device name        case 0x09: // Complete local device name            byte sb[] = new byte[length];            buffer.get(sb, 0, length);            length = 0;            parsedAd.localName = new String(sb).trim();            break;                        case (byte) 0xFF: // Manufacturer Specific Data            parsedAd.manufacturer = buffer.getShort();            length -= 2;            break;        default: // skip            break;    }    if (length &gt; 0) {        buffer.position(buffer.position() + length);    }}return parsedAd;</code></pre><p>}</p><pre><code>其中 ParsedAd 是自定义的简单 Java 对象，用来保存解析后的数据。这里只是解析了我关心的数据，你也可以根据前面的说明，解析更多的内容。## 三、参考资料- [蓝牙官方文档](https://www.bluetooth.org/en-us/specification/adopted-specifications)- [GAP Advertising and Scan Response Data format](https://devzone.nordicsemi.com/documentation/nrf51/4.2.0/html/group___b_l_e___g_a_p___a_d___t_y_p_e___d_e_f_i_n_i_t_i_o_n_s.html)- [Parsing BLE Advertisement packets](http://www.sfonge.com/forum/topic/parsing-ble-advertisement-packets)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BLE学习笔记2-GATT Profile简介</title>
      <link href="/2020/07/05/diary-20200705-2/"/>
      <url>/2020/07/05/diary-20200705-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>BLE低功耗蓝牙（Bluetooth Low Energy）连接都是建立在 GATT (Generic Attribute Profile) 协议之上。GATT 是一个在蓝牙连接之上的发送和接收很短的数据段的通用规范，这些很短的数据段被称为属性（Attribute）。</p><h2 id="二、GAP"><a href="#二、GAP" class="headerlink" title="二、GAP"></a>二、GAP</h2><p>详细介绍 GATT 之前，需要了解 GAP（Generic Access Profile），它在用来控制设备连接和广播。GAP 使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互。例如 Beacon 设备就只是向外广播，不支持连接，小米手环就等设备就可以与中心设备连接。</p><h3 id="2-1-设备角色"><a href="#2-1-设备角色" class="headerlink" title="2.1 设备角色"></a>2.1 设备角色</h3><p>GAP 给设备定义了若干角色，其中主要的两个是：外围设备（Peripheral）和中心设备（Central）。</p><ul><li>外围设备：这一般就是非常小或者简单的低功耗设备，用来提供数据，并连接到一个更加相对强大的中心设备。例如小米手环。</li><li>中心设备：中心设备相对比较强大，用来连接其他外围设备。例如手机等。<h3 id="2-2-广播数据"><a href="#2-2-广播数据" class="headerlink" title="2.2 广播数据"></a>2.2 广播数据</h3>在 GAP 中外围设备通过两种方式向外广播数据： Advertising Data Payload（广播数据）和 Scan Response Data Payload（扫描回复），每种数据最长可以包含 31 byte。这里广播数据是必需的，因为外设必需不停的向外广播，让中心设备知道它的存在。扫描回复是可选的，中心设备可以向外设请求扫描回复，这里包含一些设备额外的信息，例如设备的名字。<h3 id="2-3-广播流程"><a href="#2-3-广播流程" class="headerlink" title="2.3 广播流程"></a>2.3 广播流程</h3>GAP 的广播工作流程如下图所示。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GAP_adv_proc.jpg" alt="GAP的广播工作流程"><br>从图中我们可以清晰看出广播数据和扫描回复数据是怎么工作的。外围设备会设定一个广播间隔，每个广播间隔中，它会重新发送自己的广播数据。广播间隔越长，越省电，同时也不太容易扫描到。<h3 id="2-4-广播的网络拓扑结构"><a href="#2-4-广播的网络拓扑结构" class="headerlink" title="2.4 广播的网络拓扑结构"></a>2.4 广播的网络拓扑结构</h3>大部分情况下，外设通过广播自己来让中心设备发现自己，并建立 GATT 连接，从而进行更多的数据交换。也有些情况是不需要连接的，只要外设广播自己的数据即可。用这种方式主要目的是让外围设备，把自己的信息发送给多个中心设备。因为基于 GATT 连接的方式的，只能是一个外设连接一个中心设备。 使用广播这种方式最典型的应用就是苹果的 iBeacon。广播工作模式下的网络拓扑图如下：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GAP_BroadcastTopology.jpg" alt="广播工作模式网络拓扑图"><h2 id="三、GATT"><a href="#三、GATT" class="headerlink" title="三、GATT"></a>三、GATT</h2>GATT 的全名是 Generic Attribute Profile（姑且翻译成：普通属性协议），它定义两个东西(Service和Characteristic)用于BLE设备的通信。GATT使用ATT（Attribute Protocol）协议，把 Service, Characteristic对应的数据保存在一个查找表中，次查找表使用 16 bit ID 作为每一项的索引。<br>一旦两个设备建立起了连接，GATT 就开始起作用了，这也意味着，你必需完成前面的 GAP 协议。这里需要说明的是，GATT 连接，必需先经过 GAP 协议。实际上，我们在 Android 开发中，可以直接使用设备的 MAC 地址，发起连接，可以不经过扫描的步骤。这并不意味不需要经过 GAP，实际上在芯片级别已经给你做好了，蓝牙芯片发起连接，总是先扫描设备，扫描到了才会发起连接。<br>GATT 连接需要特别注意的是：<code>GATT 连接是独占的</code>。也就是一个 BLE 外设同时只能被一个中心设备连接。一旦外设被连接，它就会马上停止广播，这样它就对其他设备不可见了。当设备断开，它又开始广播。<br>中心设备和外设需要双向通信的话，唯一的方式就是建立 GATT 连接。<h3 id="3-1-GATT连接的网络拓扑"><a href="#3-1-GATT连接的网络拓扑" class="headerlink" title="3.1 GATT连接的网络拓扑"></a>3.1 GATT连接的网络拓扑</h3>下图展示了 GTT 连接网络拓扑结构。这里很清楚的显示，一个外设只能连接一个中心设备，而一个中心设备可以连接多个外设。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GATT_network_topology.jpg" alt="GATT连接的网络拓扑"><br>一旦建立起了连接，通信就是双向的了，对比前面的 GAP 广播的网络拓扑，GAP 通信是单向的。如果你要让两个设备外设能通信，就只能通过中心设备中转。<h3 id="3-2-GATT-通信事务"><a href="#3-2-GATT-通信事务" class="headerlink" title="3.2 GATT 通信事务"></a>3.2 GATT 通信事务</h3>GATT 通信的双方是 C/S 关系。外设作为 GATT 服务端（Server），它维持了 ATT 的查找表以及 service 和 characteristic 的定义。中心设备是 GATT 客户端（Client），它向 Server 发起请求。需要注意的是，所有的通信事件，都是由客户端（也叫主设备，Master）发起，并且接收服务端（也叫从设备，Slave）的响应。<br>一旦连接建立，外设将会给中心设备建议一个连接间隔（Connection Interval）,这样，中心设备就会在每个连接间隔尝试去重新连接，检查是否有新的数据。但是，这个连接间隔只是一个建议，你的中心设备可能并不会严格按照这个间隔来执行，例如你的中心设备正在忙于连接其他的外设，或者中心设备资源太忙。<br>下图展示一个外设（GATT 服务端）和中心设备（GATT 客户端）之间的数据交换流程，可以看到的是，每次都是主设备发起请求：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GATT_MasterSlaveTransactions.jpg" alt="外设与中心设备数据交换"><h3 id="3-3-GATT结构"><a href="#3-3-GATT结构" class="headerlink" title="3.3 GATT结构"></a>3.3 GATT结构</h3>GATT 通信事务是建立在嵌套的Profiles, Services 和 Characteristics之上的的，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GATT_Structure.jpg" alt="GATT结构"></li><li><code>Profile</code> Profile 并不是实际存在于 BLE 外设上的，它只是一个被 Bluetooth SIG 或者外设设计者预先定义的 Service 的集合。例如心率Profile（Heart Rate Profile）就是结合了 Heart Rate Service 和 Device Information Service。所有官方通过 GATT Profile 的列表可以从<a href="http://developer.bluetooth.org/TechnologyOverview/Pages/Profiles.aspx#GATT" target="_blank" rel="noopener">这里</a>找到。 </li><li><code>Service</code> Service 是把数据分成一个个的独立逻辑项，它包含一个或者多个 Characteristic。每个 Service 有一个 UUID 唯一标识。 UUID 有 16 bit 的，或者 128 bit 的。16 bit 的 UUID 是官方通过认证的，需要花钱购买，128 bit 是自定义的，这个就可以自己随便设置。<br>官方通过了一些标准 Service，完整列表在<a href="https://developer.bluetooth.org/gatt/services/Pages/ServicesHome.aspx" target="_blank" rel="noopener">这里</a>。以 Heart Rate Service为例，可以看到它的官方通过 16 bit UUID 是 0x180D，包含 3 个 Characteristic：Heart Rate Measurement, Body Sensor Location 和 Heart Rate Control Point，并且定义了只有第一个是必须的，它是可选实现的。</li><li><code>Characteristic</code> 在 GATT 事务中的最低界别的是 Characteristic，Characteristic 是最小的逻辑数据单元，当然它可能包含一个组关联的数据，例如加速度计的 X/Y/Z 三轴值。<br>与 Service 类似，每个 Characteristic 用 16 bit 或者 128 bit 的 UUID 唯一标识。你可以免费使用 Bluetooth SIG 官方定义的标准 Characteristic，使用官方定义的，可以确保 BLE 的软件和硬件能相互理解。当然，你可以自定义 Characteristic，这样的话，就只有你自己的软件和外设能够相互理解。<br>实际上，和 BLE 外设打交道，主要是通过 Characteristic。你可以从 Characteristic 读取数据，也可以往 Characteristic 写数据。这样就实现了双向的通信。所以你可以自己实现一个类似串口（UART）的 Sevice，这个 Service 中包含两个 Characteristic，一个被配置只读的通道（RX），另一个配置为只写的通道（TX）。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BLE学习笔记1-Android开发前言</title>
      <link href="/2020/07/05/diary-20200705-1/"/>
      <url>/2020/07/05/diary-20200705-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、相关介绍"><a href="#一、相关介绍" class="headerlink" title="一、相关介绍"></a>一、相关介绍</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><p>本文主要描述Android BLE的一些基础知识及相关操作流程，不牵扯具体的业务实现，其中提供了针对广播包及响应包的解析思路。<br>蓝牙的创始公司是爱立信。1994年爱立信开始对小范围无线通信技术进行研发，在1997年，爱立信的研究激发了其他公司的浓厚兴趣，于是1998年2月，一些跨国大公司包括诺基亚、苹果、三星组成的一个特殊兴趣小组（SIG），他们共同的目标是建立一个全球性的小范围无线通信技术，该项技术就是蓝牙。</p><p>蓝牙无线技术是一种全球通用的短距离无线技术，通过蓝牙技术能够实现多种电子设备间的相互连接，特别是在小型无线电、耗电量低、成本低、安全性、稳定性、易用性以及特别的联网能力等固有的优势上，蓝牙无线技术发展迅速。</p><h3 id="1-2分类"><a href="#1-2分类" class="headerlink" title="1.2分类"></a>1.2分类</h3><p>蓝牙分为三种：Bluetooth Smart Ready、Bluetooth Smart（Smart是低功耗蓝牙的标识）、以及标准 Bluetooth。根据 Bluetooth SIG的说法，这样是为了要分辨装置间的相容性以及标识各版本的传输频率。基本上来说，Bluetooth Smart Ready适用于任何双模蓝牙4.0的电子产品,而Bluetooth Smart是应用在心率监视器或计步器等使用扭扣式电池并传输单一的装置。Bluetooth Smart Ready的相容性最高，可与Bluetooth Smart及标准蓝牙相通。标准蓝牙则无法与Bluetooth Smart相通。</p><h3 id="1-3BLE分类"><a href="#1-3BLE分类" class="headerlink" title="1.3BLE分类"></a>1.3BLE分类</h3><p>BLE是Bluetooth Low Energy的缩写，又叫蓝牙4.0，区别于蓝牙3.0和之前的技术。BLE前身是NOKIA开发的Wibree技术，主要用于实现移动智能终端与周边配件之间的持续连接，是功耗极低的短距离无线通信技术，并且有效传输距离被提升到了100米以上，同时只需要一颗纽扣电池就可以工作数年之久。BLE是在蓝牙技术的基础上发展起来的，既同于蓝牙，又区别于传统蓝牙。BLE设备分单模和双模两种，双模简称BR，商标为Bluetooth Smart Ready，单模简称BLE或者LE,商标为Bluetooth Smart。Android是在4.3后才支持BLE，这说明不是所有蓝牙手机都支持BLE，而且支持BLE的蓝牙手机一般是双模的。双模兼容传统蓝牙，可以和传统蓝牙通信，也可以和BLE通信，常用在手机上，android4.3和IOS4.0之后版本都支持BR，也就是双模设备。单模只能和BR和单模的设备通信，不能和传统蓝牙通信，由于功耗低，待机长，所以常用在手环的智能设备上。</p><h3 id="1-4蓝牙的工作原理"><a href="#1-4蓝牙的工作原理" class="headerlink" title="1.4蓝牙的工作原理"></a>1.4蓝牙的工作原理</h3><h4 id="1-4-1-蓝牙通信的主从关系"><a href="#1-4-1-蓝牙通信的主从关系" class="headerlink" title="1.4.1 蓝牙通信的主从关系"></a>1.4.1 蓝牙通信的主从关系</h4><p>蓝牙技术规定每一对设备之间进行蓝牙通讯时，必须一个为主角色，另一为从角色，才能进行通信，通信时，必须由主端进行查找，发起配对，建链成功后，双方即可收发数据。理论上，一个蓝牙主端设备，可同时与7个蓝牙从端设备进行通讯。一个具备蓝牙通讯功能的设备，可以在两个角色间切换，平时工作在从模式，等待其它主设备来连接，需要时，转换为主模式，向其它设备发起呼叫。一个蓝牙设备以主模式发起呼叫时，需要知道对方的蓝牙地址，配对密码等信息，配对完成后，可直接发起呼叫。这可以解释为什么有时无法连接蓝牙，有可能是连接的蓝牙设备过多。</p><h4 id="1-4-2-蓝牙的呼叫过程"><a href="#1-4-2-蓝牙的呼叫过程" class="headerlink" title="1.4.2 蓝牙的呼叫过程"></a>1.4.2 蓝牙的呼叫过程</h4><p>蓝牙主端设备发起呼叫，首先是查找，找出周围处于可被查找的蓝牙设备。主端设备找到从端蓝牙设备后，与从端蓝牙设备进行配对，此时需要输入从端设备的PIN码，也有设备不需要输入PIN码。配对完成后，从端蓝牙设备会记录主端设备的信任信息，此时主端即可向从端设备发起呼叫，已配对的设备在下次呼叫时，不再需要重新配对。已配对的设备，做为从端的蓝牙耳机也可以发起建链请求，但做数据通讯的蓝牙模块一般不发起呼叫。链路建立成功后，主从两端之间即可进行双向的数据或语音通讯。在通信状态下，主端和从端设备都可以发起断链，断开蓝牙链路。</p><h4 id="1-4-3-蓝牙一对一的串口数据传输应用"><a href="#1-4-3-蓝牙一对一的串口数据传输应用" class="headerlink" title="1.4.3 蓝牙一对一的串口数据传输应用"></a>1.4.3 蓝牙一对一的串口数据传输应用</h4><p>蓝牙数据传输应用中，一对一串口数据通讯是最常见的应用之一，蓝牙设备在出厂前即提前设好两个蓝牙设备之间的配对信息，主端预存有从端设备的PIN码、地址等，两端设备加电即自动建链，透明串口传输，无需外围电路干预。一对一应用中从端设备可以设为两种类型，一是静默状态，即只能与指定的主端通信，不被别的蓝牙设备查找；二是开发状态，既可被指定主端查找，也可以被别的蓝牙设备查找建链。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><h3 id="2-1-Generic-Access-Profile-GAP"><a href="#2-1-Generic-Access-Profile-GAP" class="headerlink" title="2.1 Generic Access Profile(GAP)"></a>2.1 Generic Access Profile(GAP)</h3><p>用来控制设备连接和广播，GAP使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互。    </p><h3 id="2-2-Generic-Attribute-Profile-GATT"><a href="#2-2-Generic-Attribute-Profile-GATT" class="headerlink" title="2.2 Generic Attribute Profile(GATT)"></a>2.2 Generic Attribute Profile(GATT)</h3><p>通过BLE连接，读写属性类数据的Profile通用规范，现在所有的BLE应用Profile都是基于GATT的。     </p><h3 id="2-3-Attribute-Protocol-ATT"><a href="#2-3-Attribute-Protocol-ATT" class="headerlink" title="2.3 Attribute Protocol (ATT)"></a>2.3 Attribute Protocol (ATT)</h3><p>GATT是基于ATTProtocol的，ATT针对BLE设备做了专门的优化，具体就是在传输过程中使用尽量少的数据，每个属性都有一个唯一的UUID，属性将以characteristics and services的形式传输。    </p><h3 id="2-4-Characteristic"><a href="#2-4-Characteristic" class="headerlink" title="2.4 Characteristic"></a>2.4 Characteristic</h3><p>Characteristic可以理解为一个数据类型，它包括一个value和0至多个对次value的描述（Descriptor）。</p><h3 id="2-5-Descriptor"><a href="#2-5-Descriptor" class="headerlink" title="2.5 Descriptor"></a>2.5 Descriptor</h3><p>对Characteristic的描述，例如范围、计量单位等。</p><h3 id="2-6-Service"><a href="#2-6-Service" class="headerlink" title="2.6 Service"></a>2.6 Service</h3><p>Characteristic的集合。例如一个service叫做“Heart Rate Monitor”，它可能包含多个Characteristics，其中可能包含一个叫做“heart ratemeasurement”的Characteristic。 </p><h3 id="2-7-UUID"><a href="#2-7-UUID" class="headerlink" title="2.7 UUID"></a>2.7 UUID</h3><p>唯一标示符，每个Service，Characteristic，Descriptor，都是由一个UUID定义。</p><h3 id="2-8-角色和职责"><a href="#2-8-角色和职责" class="headerlink" title="2.8 角色和职责"></a>2.8 角色和职责</h3><p>Android设备与BLE设备交互有两组角色</p><ul><li>中心设备和外围设备（Central vs. peripheral）</li></ul><p>Central角色负责scan advertisement。而peripheral角色负责make advertisement。<br>这两种角色取决于BLE连接成功后，两个设备间通信的方式。<br>现有一个活动追踪的BLE设备和一个支持BLE的Android设备。Android设备支持Central角色，而BLE设备支持peripheral角色。创建一个BLE连接需要这两个角色都存在，都仅支持Central角色或者都仅支持peripheral角色则无法建立连接。<br>当连接建立后，它们之间就需要传输GATT数据。谁做server，谁做client，则取决于具体数据传输的情况。例如，如果活动追踪的BLE设备需要向 Android设备传输sensor数据，则活动追踪器自然成为了server端；而如果活动追踪器需要从Android设备获取更新信息，则 Android设备作为server端可能更合适。</p><h3 id="2-9-权限及feature"><a href="#2-9-权限及feature" class="headerlink" title="2.9 权限及feature"></a>2.9 权限及feature</h3><p>和经典蓝牙一样，应用使用蓝牙，需要声明BLUETOOTH权限，如果需要扫描设备或者操作蓝牙设置，则还需要BLUETOOTH_ADMIN权限：</p><pre><code>&lt;uses-permissionandroid:name="android.permission.BLUETOOTH"/&gt;&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/&gt;</code></pre><p>除了蓝牙权限外，如果需要BLE feature则还需要声明uses-feature：</p><pre><code>&lt;uses-featureandroid:name="android.hardware.bluetooth_le"android:required="true"/&gt;</code></pre><p>按时required为true时，则应用只能在支持BLE的Android设备上安装运行；required为false时，Android设备均可正常安装运行，需要在代码运行时判断设备是否支持BLE feature：</p><pre><code>// Use this check to determine whether BLE is supportedon the device. Then// you can selectively disable BLE-related features.if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)){    Toast.makeText(this, R.string.ble_not_supported,Toast.LENGTH_SHORT).show();    finish();}</code></pre><h2 id="三、Android-BLE-API"><a href="#三、Android-BLE-API" class="headerlink" title="三、Android BLE API"></a>三、Android BLE API</h2><h3 id="3-1-BluetoothGatt"><a href="#3-1-BluetoothGatt" class="headerlink" title="3.1 BluetoothGatt"></a>3.1 BluetoothGatt</h3><p>继承BluetoothProfile，通过BluetoothGatt可以连接设备（connect）,发现服务（discoverServices），并把相应地属性返回到BluetoothGattCallback，可以看成蓝牙设备从连接到断开的生命周期。</p><h3 id="3-2-BluetoothGattCharacteristic"><a href="#3-2-BluetoothGattCharacteristic" class="headerlink" title="3.2 BluetoothGattCharacteristic"></a>3.2 BluetoothGattCharacteristic</h3><p>相当于一个数据类型，可以看成一个特征或能力，它包括一个value和0~n个value的描述（BluetoothGattDescriptor）。</p><h3 id="3-3-BluetoothGattDescriptor"><a href="#3-3-BluetoothGattDescriptor" class="headerlink" title="3.3 BluetoothGattDescriptor"></a>3.3 BluetoothGattDescriptor</h3><p>描述符，对Characteristic的描述，包括范围、计量单位等。</p><h3 id="3-4-BluetoothGattService"><a href="#3-4-BluetoothGattService" class="headerlink" title="3.4 BluetoothGattService"></a>3.4 BluetoothGattService</h3><p>服务，Characteristic的集合。</p><h3 id="3-5-BluetoothProfile"><a href="#3-5-BluetoothProfile" class="headerlink" title="3.5 BluetoothProfile"></a>3.5 BluetoothProfile</h3><p>一个通用的规范，按照这个规范来收发数据。 </p><h3 id="3-6-BluetoothManager"><a href="#3-6-BluetoothManager" class="headerlink" title="3.6 BluetoothManager"></a>3.6 BluetoothManager</h3><p>通过BluetoothManager来获取BluetoothAdapter。</p><pre><code>BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);</code></pre><h3 id="3-7-BluetoothAdapter"><a href="#3-7-BluetoothAdapter" class="headerlink" title="3.7 BluetoothAdapter"></a>3.7 BluetoothAdapter</h3><p>代表了移动设备的本地的蓝牙适配器, 通过该蓝牙适配器可以对蓝牙进行基本操作，一个Android系统只有一个BluetoothAdapter，通过BluetoothManager获取。</p><pre><code>BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();</code></pre><h3 id="3-8-BluetoothDevice"><a href="#3-8-BluetoothDevice" class="headerlink" title="3.8 BluetoothDevice"></a>3.8 BluetoothDevice</h3><p>扫描后发现可连接的设备，获取已经连接的设备。 </p><pre><code>BluetoothDevice bluetoothDevice = bluetoothAdapter.getRemoteDevice(address);</code></pre><h3 id="3-9-BluetoothGattCallback"><a href="#3-9-BluetoothGattCallback" class="headerlink" title="3.9 BluetoothGattCallback"></a>3.9 BluetoothGattCallback</h3><p>已经连接上设备，对设备的某些操作后返回的结果。 </p><pre><code>BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback(){    //实现回调方法，根据业务做相应处理};BluetoothGatt bluetoothGatt = bluetoothDevice.connectGatt(this, false, bluetoothGattCallback);</code></pre><h2 id="四、操作流程"><a href="#四、操作流程" class="headerlink" title="四、操作流程"></a>四、操作流程</h2><h3 id="4-1-开启蓝牙"><a href="#4-1-开启蓝牙" class="headerlink" title="4.1 开启蓝牙"></a>4.1 开启蓝牙</h3><p>在使用蓝牙BLE之前，需要确认Android设备是否支持BLE feature(required为false时)，另外要需要确认蓝牙是否打开。如果发现不支持BLE，则不能使用BLE相关的功能；如果支持BLE，但是蓝牙没打开，则需要打开蓝牙。代码示例如下：</p><pre><code>//是否支持蓝牙模块@TargetApi(18)public static boolean isSupportBle(Context context) {    if(context != null &amp;&amp; context.getPackageManager().hasSystemFeature("android.hardware.bluetooth_le")) {        BluetoothManager manager = (BluetoothManager)context.getSystemService("bluetooth");        return manager.getAdapter() != null;    } else {        return false;    }}//是否开启蓝牙@TargetApi(18)public static boolean isBleEnable(Context context) {    if(!isSupportBle(context)) {        return false;    } else {        BluetoothManager manager = (BluetoothManager)context.getSystemService("bluetooth");        return manager.getAdapter().isEnabled();    }}//开启蓝牙public static void enableBle(Activity act, int requestCode) {    Intent mIntent = new Intent("android.bluetooth.adapter.action.REQUEST_ENABLE");    act.startActivityForResult(mIntent, requestCode);}//蓝牙开启过程if(isSupportBle(mContext)){    //支持蓝牙模块    if(!isBleEnable(mContext)){        //没开启蓝牙则开启        enableBle(mSelfActivity, 1);    }} else{    //不支持蓝牙模块处理}//蓝牙开启回调@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {    //判断requestCode是否为开启蓝牙时传进去的值，再做相应处理    if(requestCode == 1){        //蓝牙开启成功后的处理    }    super.onActivityResult(requestCode, resultCode, data);}</code></pre><h3 id="4-2-设备搜索"><a href="#4-2-设备搜索" class="headerlink" title="4.2 设备搜索"></a>4.2 设备搜索</h3><ul><li><p>BluetoothAdapter.startDiscovery在大多数手机上是可以同时发现经典蓝牙和Ble的，但是startDiscovery的回调无法返回Ble的广播，所以无法通过广播识别设备，且startDiscovery扫描Ble的效率比StartLeScan低很多。所以在实际应用中，还是StartDiscovery和StartLeScan分开扫，前者扫传统蓝牙，后者扫低功耗蓝牙。</p></li><li><p>由于搜索需要尽量减少功耗，因此在实际使用时需要注意：当找到对应的设备后，立即停止扫描；不要循环搜索设备，为每次搜索设置适合的时间限制，避免设备不在可用范围的时候持续不停扫描，消耗电量。 </p></li><li><p>通过调用BluetoothAdapter的 startLeScan() 搜索BLE设备。调用此方法时需要传入 BluetoothAdapter.LeScanCallback 参数。具体代码示例如下：</p><pre><code>BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();bluetoothAdapter.startLeScan(new BluetoothAdapter.LeScanCallback() {  @Override  public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {      //对扫描到的设备进行处理，可以依据BluetoothDevice中的信息、信号强度rssi以及广播包和响应包组成的scanRecord字节数组进行分析  }});</code></pre><h3 id="4-3-设备通信"><a href="#4-3-设备通信" class="headerlink" title="4.3 设备通信"></a>4.3 设备通信</h3><p>两个设备通过BLE通信，首先需要建立GATT连接，这里我们讲的是Android设备作为client端，连接GATT Server。连接GATT Server，需要调用BluetoothDevice的connectGatt()方法，此函数带三个参数：Context、autoConnect(boolean)和 BluetoothGattCallback 对象。调用后返回BluetoothGatt对象，它是GATT profile的封装，通过这个对象，我们就能进行GATT Client端的相关操作。如断开连接<code>bluetoothGatt.disconnect()</code>，发现服务 <code>bluetoothGatt.discoverServices()</code> 等等。示例代码如下： </p><pre><code>BluetoothDevice bluetoothDevice = bluetoothAdapter.getRemoteDevice(address);BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback(){  @Override  public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {      super.onConnectionStateChange(gatt, status, newState);  }  @Override  public void onServicesDiscovered(BluetoothGatt gatt, int status) {      super.onServicesDiscovered(gatt, status);  }  @Override  public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {      super.onCharacteristicRead(gatt, characteristic, status);  }  @Override  public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {      super.onCharacteristicWrite(gatt, characteristic, status);  }  @Override  public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {      super.onCharacteristicChanged(gatt, characteristic);  }  @Override  public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {      super.onDescriptorRead(gatt, descriptor, status);  }  @Override  public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {      super.onDescriptorWrite(gatt, descriptor, status);  }  @Override  public void onReliableWriteCompleted(BluetoothGatt gatt, int status) {      super.onReliableWriteCompleted(gatt, status);  }  @Override  public void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) {      super.onReadRemoteRssi(gatt, rssi, status);  }  @Override  public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) {      super.onMtuChanged(gatt, mtu, status);  }};BluetoothGatt bluetoothGatt = bluetoothDevice.connectGatt(this, false, bluetoothGattCallback);</code></pre></li></ul><p>//以下为获得Gatt后的相关操作对应的响应方法<br>//notification to onCharacteristicChanged；<br>bluetoothGatt.setCharacteristicNotification(characteristic, true);</p><p>//readCharacteristic to onCharacteristicRead；<br>bluetoothGatt.readCharacteristic(characteristic);</p><p>//writeCharacteristic to onCharacteristicWrite；<br>bluetoothGatt.wirteCharacteristic(mCurrentcharacteristic);</p><p>//connect and disconnect to onConnectionStateChange；<br>bluetoothGatt.connect();<br>bluetoothGatt.disconnect();</p><p>//readDescriptor to onDescriptorRead；<br>bluetoothGatt.readDescriptor(descriptor);</p><p>//writeDescriptor to onDescriptorWrite；<br>bluetoothGatt.writeDescriptor(descriptor);</p><p>//readRemoteRssi to onReadRemoteRssi；<br>bluetoothGatt.readRemoteRssi();</p><p>//executeReliableWrite to onReliableWriteCompleted；<br>bluetoothGatt.executeReliableWrite();</p><p>//discoverServices to onServicesDiscovered;<br>bluetoothGatt.discoverServices();</p><pre><code>### 4.4 数据解析 - BLE中有两种角色Central和Peripheral，也就是中心设备和外围设备，中心设备可以主动连接外围设备，外围设备发送广播或者被中心设备连接，外围通过广播被中心设备发现，广播中带有外围设备自身的相关信息。- 数据包有两种：广播包（Advertising Data）和响应包（Scan Response），其中广播包是每个设备必须广播的，而响应包是可选的。![数据包格式](https://gitee.com/seanzs/pic/raw/master/img/data_format.jpg)数据包的格式为每个包都是 31 字节，数据包中分为有效数据（significant）和无效数据（non-significant）两部分。- 有效数据部分：包含若干个广播数据单元，称为AD Structure。如图中所示，AD Structure的组成是：第一个字节是长度值Len，表示接下来的Len个字节是数据部分。数据部分的第一个字节表示数据的类型AD Type，剩下的Len - 1个字节是真正的数据AD data。其中AD type非常关键，决定了AD Data的数据代表的是什么和怎么解析，这个在后面会详细讲；- 无效数据部分：因为广播包的长度必须是31字节，如果有效数据部分不到31字节，剩下的就用0补齐，这部分的数据是无效的，解析的时候，直接忽略即可。- 查看Nordic的SDK中的定义，AD type的定义在程序的“ble_gap.h”头文件中。定义如下：</code></pre><p>#define BLE_GAP_AD_TYPE_FLAGS                               0x01 //&lt; Flags for discoverability.<br>#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE   0x02 //&lt; Partial list of 16 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE         0x03 //&lt; Complete list of 16 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_MORE_AVAILABLE   0x04 //&lt; Partial list of 32 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_COMPLETE         0x05 //&lt; Complete list of 32 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE  0x06 //&lt; Partial list of 128 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE        0x07 //&lt; Complete list of 128 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME                    0x08 //&lt; Short local device name.<br>#define BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME                 0x09 //&lt; Complete local device name.<br>#define BLE_GAP_AD_TYPE_TX_POWER_LEVEL                      0x0A //&lt; Transmit power level.<br>#define BLE_GAP_AD_TYPE_CLASS_OF_DEVICE                     0x0D //&lt; Class of device.<br>#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C               0x0E //&lt; Simple Pairing Hash C.<br>#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R         0x0F //&lt; Simple Pairing Randomizer R.<br>#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_TK_VALUE           0x10 //&lt; Security Manager TK Value.<br>#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_OOB_FLAGS          0x11 //&lt; Security Manager Out Of Band Flags.<br>#define BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE     0x12 //&lt; Slave Connection Interval Range.<br>#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT       0x14 //&lt; List of 16-bit Service Solicitation UUIDs.<br>#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT      0x15 //&lt; List of 128-bit Service Solicitation UUIDs.<br>#define BLE_GAP_AD_TYPE_SERVICE_DATA                        0x16 //&lt; Service Data - 16-bit UUID.<br>#define BLE_GAP_AD_TYPE_PUBLIC_TARGET_ADDRESS               0x17 //&lt; Public Target Address.<br>#define BLE_GAP_AD_TYPE_RANDOM_TARGET_ADDRESS               0x18 //&lt; Random Target Address.<br>#define BLE_GAP_AD_TYPE_APPEARANCE                          0x19 //&lt; Appearance.<br>#define BLE_GAP_AD_TYPE_ADVERTISING_INTERVAL                0x1A //&lt; Advertising Interval.<br>#define BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS         0x1B //&lt; LE Bluetooth Device Address.<br>#define BLE_GAP_AD_TYPE_LE_ROLE                             0x1C //&lt; LE Role.<br>#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C256            0x1D //&lt; Simple Pairing Hash C-256.<br>#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R256      0x1E //&lt; Simple Pairing Randomizer R-256.<br>#define BLE_GAP_AD_TYPE_SERVICE_DATA_32BIT_UUID             0x20 //&lt; Service Data - 32-bit UUID.<br>#define BLE_GAP_AD_TYPE_SERVICE_DATA_128BIT_UUID            0x21 //&lt; Service Data - 128-bit UUID.<br>#define BLE_GAP_AD_TYPE_3D_INFORMATION_DATA                 0x3D //&lt; 3D Information Data.<br>#define BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA          0xFF //&lt; Manufacturer Specific Data.</p><pre><code>- 所有的 AD Type 的定义在文档[Core Specification Supplement](https://www.bluetooth.com/specifications/adopted-specifications)中，根据上面头文件中的定义，AD Type包括如下类型：- `Flags`     1. TYPE = 0x01： 这个数据用来标识设备 LE 物理连接的功能，DATA 是 0 到多个字节的 Flag 值，每个 bit 上用 0 或者 1 来表示是否为 True。如果有任何一个 bit 不为 0，并且广播包是可连接的，就必须包含此数据。各 bit 的定义如下：    ```    bit 0: LE有限发现模式    bit 1: LE普通发现模式    bit 2: 不支持BR/EDR    bit 3: 对Same Device Capable(Controller)同时支持BLE和BR/EDR    bit 4: 对Same Device Capable(Host)同时支持BLE和BR/EDR    bit 5..7: 预留    ```    - `Service UUID`广播数据中一般都会把设备支持的 GATT Service 广播出来，用来告诉外面本设备所支持的 Service。有三种类型的 UUID：16 bit, 32bit, 128 bit。广播中，每种类型类型有有两个类别：完整和非完整的。这样就共有 6 种 AD Type2. TYPE = 0x02：非完整的16 bit UUID列表3. TYPE = 0x03：完整的16 bit UUID列表4. TYPE = 0x04：非完整的32 bit UUID列表5. TYPE = 0x05：完整的32 bit UUID列表6. TYPE = 0x06：非完整的128 bit UUID列表7. TYPE = 0x07：完整的128 bit UUID列表 - `Local Name`设备名字，DATA 是名字的字符串。 Local Name 可以是设备的全名，也可以是设备名字的缩写，其中缩写必须是全名的前面的若干字符。     8. TYPE = 0x08：设备简称     9. TYPE = 0x09：设备全名 - `TX Power Leve`    10. TYPE = 0x0A：表示设备发送广播包的信号强度,DATA部分是一个字节，表示 -127 到 + 127 dBm。- `设备类别`    11. TYPE = 0x0D：设备类别- `设备配对的Hash值`    12. TYPE = 0x0E：设备配对的Hash值 - `设备配对的随机值`        13. TYPE = 0x0F：设备配对的随机值- `TK安全管理`    14. TYPE = 0x10：TK安全管理（Security Manager TK Value）- `带外安全管理`    15. TYPE = 0x11：带外安全管理（Security Manager Out of Band）,DATA 也是 Flag，每个 bit 表示一个功能：，各bit定义如下：    ```    bit 0: OOB Flag，0-表示没有OOB数据，1-表示有    bit 1: 支持LE    bit 2: 对Same Device Capable(Host)同时支持BLE和BR/EDR    bit 3: 地址类型，0-表示公开地址，1-表示随机地址    ```    - `外设（Slave）连接间隔范围`    16. TYPE = 0x12：外设（Slave）连接间隔范围，数据中定义了Slave最大和最小连接间隔，数据包含4个字节：前两字节定义最小连接间隔，取值范围：0x0006 ~ 0x0C80，而0xFFFF表示未定义；后两字节，定义最大连接间隔，取值范围同上，不过需要保证最大连接间隔大于或者等于最小连接间隔。- `服务搜寻` 外围设备可以要请中心设备提供相应的 Service。其数据定义和前面的 Service UUID 类似：    17. TYPE = 0x14：服务搜寻16 bit UUID列表    18. TYPE = 0x15：服务搜寻128 bit UUID列表    19. TYPE = 0x16：16 bit UUID Service，前两个字节是UUID，后面是Service的数据- `公开目标地址`     20. TYPE = 0x17：公开目标地址，表示希望这个广播包被指定的目标设备处理，此设备绑定了公开地址，DATA 是目标地址列表，每个地址 6 字节。- `随机目标地址`    21. TYPE = 0x18：随机目标地址，表示希望这个广播包被指定的目标设备处理，此设备绑定了随机地址，DATA 是目标地址列表，每个地址 6 字节。- `Appearance`    22. TYPE = 0x19：表示设备的外观 - `广播区间`    23. TYPE = 0x1A：广播区间- `LE设备地址`        24. TYPE = 0x1B：LE设备地址 - `LE设备角色`        25. TYPE = 0x1C：LE设备角色 - `256位设备配对的Hash值`        26. TYPE = 0x1D：256位设备配对的Hash值 - `256位设备配对的随机值`        27. TYPE = 0x1E：256位设备配对的随机值- `32bit UUID Service`            28. TYPE = 0x20：32 bit UUID Service，前4个字节是UUID，后面是Service的数据- `128bit UUID Service`        29. TYPE = 0x21：128 bit UUID Service，前16个字节是UUID，后面是Service的数据 - `3D信息数据`    30. TYPE = 0x3D：3D信息数据 - `厂商自定义数据`    31. TYPE = 0xFF：厂商自定义数据，厂商自定义的数据中，前两个字节表示厂商ID，剩下的是厂商自己按照需求添加，里面的数据内容自己定义。### 4.5 举例说明解析的思路搜索设备获取的数据包如下：</code></pre><p>02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35 09 03 E7 FE 12 FF 0F 18 0A 18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p><pre><code>根据解析规则，可分成如下部分：1.  广播数据 </code></pre><p>02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35</p><pre><code>2. 响应数据 </code></pre><p>09 03 E7 FE 12 FF 0F 18 0A 18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p><pre><code>3. 有效数据 </code></pre><p>02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35 09 03 E7 FE 12 FF 0F 18 0A 18</p><pre><code>4. 无效数据 </code></pre><p>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p><pre><code>其中的有效数据又可分为如下几个数据单元：</code></pre><p>02 01 06<br>14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23<br>06 08 48 45 54 2D 35<br>09 03 E7 FE 12 FF 0F 18 0A 18</p><pre><code>根据上面定义的AD Type分别解析如下：第一组数据告诉我们该设备属于LE普通发现模式，不支持BR/EDR；第二组数据告诉我们该数据为厂商自定义数据，一般是必须解析的，可根据协议规则进行解析获取对应的所需信息；第三组数据告诉我们该设备的简称为HET-5，其中对应的字符是查找[ASCII表](http://baike.baidu.com/link?url=_TISWJN8T3JSHi5A8OrhuBNyzLLAf006twuPA8wIWtdDG7UbyTfenCFaGWMxJCfXXmZp3SFMTHirjsKx0pTRua)得出；第四组数据告诉我们UUID为E7FE-12FF-0F18-0A18(此处有疑，类型03表示的是16位的UUID，对应的两个字节，而此处有8个字节，估计是设备烧录时把字节位数理解为了字符位数导致的问题).</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>4月以来的两月瘦了20斤</title>
      <link href="/2020/06/16/diary-20200616/"/>
      <url>/2020/06/16/diary-20200616/</url>
      
        <content type="html"><![CDATA[<h3 id="1-空"><a href="#1-空" class="headerlink" title="1.空"></a>1.空</h3><p align="center">不过是大梦一场空</p><p align="center">不过是孤影照惊鸿</p><p align="center">不过是白驹之过一场梦</p><p align="center">梦里有一些相逢</p><p align="center">有道是万物皆虚空</p><p align="center">有道是苦海最无穷</p><p align="center">有道是人生得意须尽欢</p><p align="center">难得最是心从容</p><p align="center">你每天都要求自己拒绝</p><p align="center">碌碌生活的平庸</p><p align="center">人潮挤散你的孤勇</p><p align="center">只留满夜星空</p><p align="center">让所有月色的朦胧</p><p align="center">都遮住现实里破碎的美梦</p><p align="center">而你的快乐正浓</p><p align="center">坠落在晚风</p><div align="center"><img width="500" height="350" src="https://gitee.com/seanzs/pic/raw/master/img/1138516029.jpg"></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>近期的工作学习计划</title>
      <link href="/2020/05/21/diary-20200521/"/>
      <url>/2020/05/21/diary-20200521/</url>
      
        <content type="html"><![CDATA[<h3 id="emsp-emsp-近期装修是最重要的事，买东西肉疼。另外近期的学习计划"><a href="#emsp-emsp-近期装修是最重要的事，买东西肉疼。另外近期的学习计划" class="headerlink" title="   近期装修是最重要的事，买东西肉疼。另外近期的学习计划:"></a>   近期装修是最重要的事，买东西肉疼。另外近期的学习计划:</h3><h4 id="1、web前端"><a href="#1、web前端" class="headerlink" title="1、web前端"></a>1、web前端</h4><h4 id="2、基于unity3d的图形学"><a href="#2、基于unity3d的图形学" class="headerlink" title="2、基于unity3d的图形学"></a>2、基于unity3d的图形学</h4><h4 id="3、UE4和UE5"><a href="#3、UE4和UE5" class="headerlink" title="3、UE4和UE5"></a>3、UE4和UE5</h4><h4 id="4、某服务器架构调试"><a href="#4、某服务器架构调试" class="headerlink" title="4、某服务器架构调试"></a>4、某服务器架构调试</h4><h4 id="5、MyBatis-半自动轻量级持久层框架"><a href="#5、MyBatis-半自动轻量级持久层框架" class="headerlink" title="5、MyBatis(半自动轻量级持久层框架)"></a>5、MyBatis(半自动轻量级持久层框架)</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>难搞哦</title>
      <link href="/2020/05/19/diary-20200519/"/>
      <url>/2020/05/19/diary-20200519/</url>
      
        <content type="html"><![CDATA[<p>   难搞哦</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一天</title>
      <link href="/2020/05/17/diary-20200517/"/>
      <url>/2020/05/17/diary-20200517/</url>
      
        <content type="html"><![CDATA[<p>  今天周日，第一次在这里从早上待到晚上，看着这夕阳，才下眉头，却上心头。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/646328966.jpg" width="80%" align="center"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>下班路上</title>
      <link href="/2020/05/11/diary-20200511/"/>
      <url>/2020/05/11/diary-20200511/</url>
      
        <content type="html"><![CDATA[<p>  下班路上<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/1775673119.jpg" width="80%" align="center"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>明天就要去公司上班了</title>
      <link href="/2020/05/10/diary-20200510/"/>
      <url>/2020/05/10/diary-20200510/</url>
      
        <content type="html"><![CDATA[<blockquote><p>人生路漫漫，很多事情都会不知不觉中忘记，但如果你把它记录下来了。等你老了翻开来看看，那是一笔无法用钱来衡量的财富。</p></blockquote><p>  明天结束居家办公去公司上班，今天上午把电脑搬去公司，顺便做个卫生，停车费有点贵呀；<br>  下午有空想去中国银行更新下身份证信息，结果银行今天没开门；<br>  因为泥工不在，装修今天也没有进场，说是要过两天；<br>  人都是站在自己角度看事物，疫情渐缓，样品柜子可能也不太想不挣钱的便宜处理。<br>  前两天风大，短袖出行回来今天晚上感觉有点受凉。喝了两包板蓝根。睡觉。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>江滩拍摄婚纱照</title>
      <link href="/2020/05/07/diary-20200507/"/>
      <url>/2020/05/07/diary-20200507/</url>
      
        <content type="html"><![CDATA[<p>  昨天来江汉路选婚纱照的服装，选了三套：主白纱、彩纱、室外纱。到时候现场拍摄现场再选古装和街拍服装。天气预报今天中雨，但拍摄时间仍预约今天，如果真一直下大雨就只拍室内的，室外的另订时间。</p><p>  今天天公作美，早上九点半到店里，给女士化妆，给我扑了点粉，准时开拍，因疫情原因，原定江夏的外景改成就近的江滩，各个方面也挺合适的，拍摄时一直配合摄影师的要求在摆姿势，“帅哥、美女，往老公这靠点，看着你老婆，太凶了，这是假笑，靠近点，走一步，挺胸，头歪了，闭眼了，好，别动，再来一次，笑的敷衍哦，笑太开了，高点，过来点，侧着点，行，不错，很好”。</p><p>  五套服装连贯拍完一直到了下午五点半左右，期间吃了点自己带的代餐面包和水。确实是体力活，有点累的。</p><p>  晚上微信视频里你葛优躺在床头调侃拍照除了费钱有什么作用，我说可能是为了发朋友圈，呵呵。</p><p>  照片将情感沉淀在今天定格的瞬间，翻阅照片就是品味往事，点点滴滴，从懵懂变清晰。生活也逐渐展开新的篇章。</p><blockquote><p>5月9号挑选精修及入册的照片，5月16号邮箱看效果，估计5月底能拿相册等东西</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/01/diary-0/"/>
      <url>/2020/05/01/diary-0/</url>
      
        <content type="html"><![CDATA[<p>  因疫情原因，从1月23号到4月6号的两个多月一直呆乡里，关注新闻、刷抖音、吃饭、锻炼、了解日落与星空，背单词，做卫生、烧火、买菜、挖蒲公英、犁地之类。。。</p><a id="more"></a><p>  复工一段时间后，5月1号发现过去买的域名今年3月份就过期了，过期时间过长无法续费，只能更高费用的赎回，那域名就不要算了。再加上旧服务器本来就慢。</p><p>  把旧服务器上花里胡哨的文件备份留存以后，就捣鼓了这个博客，重新开始。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
