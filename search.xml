<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MongoDB实践之2-nodejs连接mongodb数据库</title>
      <link href="/2020/07/20/diary-20200720-2/"/>
      <url>/2020/07/20/diary-20200720-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础操作"><a href="#一、基础操作" class="headerlink" title="一、基础操作"></a>一、基础操作</h2><h3 id="1-1初始化nodejs工程"><a href="#1-1初始化nodejs工程" class="headerlink" title="1.1初始化nodejs工程"></a>1.1初始化nodejs工程</h3><p>在项目根目录下初始化一个package.json文件</p><pre><code>    npm init -y</code></pre><h3 id="1-2安装mongodb模块"><a href="#1-2安装mongodb模块" class="headerlink" title="1.2安装mongodb模块"></a>1.2安装mongodb模块</h3><pre><code>    npm install --save-dev mongodb</code></pre><h3 id="1-3基础增删改查操作"><a href="#1-3基础增删改查操作" class="headerlink" title="1.3基础增删改查操作"></a>1.3基础增删改查操作</h3><p>建立index.js进行代码编写，对数据库进行连接操作。node index.js运行。</p><pre><code>    const mongodbClient=require("mongodb").MongoClient;    const url="mongodb://127.0.0.1:27017";    mongodbClient.connect(url,        {            useUnifiedTopology:true        },        (err,client)=&gt;{        if(err){            console.log("连接失败:"+err);        }else{            console.log("连接成功:"+url);        }    });    mongodbClient.connect(        url,        {            useUnifiedTopology:true        },        (err,client)=&gt;{            if(err){                console.log("连接失败:"+err);            }else{                //连接到该数据库服务器下数据库tablihi中的表biao1,获取表后，对表进行操作。                const collection=client.db("tablehi").collection("biao1");                //增                //collection.save(                //    {                //        "name":"赵四",                //        "password":"safs56"                //    },(err,result)=&gt;{                //        //client.close();                //    }                //);                //删                //collection.remove(                //    {                //        "name":"张三"                //    },()=&gt;{                //        //client.close();                //    }                //);                //改                //collection.update(                //    {                //        "name":"王五"                //    },                //    {                //        "$set":{"password":"wangwu"}                //    }                //);                //查                collection.find().toArray((err,data)=&gt;{                    console.log(data);                    client.close();                });            }        }    );</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB实践之1-安装及命令行登录</title>
      <link href="/2020/07/20/diary-20200720-1/"/>
      <url>/2020/07/20/diary-20200720-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h2><p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/gainianmongodb1.jpg" alt="MongoDB相关概念1"><br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/gainianmongodb2.jpg" alt="MongoDB相关概念直观示意"></p><h3 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h3><h2 id="二、解压版MongoDB配置使用"><a href="#二、解压版MongoDB配置使用" class="headerlink" title="二、解压版MongoDB配置使用"></a>二、解压版MongoDB配置使用</h2><p>官方下载地址 <a href="http://dl.mongodb.org/dl/win32/x86_64" target="_blank" rel="noopener">http://dl.mongodb.org/dl/win32/x86_64</a></p><h3 id="2-1-创建mongodb目录"><a href="#2-1-创建mongodb目录" class="headerlink" title="2.1 创建mongodb目录"></a>2.1 创建mongodb目录</h3><p>下载mongodb-win32-x86_64-2008plus-ssl-v4.0-latest.zip，解压到当前目录后更改文件夹名称为mongodb（名称可随意）。<br>在解压后的文件夹内新建data、log两个文件夹<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/jiayainstallmongodb1.jpg" alt="创建mongodb目录"></p><h3 id="2-2-创建配置文件"><a href="#2-2-创建配置文件" class="headerlink" title="2.2 创建配置文件"></a>2.2 创建配置文件</h3><p>mongodb目录下创建conf文件夹，其内创建mongodb.config</p><pre><code>dbpath=D:\mdb\mongodb\data                            #数据库路径logpath=D:\mdb\mongodb\log\mongodb.log                #日志输出文件路径logappend=true                                        #日志采用追加模式，mongodb的日志会追加到现有日志文件里，而不是重新创建一个新文件journal=true                                        #启用日志quiet=true                                            #过滤掉一些无用日志信息，若需调试请设置为falseport=27017                                            #端口号 默认为27017bind_ip_all=true                                    #允许所有地址访问</code></pre><h3 id="2-3手动启动"><a href="#2-3手动启动" class="headerlink" title="2.3手动启动"></a>2.3手动启动</h3><p>管理员cmd模式下进入mongodb目录 D:\mdb\mongodb\bin下</p><h4 id="运行mongodb"><a href="#运行mongodb" class="headerlink" title="运行mongodb"></a>运行mongodb</h4><pre><code>mongod --config "D:/mdb/mongodb/conf/mongodb.config"</code></pre><h4 id="查看mongodb版本"><a href="#查看mongodb版本" class="headerlink" title="查看mongodb版本"></a>查看mongodb版本</h4><pre><code>mongod --version</code></pre><h3 id="2-4命令行登录db"><a href="#2-4命令行登录db" class="headerlink" title="2.4命令行登录db"></a>2.4命令行登录db</h3><p>mongodb运行后，重新另起一个cmd模式进入 D:\mdb\mongodb\bin，可以登录测试mongodb是否起来了</p><pre><code>mongo 127.0.0.1:27017</code></pre><h3 id="2-5命令行登录mongodb后的操作"><a href="#2-5命令行登录mongodb后的操作" class="headerlink" title="2.5命令行登录mongodb后的操作"></a>2.5命令行登录mongodb后的操作</h3><h4 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h4><p>show dbs;</p><h4 id="切换-创建数据库"><a href="#切换-创建数据库" class="headerlink" title="切换/创建数据库"></a>切换/创建数据库</h4><p>use dancy;<br>如果use后面的数据库存在则切换到该数据库，如果不存在则创建</p><h4 id="查看当前数据库"><a href="#查看当前数据库" class="headerlink" title="查看当前数据库"></a>查看当前数据库</h4><p>db;</p><h4 id="查看当前库有多少集合"><a href="#查看当前库有多少集合" class="headerlink" title="查看当前库有多少集合"></a>查看当前库有多少集合</h4><p>show collections;</p><h4 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h4><p>db.createCollection(某collection名)</p><h4 id="查询某个集合的内容"><a href="#查询某个集合的内容" class="headerlink" title="查询某个集合的内容"></a>查询某个集合的内容</h4><p>db.”某collection名(类似某表名)”.find();</p><h4 id="往某集合里插入一条文档数据"><a href="#往某集合里插入一条文档数据" class="headerlink" title="往某集合里插入一条文档数据"></a>往某集合里插入一条文档数据</h4><p>db.”某collection名(类似某表名)”.insert({“name”: “dancy”})</p><h4 id="删除当前数据库db-dropDatabase"><a href="#删除当前数据库db-dropDatabase" class="headerlink" title="删除当前数据库db.dropDatabase()"></a>删除当前数据库db.dropDatabase()</h4><h4 id="查看集合内文档-db-集合名-find"><a href="#查看集合内文档-db-集合名-find" class="headerlink" title="查看集合内文档 db.集合名.find()"></a>查看集合内文档 db.集合名.find()</h4><p>find方法里面可以传递参数（查询条件）</p><h4 id="查看已插入集合的所有文档（格式化输出）"><a href="#查看已插入集合的所有文档（格式化输出）" class="headerlink" title="查看已插入集合的所有文档（格式化输出）"></a>查看已插入集合的所有文档（格式化输出）</h4><p>db.集合名.find().pretty()</p><h4 id="删除一个文档"><a href="#删除一个文档" class="headerlink" title="删除一个文档"></a>删除一个文档</h4><p>db.集合名.deleteOne({“name”: “lotus”}) , 括号内参数为删除条件。</p><h4 id="删除所有文档："><a href="#删除所有文档：" class="headerlink" title="删除所有文档："></a>删除所有文档：</h4><p>db.集合名.deleteMany({})</p><pre><code>db.adminCommand()               db.dbEval()                     db.getFreeMonitoringStatus()    db.getSiblingDB()               db.isMaster()                   db.revokePrivilegesFromRole()   db.stats()db.aggregate()                  db.disableFreeMonitoring()      db.getLastError()               db.getSisterDB()                db.killOP()                     db.revokeRolesFromRole()        db.toLocaleString()db.auth()                       db.dropAllRoles()               db.getLastErrorCmd()            db.getSlaveOk()                 db.killOp()                     db.revokeRolesFromUser()        db.toString()db.changeUserPassword()         db.dropAllUsers()               db.getLastErrorObj()            db.getUser()                    db.listCommands()               db.runCommand()                 db.tojson()db.cloneCollection()            db.dropDatabase(               db.getLogComponents(           db.getUsers()                   db.loadServerScripts()          db.runCommandWithMetadata()     db.unsetWriteConcern()db.cloneDatabase()              db.dropRole()                   db.getMongo()                   db.getWriteConcern()            db.logout()                     db.runReadCommand()             db.updateRole()db.commandHelp()                db.dropUser()                   db.getName()                    db.grantPrivilegesToRole()      db.printCollectionStats()       db.serverBits()                 db.updateUser()db.constructor                 db.enableFreeMonitoring()       db.getPrevError()               db.grantRolesToRole()           db.printReplicationInfo()       db.serverBuildInfo()            db.valueOfdb.copyDatabase()               db.eval()                       db.getProfilingLevel()          db.grantRolesToUser()           db.printShardingStatus()        db.serverCmdLineOpts()          db.version()db.createCollection()           db.forceError()                 db.getProfilingStatus()         db.group()                      db.printSlaveReplicationInfo()  db.serverStatus()db.createRole()                 db.fsyncLock()                  db.getQueryOptions()            db.groupcmd()                   db.propertyIsEnumerable        db.setLogLevel()db.createUser()                 db.fsyncUnlock()                db.getReplicationInfo()         db.groupeval()                  db.prototype                   db.setProfilingLevel()db.createView()                 db.getCollection()              db.getRole()                    db.hasOwnProperty              db.removeUser()                 db.setSlaveOk()db.currentOP()                  db.getCollectionInfos()         db.getRoles()                   db.help()                       db.repairDatabase()             db.setWriteConcern()db.currentOp()                  db.getCollectionNames()         db.getSession()                 db.hostInfo()                   db.resetError()                 db.shutdownServer()</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android网络请求框架OkHttp的使用</title>
      <link href="/2020/07/17/diary-20200717-1/"/>
      <url>/2020/07/17/diary-20200717-1/</url>
      
        <content type="html"><![CDATA[<ul><li>okhttp-3.9.0.jar</li><li>okio-1.13.0.jar(配套必须包含)</li></ul><h2 id="一、关于OkHttp"><a href="#一、关于OkHttp" class="headerlink" title="一、关于OkHttp"></a>一、关于OkHttp</h2><p> OkHttp 是 Square 公司开源的针对 Java 和 Android 程序，封装的一个高性能 http 请求库。支持spdy、http2.0、websocket，支持同步、异步，而且OkHttp又封装了线程池，封装了数据转换，封装了参数使用、错误处理等，api使用起来更加方便。可以把它理解成是一个封装之后的类似HttpUrlConnection的一个东西，但是你在使用的时候仍然需要自己再做一层封装，这样才能像使用一个框架一样更加顺手。</p><h2 id="二、安装使用"><a href="#二、安装使用" class="headerlink" title="二、安装使用"></a>二、安装使用</h2><h3 id="2-1-添加库的引用"><a href="#2-1-添加库的引用" class="headerlink" title="2.1 添加库的引用"></a>2.1 添加库的引用</h3><p>将okhttp-3.9.0.jar和okio-1.13.0.jar放入AndroidStudio的Project/app/libs/目录下，并右键点击“Add As Library”。</p><h3 id="2-2-添加网络访问权限"><a href="#2-2-添加网络访问权限" class="headerlink" title="2.2 添加网络访问权限"></a>2.2 添加网络访问权限</h3><p>在AndroidManifest.xml里添加权限</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"    package="com.compancy1.yibuhttp"&gt;    &lt;uses-permission android:name="android.permission.INTERNET" /&gt;    &lt;application        android:networkSecurityConfig="@xml/network"        android:allowBackup="true"        android:icon="@mipmap/ic_launcher"        android:label="@string/app_name"        android:roundIcon="@mipmap/ic_launcher_round"        android:supportsRtl="true"        android:theme="@style/AppTheme"&gt;        &lt;meta-data            android:name="com.google.android.actions"            android:resource="@xml/network" /&gt;        &lt;activity android:name=".MainActivity"&gt;            &lt;intent-filter&gt;                &lt;action android:name="android.intent.action.MAIN" /&gt;                &lt;category android:name="android.intent.category.LAUNCHER" /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><h3 id="2-3-Activity代码中使用"><a href="#2-3-Activity代码中使用" class="headerlink" title="2.3 Activity代码中使用"></a>2.3 Activity代码中使用</h3><pre><code>public class MainActivity extends AppCompatActivity {    Button btn;         @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        btn=(Button) findViewById(R.id.btn1);        btn.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                myPost();            }        });    }    private void myPost(){        String url="http://192.168.31.112:8181";        OkHttpClient okHttpClient=new OkHttpClient();        FormBody.Builder formBody=new FormBody.Builder();        formBody.add("username","关云长");        formBody.add("password","a123321b");        Request request=new Request.Builder()                .url(url)                .post(formBody.build())                .build();        Call call=okHttpClient.newCall(request);        //异步请求，通过接口回调告知用户http的异步执行结果        call.enqueue(new Callback() {            @Override            public void onFailure(Call call, IOException e) {                Log.d("OKHttpFailed",e.getMessage());            }            @Override            public void onResponse(Call call, Response response) throws IOException {                if(response.isSuccessful()){                    Log.d("OKHttp",response.body().toString());                }            }        });    }}</code></pre><h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>由于Android P以后网络访问安全策略升级引起的错误，报错CLEARTEXT communication to “ “ not permitted by network security policy 。<br>解决方法:添加res/xml/network.xml文件后，在Androidmanifest.xml中设置networkSecurity指向该文件即可。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/notpermittedbynetworksecuritypolicy.jpg" alt="网络访问安全策略修改"><br>network.xml如下</p><pre><code>&lt;?xml version ="1.0" encoding ="utf-8"?&gt;&lt;network-security-config&gt;    &lt;base-config cleartextTrafficPermitted="true"  /&gt;&lt;/network-security-config&gt;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> OkHttp </tag>
            
            <tag> AndriodStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用socket.io和nodeJS的websocket实践</title>
      <link href="/2020/07/16/diary-20200716-2/"/>
      <url>/2020/07/16/diary-20200716-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、关于socket-IO"><a href="#一、关于socket-IO" class="headerlink" title="一、关于socket.IO"></a>一、关于socket.IO</h2><p>socket.IO是一个websocket库，包括了客户端的js和服务器端的nodejs。官方地址：<a href="http://socket.io" target="_blank" rel="noopener">http://socket.io</a> </p><h2 id="二、socket-io提供给客户端的websock服务"><a href="#二、socket-io提供给客户端的websock服务" class="headerlink" title="二、socket.io提供给客户端的websock服务"></a>二、socket.io提供给客户端的websock服务</h2><p>去github clone socket.io的最新版本，或者直接饮用使用socket.io的CDN服务：</p><pre><code>    &lt;script src="https://lib.baomitu.com/socket.io/2.3.0/socket.io.js"&gt;&lt;/script&gt;</code></pre><p>以下是使用socket.io库来创建客户端</p><pre><code>    &lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;&lt;/title&gt;    &lt;script src="https://lib.baomitu.com/socket.io/2.3.0/socket.io.js"&gt;&lt;/script&gt;    &lt;script&gt;        var socket=io.connect('http://localhost:8081');        socket.on('message',function(data){            console.log('Receive message from server,'+data);            socket.emit('message',{nihao:'helloworld'});            socket.emit('storeClientInfo',{customId:"000CustomIdHere1234"});        });        socket.on('connect',function(){            alert("连接成功");        });        socket.on('disconnect',function(){            console.log("断开连接");        });    &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;    &lt;/body&gt;</code></pre><h2 id="三、socket-io提供给服务器端搭建websock服务"><a href="#三、socket-io提供给服务器端搭建websock服务" class="headerlink" title="三、socket.io提供给服务器端搭建websock服务"></a>三、socket.io提供给服务器端搭建websock服务</h2><h3 id="创建空的项目文件夹"><a href="#创建空的项目文件夹" class="headerlink" title="创建空的项目文件夹"></a>创建空的项目文件夹</h3><pre><code>    mkdir socketserver    cd socketserver</code></pre><h3 id="在项目内安装socket-io"><a href="#在项目内安装socket-io" class="headerlink" title="在项目内安装socket.io"></a>在项目内安装socket.io</h3><pre><code>    npm install socket.io</code></pre><h3 id="搭建服务器环境"><a href="#搭建服务器环境" class="headerlink" title="搭建服务器环境"></a>搭建服务器环境</h3><p>通过nodejs的http模块就可以方便的搭建websocket服务器环境</p><pre><code>    // 引入需要的模块：http和socket.io    var http=require('http');    var io=require('socket.io');    // 创建server，Socket服务器还是构建于HTTP服务器之上，因此先调用 http.createServer()    var server=http.createServer();    server.on('request',function(req,res){        res.writeHead(200,{'Content-Type':'text/html'});        res.end('&lt;h1&gt;Hello,Socket&lt;/h1&gt;');    });    //http端口8081    server.listen(8081);    console.log("-- http listen on port :8081 --");    var clients=[];    //创建socket，交由Socket.io接管    var socket=io.listen(server);    //添加连接监听，Socket.io 真正的连接事件    socket.on('connection',function(client){        //服务端这边的客户端对象代表接受客户端发过来的信息        client.on('message',function(obj){            console.log("Receive message from client,"+obj.nihao);        });        //客户端断开连接时，在服务器端的列表里删除相应对象代表        client.on('disconnect',function(){            //console.log('server has disconnected');            for(var i=0,len=clients.length;i&lt;len;++i){                var c=clients[i];                if(c.clientId==client.id){                    clients.splice(i,1);                    console.log(clients.length);                    break;                }            }        });        //服务端这边的监听客户端对象代表接受客户端发过来的自定义事件        client.on('storeClientInfo',function(data){            var clientInfo=new Object();            clientInfo.customId=data.customId;            clientInfo.clientId=client.id;            clients.push(clientInfo);            console.log(clients.length);        });        //服务端通过客户端对象代表向该客户端发送信息message        client.send("welcome my friend");    });    console.log("-- socket listen on port :8081 --");</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> NodeJS </tag>
            
            <tag> socket.io </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速搭建在线文档的实践</title>
      <link href="/2020/07/16/diary-20200716-1/"/>
      <url>/2020/07/16/diary-20200716-1/</url>
      
        <content type="html"><![CDATA[<ul><li>Vue v2.9.6</li><li>Node v12.16.3</li></ul><h2 id="一、关于vuepress："><a href="#一、关于vuepress：" class="headerlink" title="一、关于vuepress："></a>一、关于vuepress：</h2><p>vuepress项目的文档结构，都必须按照官方文档的格式进行制作。比如说你想修改整体的主题颜色，你就必须修改styles文件夹下的palette.styl。你想在markdown中添加vue组件，vue组件必须放在components文件夹下，诸如此类。等到vuepress在打包的时候，它会遍历特定的路径和文件名称，读取内容生成页面结构和样式。</p><h2 id="二、开始制作"><a href="#二、开始制作" class="headerlink" title="二、开始制作"></a>二、开始制作</h2><h3 id="创建空的项目文件夹"><a href="#创建空的项目文件夹" class="headerlink" title="创建空的项目文件夹"></a>创建空的项目文件夹</h3><pre><code>    mkdir vuepressdemo    cd vuepressdemo</code></pre><h3 id="全局安装vuepress"><a href="#全局安装vuepress" class="headerlink" title="全局安装vuepress"></a>全局安装vuepress</h3><pre><code>    npm install -g vuepress</code></pre><h3 id="初始化项目信息"><a href="#初始化项目信息" class="headerlink" title="初始化项目信息"></a>初始化项目信息</h3><pre><code>    npm init -y</code></pre><p>创建完成后，进入我们的pageckage.json文件，在scripts中添加两条命令</p><pre><code>"scripts": {    "dev": "vuepress dev docs",         //用于实时预览    "build": "vuepress build docs"      //用于打包项目}</code></pre><h3 id="按规则创建vuepress项目结构的文件夹和文件"><a href="#按规则创建vuepress项目结构的文件夹和文件" class="headerlink" title="按规则创建vuepress项目结构的文件夹和文件"></a>按规则创建vuepress项目结构的文件夹和文件</h3><p>有现成的就直接复制docs目录吧。<br>或者对照<a href="https://vuepress.vuejs.org/zh/guide/directory-structure.html" target="_blank" rel="noopener">官方的目录结构</a></p><pre><code>├── docs│   ├── .vuepress  //存放核心内容的文件夹│   │   ├── components  //存放你需要添加的vue组件│   │   ├── public  //存放静态文件，如图片等│   │   ├── styles  //存放需要定制的样式│   │   │   └── palette.styl  //配置页面主题颜色的文件│   │   └── config.js   //设定顶部导航栏、侧边导航栏等项目配置的核心文件│   ├── pages   //存放markdown文件，用于设置其他页面内容│   ├── README.md   //首页展示用的markdown文件├── deploy.sh     //之后用于编写上传、发布脚本的文件└── package.json  //之前创建的Node.js项目描述文件</code></pre><h3 id="开发、部署"><a href="#开发、部署" class="headerlink" title="开发、部署"></a>开发、部署</h3><p>CMD进入在package.json同层目录里执行命令。</p><pre><code>    npm run dev    用于开发实时预览    npm run build  用于打包项目输出静态网页于docs/.vuepress/dist/处。</code></pre><p>如果不部署在服务器根目录，需要在docs/.vuepress/config.js里添加base信息。</p><pre><code>//config.jsmodule.exports = {    title: '我的首页', // 显示在左上角的网页名称以及首页在浏览器标签显示的title名称    description: '我的首页记录', // meta 中的描述文字，用于SEO    // 注入到当前页面的 HTML &lt;head&gt; 中的标签    head: [        ['link', { rel: 'icon', href: '/egg.png' }],  //浏览器的标签栏的网页图标    ],    markdown: {        lineNumbers: true    },    serviceWorker: true,    themeConfig: {            logo: '/egg.png',        lastUpdated: 'lastUpdate', // string | boolean        nav: [            { text: '首页', link: '/' },            {                text: '分类',                ariaLabel: '分类',                items: [                    { text: '文章', link: '/pages/folder1/test1.md' },                    { text: '琐碎', link: '/pages/folder2/test4.md' },                ]            },            { text: '功能演示', link: '/pages/folder1/test3.md' },            { text: '联系我', link: 'https://www.baidu.com' },        ],        sidebar: {            '/pages/folder1/':[                {                    title: '测试菜单1',   // 必要的一级菜单名称                    collapsable: false, // 可选的, 默认值是 true折叠,                    sidebarDepth: 1,    // 可选的, 设置侧边导航自动提取markdown文件标题的层级，默认1为h2层级                    children: [                        ['test1.md', '子菜单1'],    //菜单名称为'子菜单1'，跳转至/pages/folder1/test1.md                        ['test3.md', '子菜单2']                    ]                },                {                    title: '测试菜单2',                    collapsable: false, // 可选的, 默认值是 true,                    children: [                        ['test2.md', '子菜单1']                    ]                }            ],            //...可添加多个不同的侧边栏，不同页面会根据路径显示不同的侧边栏        }    },    base: '/mydoc/'  //部署时服务器的发布目录}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android中ListView的用法</title>
      <link href="/2020/07/15/diary-20200715-1/"/>
      <url>/2020/07/15/diary-20200715-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、ListView的作用："><a href="#一、ListView的作用：" class="headerlink" title="一、ListView的作用："></a>一、ListView的作用：</h2><p>将数据填充到布局，处理用户的选择点击操作。<br>创建ListView需要3个元素：</p><ol><li>ListView中的每一列的View。</li><li>填入View的数据或图片资源等。</li><li>连接数据与ListView的适配器。</li></ol><h2 id="二、什么是适配器？"><a href="#二、什么是适配器？" class="headerlink" title="二、什么是适配器？"></a>二、什么是适配器？</h2><p>适配器是一个连接数据资源和AdapterView（如ListView）的桥梁，使用适配器能实现数据与AdapterView的分离，使AdapterView与数据的绑定更加简单，修改更加方便。<br>Android中常用的适配器Adapter有：</p><ul><li>ArrayAdapter<t>：用于绑定数组，支持泛型操作</t></li><li>SimpleAdapte：用于绑定在xml中定义的控件对应的数据</li><li>SimpleCursorAdapter：用于绑定游标得到的数据</li><li>BaseAdapter：通用的基础适配器</li></ul><h3 id="2-1-ArrayAdapter："><a href="#2-1-ArrayAdapter：" class="headerlink" title="2.1 ArrayAdapter："></a>2.1 ArrayAdapter<t>：</t></h3><p>用ArrayAdapter可实现简单的ListView数据绑定。默认情况下，ArrayAdapter绑定每个对象的toString值到layout中预先定义的TextView控件上。还可以实现带RadioButton和CheckBox的ListView。<br>在布局文件中添加一个ListView控件。</p><pre><code>&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;LinearLayoutxmlns:android="http://schemas.android.com/apk/res/android"    android:layout_width="fill_parent"    android:layout_height="fill_parent"    &gt;    &lt;ListView         android:id="@+id/lv"        android:layout_width="fill_parent"        android:layout_height="fill_parent"    /&gt;&lt;/LinearLayout&gt;</code></pre><p>然后在Activity中初始化。</p><pre><code>publicclass MyListView extends Activity {    privatestaticfinal String[] strs = new String[] {        "first", "second", "third", "fourth", "fifth"    };    //定义一个String数组用来显示ListView的内容    private ListView lv;    /** Called when the activity is first created. */    @Override    public void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.main);        lv = (ListView) findViewById(R.id.lv);        //得到ListView对象的引用        /*为ListView设置Adapter来绑定数据*/        lv.setAdapter(new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1, strs));        /*处理用户的操作。通过如下的代码就可以为ListView绑定一个点击监听器*/        lv.setOnItemClickListener(new OnItemClickListener() {            @Override            publicvoid onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2,long arg3) {                //点击后在标题上显示点击了第几行                setTitle("你点击了第"+arg2+"行");            }        });    }}</code></pre><p>其中R.layout.simple_list_item_1是一个自定义的layout文件xml,必须要有TextView控件。比如长下面这个样子：</p><pre><code>&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;TextView xmlns:android="http://schemas.android.com/apk/res/android"    android:layout_width="match_parent"    android:layout_height="wrap_content"    android:orientation="vertical"&gt;&lt;/TextView&gt;</code></pre><p>分析一下以上简单的使用步骤：</p><ul><li>定义一个数组来存放ListView中item的内容。</li><li>通过实现ArrayAdapter的构造函数来创建一个ArrayAdapter的对象。</li><li>通过ListView的setAdapter()方法绑定ArrayAdapter。<br>其中第二步有必要说一下的是，ArrayAdapter有多个构造函数，例子中实现的是最常用的一种。第一个参数为上下文，第二个参数为一个包含TextView，用来填充ListView的每一行的布局资源ID。第三个参数为ListView的内容。其中第二个参数可以自定义一个layout，但是这个layout必须要有TextView控件。通常我们使用Android提供的资源，除了例子中所用的，常用的还有如下几种，可实现带RadioButton和CheckBox的ListView。</li></ul><h3 id="2-2-SimpleAdapter："><a href="#2-2-SimpleAdapter：" class="headerlink" title="2.2 SimpleAdapter："></a>2.2 SimpleAdapter：</h3><p>使用SimpleAdapter可以自定义实现ListView中的item的内容，比如图片、多选框等。使用simpleAdapter的数据一般都是用HashMap构成的列表，列表的每一节对应ListView的每一行。通过SimpleAdapter的构造函数，将HashMap的每个键的数据映射到布局文件中对应控件上。<br>很多时候需要在列表中展示一些除了文字以外的东西，比如图片等。这时候可以使用SimpleAdapter。SimpleAdapter的使用也非常简单，同时它的功能也非常强大。可以通过它自定义ListView中的item的内容，比如图片、多选框等。接下来这个例子，实现一个每一行都有一个ImageView和TextView的ListView。<br>在布局文件中添加一个ListView控件。</p><pre><code>&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;LinearLayoutxmlns:android="http://schemas.android.com/apk/res/android"    android:layout_width="fill_parent"    android:layout_height="fill_parent"    &gt;    &lt;ListView         android:id="@+id/lv"        android:layout_width="fill_parent"        android:layout_height="fill_parent"    /&gt;&lt;/LinearLayout&gt;</code></pre><p>定义一个ListView中每一行的布局item.xml，用RelativeLayout来实现一个带两行字和一个图片的布局。</p><pre><code>&lt;?xmlversion="1.0"encoding="utf-8"?&gt;&lt;RelativeLayoutxmlns:android="http://schemas.android.com/apk/res/android"    android:layout_height="fill_parent"    android:layout_width="fill_parent"    &gt;    &lt;ImageView android:layout_alignParentRight="true"    android:layout_width="wrap_content"    android:layout_height="wrap_content"    android:id="@+id/ItemImage"    /&gt;    &lt;TextView android:id="@+id/ItemTitle"    android:layout_height="wrap_content"    android:layout_width="fill_parent"    android:textSize="20sp"/&gt;    &lt;TextViewandroid:id="@+id/ItemText"    android:layout_height="wrap_content"    android:layout_width="fill_parent"    android:layout_below="@+id/ItemTitle"    /&gt;&lt;/RelativeLayout&gt;</code></pre><p>配置完毕，就可以在Activity中为ListView绑定数据。</p><pre><code>    public class MyListViewSimple extends Activity {        private ListView lv;        /** Called when the activity is first created. */        @Override        public void onCreate(Bundle savedInstanceState) {            super.onCreate(savedInstanceState);            setContentView(R.layout.main);            lv = (ListView) findViewById(R.id.lv);            /*定义一个动态数组*/            ArrayList&lt;HashMap&lt;String, Object&gt;&gt; listItem = new ArrayList&lt;HashMap&lt;String,Object&gt;&gt;();            /*在数组中存放数据*/            for(int i=0;i&lt;10;i++)            {                HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();                map.put("ItemImage", R.drawable.icon);//加入图片                map.put("ItemTitle", "第"+i+"行");                map.put("ItemText", "这是第"+i+"行");                listItem.add(map);            }            SimpleAdapter mSimpleAdapter = new SimpleAdapter(this,listItem,R.layout.item,new String[] {"ItemImage","ItemTitle", "ItemText"},new int[] {R.id.ItemImage,R.id.ItemTitle,R.id.ItemText});            lv.setAdapter(mSimpleAdapter);//为ListView绑定适配器            lv.setOnItemClickListener(new OnItemClickListener() {                 @Override                public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2,long arg3) {                    setTitle("你点击了第"+arg2+"行");//设置标题栏显示点击的行                }            });            }    }</code></pre><p>使用simpleAdapter的数据一般都是用HashMap构成的列表，列表的每一节对应ListView的每一行。通过SimpleAdapter的构造函数，将HashMap的每个键的数据映射到布局文件中对应控件上。这个布局文件一般根据自己的需要来自己定义。梳理一下使用SimpleAdapter的步骤。</p><ul><li>根据需要定义ListView每行所实现的布局。</li><li>定义一个HashMap构成的列表，将数据以键值对的方式存放在里面。</li><li>构造SimpleAdapter对象。</li><li>将LsitView绑定到SimpleAdapter上。</li></ul><h3 id="2-3-BaseAdapter"><a href="#2-3-BaseAdapter" class="headerlink" title="2.3 BaseAdapter:"></a>2.3 BaseAdapter:</h3><p>当ListView不只是用于展示数据，还需要加入按钮等控件获取焦点时，使用BaseAdapter，因为SimpleAdapter添加一个按钮到ListView的条目中时，无法获得焦点，点击操作会被ListView的Item所覆盖。<br><font color="red">使用BaseAdapter必须写一个类继承它</font>，同时BaseAdapter是一个抽象类，继承它必须实现它的方法。BaseAdapter的灵活性就在于它要重写很多方法，以下是必须实现的方法</p><ul><li>***Adapter(Content)</li><li>getCount():int</li><li>getItem(int):Object</li><li>getItemId(int):long</li><li>getView(int,View,ViewGroup):View<br>其中最重要的即为getView()方法。这些方法都有什么作用呢？我们通过分析ListView的原理来揭晓。<br>当系统开始绘制ListView的时候，首先调用getCount()方法。得到它的返回值，即ListView的长度。然后系统调用getView()方法，根据这个长度逐一绘制ListView的每一行。也就是说，如果让getCount()返回1，那么只显示一行。而getItem()和getItemId()则在需要处理和取得Adapter中的数据时调用。那么getView如何使用呢？如果有10000行数据，就绘制10000次？这肯定会极大的消耗资源，导致ListView滑动非常的慢，那应该怎么做呢？通过一个例子来讲解如何在使用BaseAdapter的时候优化ListView的显示。例子中将上一节中的ImageView换成Button，并且处理Button的点击事件，其中对ListView的显示做了优化。<br>例子的布局文件同上一个例子类似，这里只给出Activity类。<pre><code>public class MyListViewBase extends Activity {  private ListView lv;  /*定义一个动态数组*/  ArrayList&lt;HashMap&lt;String, Object&gt;&gt;listItem;  /** Called when the activity is first created. */  @Override  public void onCreate(Bundle savedInstanceState) {      super.onCreate(savedInstanceState);      setContentView(R.layout.main);      lv = (ListView)findViewById(R.id.lv);      MyAdapter mAdapter = new MyAdapter(this);//得到一个MyAdapter对象      lv.setAdapter(mAdapter);//为ListView绑定Adapter      /*为ListView添加点击事件*/      lv.setOnItemClickListener(new OnItemClickListener() {          @Override          public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int arg2,long arg3) {              Log.v("MyListViewBase", "你点击了ListView条目" + arg2);//在LogCat中输出信息          }      });  }  /*添加一个得到数据的方法，方便使用*/  private ArrayList&lt;HashMap&lt;String, Object&gt;&gt; getDate(){      ArrayList&lt;HashMap&lt;String,Object&gt;&gt; listItem = new ArrayList&lt;HashMap&lt;String,Object&gt;&gt;();      /*为动态数组添加数据*/          for(int i=0;i&lt;30;i++)      {          HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();          map.put("ItemTitle", "第"+i+"行");          map.put("ItemText", "这是第"+i+"行");          listItem.add(map);                 }      return listItem;  }  /* 新建一个类继承BaseAdapter，实现视图与数据的绑定     */  private class MyAdapter extends BaseAdapter {      private LayoutInflater mInflater;//得到一个LayoutInfalter对象用来导入布局      /*构造函数*/      public MyAdapter(Context context) {          this.mInflater = LayoutInflater.from(context);      }      @Override      public int getCount() {          return getDate().size();//返回数组的长度      }      @Override      public Object getItem(int position) {          return null;      }      @Override      public long getItemId(int position) {          return 0;      }      /*书中详细解释该方法*/      @Override      public View getView(finalint position, View convertView, ViewGroup parent) {          ViewHolder holder;                      //观察convertView随ListView滚动情况          Log.v("MyListViewBase", "getView " + position + " " + convertView);          if (convertView == null) {              convertView = mInflater.inflate(R.layout.item,null);              holder = new ViewHolder();              /*得到各个控件的对象*/              holder.title = (TextView) convertView.findViewById(R.id.ItemTitle);              holder.text = (TextView) convertView.findViewById(R.id.ItemText);              holder.bt = (Button) convertView.findViewById(R.id.ItemButton);              convertView.setTag(holder);//绑定ViewHolder对象          }else{              holder = (ViewHolder)convertView.getTag();//取出ViewHolder对象          }          /*设置TextView显示的内容，即我们存放在动态数组中的数据*/          holder.title.setText(getDate().get(position).get("ItemTitle").toString());          holder.text.setText(getDate().get(position).get("ItemText").toString());          /*为Button添加点击事件*/          holder.bt.setOnClickListener(new OnClickListener() {              @Override              public void onClick(View v) {                  Log.v("MyListViewBase", "你点击了按钮" + position);//打印Button的点击信息              }          });          return convertView;      }  }  /*存放控件*/  public final class ViewHolder{      public TextView title;      public TextView text;      public Button bt;  }}</code></pre>还需要注意的是，Button会抢夺ListView的焦点，需要将Button设置为没有焦点。设置非常简单，只需要在xml的Button标签下加入一行：android:focusable=“false”代码就可以了。<br>代码中getView()方法不容易理解。其实完全可以不用所谓的convertView和ViewHolder，直接导入布局并且设置控件显示的内容就可以了。但是这意味着有多少行数据就需要绘制多少行ListView，这显然是不可取的。这里采用了一种优化的方法。代码中，在getView()方法中加入了一行log输出convertView的内容。滚动ListView。<br>当启动Activity呈现第一屏ListView的时候，convertView为零。当用户向下滚动ListView时，上面的条目变为不可见，下面出现新的条目。这时候convertView不再为空，而是创建了一系列的convertView的值。当又往下滚一屏的时候，发现第11行的容器用来容纳第22行，第12行的容器用来容纳第23行。也就是说convertView相当于一个缓存，开始为0，当有条目变为不可见，它缓存了它的数据，后面再出来的条目只需要更新数据就可以了，这样大大节省了系统资料的开销。<br>还可以继续优化。虽然重复利用了已经绘制的view，但是要得到其中的控件，需要在控件的容器中通过findViewById的方法来获得。如果这个容器非常复杂，这显然会增加系统资源的开销。在上面的例子中，引入了Tag的概念。或许不是最好的办法，但是它确实能使ListView变得更流畅。代码中，当convertView为空时，用setTag()方法为每个View绑定一个存放控件的ViewHolder对象。当convertView不为空，重复利用已经创建的view的时候，使用getTag()方法获取绑定的ViewHolder对象，这样就避免了findViewById对控件的层层查询，而是快速定位到控件。<br>总结一下，这节介绍了用BaseAdapter来绑定ListView的数据。因为BaseAdapter非常灵活，使用也相对较其他控件麻烦。同时ListView的优化问题也值得读者去研究，一个流畅的ListView会带来更好的用户体验。</li></ul><h3 id="2-4-SimpleCursorAdapter："><a href="#2-4-SimpleCursorAdapter：" class="headerlink" title="2.4 SimpleCursorAdapter："></a>2.4 SimpleCursorAdapter：</h3><p>在SQLite中使用。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> AndroidStudio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>熬过无人问津的日子，才有诗和远方</title>
      <link href="/2020/07/06/diary-20200706/"/>
      <url>/2020/07/06/diary-20200706/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/20200706003547.jpg" alt=""><br>推开世界的门<br>你是站在门外最孤单的人<br>捧着一颗不懂计较的认真<br>路过你的时候 时间多残忍<br>左手的泥呀 右手的泥呀<br>知己的花衣裳<br>世界本该是你诚实的模样<br>左眼的悲伤 右眼的倔强<br>看起来都一样<br>原来你就是我走失的地方</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BLE学习笔记3-BLE广播数据解析</title>
      <link href="/2020/07/05/diary-20200705-3/"/>
      <url>/2020/07/05/diary-20200705-3/</url>
      
        <content type="html"><![CDATA[<p>BLE设备工作的第一步就是向外广播数据。广播数据中带有设备相关的信息。本文主要说一下 BLE 的广播中的数据的规范以及广播包的解析。</p><h2 id="一、广播模式"><a href="#一、广播模式" class="headerlink" title="一、广播模式"></a>一、广播模式</h2><p>BLE 中有两种角色 Central 和 Peripheral ，也就是中心设备和外围设备。中心设备可以主动连接外围设备，外围设备发送广播或者被中心设备连接。外围通过广播被中心设备发现，广播中带有外围设备自身的相关信息。<br>广播包有两种： 广播包 （Advertising Data）和 响应包 （Scan Response），其中广播包是每个设备必须广播的，而响应包是可选的。 数据包的格式如下图所示<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/data_format.jpg" alt="数据包格式"><br>每个包都是 31 字节，数据包中分为有效数据（significant）和无效数据（non-significant）两部分。</p><ul><li>有效数据部分：包含若干个广播数据单元，称为 AD Structure。如图中所示，AD Structure 的组成是：第一个字节是长度值 Len，表示接下来的 Len 个字节是数据部分。数据部分的第一个字节表示数据的类型 AD Type，剩下的 Len - 1 个字节是真正的数据 AD data。其中 AD type 非常关键，决定了 AD Data 的数据代表的是什么和怎么解析，这个在《BLE学习笔记1-Android开发前言》里详细讲；</li><li>无效数据部分 ：因为广播包的长度必须是 31 个 byte，如果有效数据部分不到 31 自己，剩下的就用 0 补全。这部分的数据是无效的，解释的时候，忽略即可。<h2 id="二、广播数据解析"><a href="#二、广播数据解析" class="headerlink" title="二、广播数据解析"></a>二、广播数据解析</h2>在 Android 可以使用 BluetoothAdapter 来发起扫描。基本用法如下：<pre><code>BluetoothAdapter.LeScanCallback mLeScanCallback =    new BluetoothAdapter.LeScanCallback() {      @Override      public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) {          // 解析广播数据          parseAdvData(scanRecord);      }  };</code></pre></li></ul><p>mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();<br>// 开始扫描设备<br>mBluetoothAdapter.startLeScan(mLeScanCallback);<br>…<br>// 停止扫描设备<br>mBluetoothAdapter.stopLeScan(mLeScanCallback);  </p><pre><code>当扫描到设备以后，就会回调 onLeScan(...)，这里的参数 scanRecord 就是广播数据，这里同时包含广播数据和扫描相应数据（如果有的话），所以长度一般就是 62 字节。据上一节的广播数据格式的说明，可以实现解析广播数据函数 parseAdvData(scanRecord);，下面的代码实现了解析几个我关心的数据：</code></pre><p>public static ParsedAd parseData(byte[] adv_data) {<br>    ParsedAd parsedAd = new ParsedAd();<br>    ByteBuffer buffer = ByteBuffer.wrap(adv_data).order(ByteOrder.LITTLE_ENDIAN);<br>    while (buffer.remaining() &gt; 2) {<br>        byte length = buffer.get();<br>        if (length == 0)<br>            break;</p><pre><code>    byte type = buffer.get();    length -= 1;    switch (type) {        case 0x01: // Flags            parsedAd.flags = buffer.get();            length--;            break;        case 0x02: // Partial list of 16-bit UUIDs        case 0x03: // Complete list of 16-bit UUIDs        case 0x14: // List of 16-bit Service Solicitation UUIDs            while (length &gt;= 2) {                parsedAd.uuids.add(UUID.fromString(String.format(                        "%08x-0000-1000-8000-00805f9b34fb", buffer.getShort())));                length -= 2;            }            break;        case 0x04: // Partial list of 32 bit service UUIDs        case 0x05: // Complete list of 32 bit service UUIDs            while (length &gt;= 4) {                parsedAd.uuids.add(UUID.fromString(String.format(                        "%08x-0000-1000-8000-00805f9b34fb", buffer.getInt())));                length -= 4;            }            break;        case 0x06: // Partial list of 128-bit UUIDs        case 0x07: // Complete list of 128-bit UUIDs        case 0x15: // List of 128-bit Service Solicitation UUIDs            while (length &gt;= 16) {                long lsb = buffer.getLong();                long msb = buffer.getLong();                parsedAd.uuids.add(new UUID(msb, lsb));                length -= 16;            }            break;        case 0x08: // Short local device name        case 0x09: // Complete local device name            byte sb[] = new byte[length];            buffer.get(sb, 0, length);            length = 0;            parsedAd.localName = new String(sb).trim();            break;                        case (byte) 0xFF: // Manufacturer Specific Data            parsedAd.manufacturer = buffer.getShort();            length -= 2;            break;        default: // skip            break;    }    if (length &gt; 0) {        buffer.position(buffer.position() + length);    }}return parsedAd;</code></pre><p>}</p><pre><code>其中 ParsedAd 是自定义的简单 Java 对象，用来保存解析后的数据。这里只是解析了我关心的数据，你也可以根据前面的说明，解析更多的内容。## 三、参考资料- [蓝牙官方文档](https://www.bluetooth.org/en-us/specification/adopted-specifications)- [GAP Advertising and Scan Response Data format](https://devzone.nordicsemi.com/documentation/nrf51/4.2.0/html/group___b_l_e___g_a_p___a_d___t_y_p_e___d_e_f_i_n_i_t_i_o_n_s.html)- [Parsing BLE Advertisement packets](http://www.sfonge.com/forum/topic/parsing-ble-advertisement-packets)</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BLE学习笔记2-GATT Profile简介</title>
      <link href="/2020/07/05/diary-20200705-2/"/>
      <url>/2020/07/05/diary-20200705-2/</url>
      
        <content type="html"><![CDATA[<h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>BLE低功耗蓝牙（Bluetooth Low Energy）连接都是建立在 GATT (Generic Attribute Profile) 协议之上。GATT 是一个在蓝牙连接之上的发送和接收很短的数据段的通用规范，这些很短的数据段被称为属性（Attribute）。</p><h2 id="二、GAP"><a href="#二、GAP" class="headerlink" title="二、GAP"></a>二、GAP</h2><p>详细介绍 GATT 之前，需要了解 GAP（Generic Access Profile），它在用来控制设备连接和广播。GAP 使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互。例如 Beacon 设备就只是向外广播，不支持连接，小米手环就等设备就可以与中心设备连接。</p><h3 id="2-1-设备角色"><a href="#2-1-设备角色" class="headerlink" title="2.1 设备角色"></a>2.1 设备角色</h3><p>GAP 给设备定义了若干角色，其中主要的两个是：外围设备（Peripheral）和中心设备（Central）。</p><ul><li>外围设备：这一般就是非常小或者简单的低功耗设备，用来提供数据，并连接到一个更加相对强大的中心设备。例如小米手环。</li><li>中心设备：中心设备相对比较强大，用来连接其他外围设备。例如手机等。<h3 id="2-2-广播数据"><a href="#2-2-广播数据" class="headerlink" title="2.2 广播数据"></a>2.2 广播数据</h3>在 GAP 中外围设备通过两种方式向外广播数据： Advertising Data Payload（广播数据）和 Scan Response Data Payload（扫描回复），每种数据最长可以包含 31 byte。这里广播数据是必需的，因为外设必需不停的向外广播，让中心设备知道它的存在。扫描回复是可选的，中心设备可以向外设请求扫描回复，这里包含一些设备额外的信息，例如设备的名字。<h3 id="2-3-广播流程"><a href="#2-3-广播流程" class="headerlink" title="2.3 广播流程"></a>2.3 广播流程</h3>GAP 的广播工作流程如下图所示。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GAP_adv_proc.jpg" alt="GAP的广播工作流程"><br>从图中我们可以清晰看出广播数据和扫描回复数据是怎么工作的。外围设备会设定一个广播间隔，每个广播间隔中，它会重新发送自己的广播数据。广播间隔越长，越省电，同时也不太容易扫描到。<h3 id="2-4-广播的网络拓扑结构"><a href="#2-4-广播的网络拓扑结构" class="headerlink" title="2.4 广播的网络拓扑结构"></a>2.4 广播的网络拓扑结构</h3>大部分情况下，外设通过广播自己来让中心设备发现自己，并建立 GATT 连接，从而进行更多的数据交换。也有些情况是不需要连接的，只要外设广播自己的数据即可。用这种方式主要目的是让外围设备，把自己的信息发送给多个中心设备。因为基于 GATT 连接的方式的，只能是一个外设连接一个中心设备。 使用广播这种方式最典型的应用就是苹果的 iBeacon。广播工作模式下的网络拓扑图如下：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GAP_BroadcastTopology.jpg" alt="广播工作模式网络拓扑图"><h2 id="三、GATT"><a href="#三、GATT" class="headerlink" title="三、GATT"></a>三、GATT</h2>GATT 的全名是 Generic Attribute Profile（姑且翻译成：普通属性协议），它定义两个东西(Service和Characteristic)用于BLE设备的通信。GATT使用ATT（Attribute Protocol）协议，把 Service, Characteristic对应的数据保存在一个查找表中，次查找表使用 16 bit ID 作为每一项的索引。<br>一旦两个设备建立起了连接，GATT 就开始起作用了，这也意味着，你必需完成前面的 GAP 协议。这里需要说明的是，GATT 连接，必需先经过 GAP 协议。实际上，我们在 Android 开发中，可以直接使用设备的 MAC 地址，发起连接，可以不经过扫描的步骤。这并不意味不需要经过 GAP，实际上在芯片级别已经给你做好了，蓝牙芯片发起连接，总是先扫描设备，扫描到了才会发起连接。<br>GATT 连接需要特别注意的是：<code>GATT 连接是独占的</code>。也就是一个 BLE 外设同时只能被一个中心设备连接。一旦外设被连接，它就会马上停止广播，这样它就对其他设备不可见了。当设备断开，它又开始广播。<br>中心设备和外设需要双向通信的话，唯一的方式就是建立 GATT 连接。<h3 id="3-1-GATT连接的网络拓扑"><a href="#3-1-GATT连接的网络拓扑" class="headerlink" title="3.1 GATT连接的网络拓扑"></a>3.1 GATT连接的网络拓扑</h3>下图展示了 GTT 连接网络拓扑结构。这里很清楚的显示，一个外设只能连接一个中心设备，而一个中心设备可以连接多个外设。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GATT_network_topology.jpg" alt="GATT连接的网络拓扑"><br>一旦建立起了连接，通信就是双向的了，对比前面的 GAP 广播的网络拓扑，GAP 通信是单向的。如果你要让两个设备外设能通信，就只能通过中心设备中转。<h3 id="3-2-GATT-通信事务"><a href="#3-2-GATT-通信事务" class="headerlink" title="3.2 GATT 通信事务"></a>3.2 GATT 通信事务</h3>GATT 通信的双方是 C/S 关系。外设作为 GATT 服务端（Server），它维持了 ATT 的查找表以及 service 和 characteristic 的定义。中心设备是 GATT 客户端（Client），它向 Server 发起请求。需要注意的是，所有的通信事件，都是由客户端（也叫主设备，Master）发起，并且接收服务端（也叫从设备，Slave）的响应。<br>一旦连接建立，外设将会给中心设备建议一个连接间隔（Connection Interval）,这样，中心设备就会在每个连接间隔尝试去重新连接，检查是否有新的数据。但是，这个连接间隔只是一个建议，你的中心设备可能并不会严格按照这个间隔来执行，例如你的中心设备正在忙于连接其他的外设，或者中心设备资源太忙。<br>下图展示一个外设（GATT 服务端）和中心设备（GATT 客户端）之间的数据交换流程，可以看到的是，每次都是主设备发起请求：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GATT_MasterSlaveTransactions.jpg" alt="外设与中心设备数据交换"><h3 id="3-3-GATT结构"><a href="#3-3-GATT结构" class="headerlink" title="3.3 GATT结构"></a>3.3 GATT结构</h3>GATT 通信事务是建立在嵌套的Profiles, Services 和 Characteristics之上的的，如下图所示：<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/GATT_Structure.jpg" alt="GATT结构"></li><li><code>Profile</code> Profile 并不是实际存在于 BLE 外设上的，它只是一个被 Bluetooth SIG 或者外设设计者预先定义的 Service 的集合。例如心率Profile（Heart Rate Profile）就是结合了 Heart Rate Service 和 Device Information Service。所有官方通过 GATT Profile 的列表可以从<a href="http://developer.bluetooth.org/TechnologyOverview/Pages/Profiles.aspx#GATT" target="_blank" rel="noopener">这里</a>找到。 </li><li><code>Service</code> Service 是把数据分成一个个的独立逻辑项，它包含一个或者多个 Characteristic。每个 Service 有一个 UUID 唯一标识。 UUID 有 16 bit 的，或者 128 bit 的。16 bit 的 UUID 是官方通过认证的，需要花钱购买，128 bit 是自定义的，这个就可以自己随便设置。<br>官方通过了一些标准 Service，完整列表在<a href="https://developer.bluetooth.org/gatt/services/Pages/ServicesHome.aspx" target="_blank" rel="noopener">这里</a>。以 Heart Rate Service为例，可以看到它的官方通过 16 bit UUID 是 0x180D，包含 3 个 Characteristic：Heart Rate Measurement, Body Sensor Location 和 Heart Rate Control Point，并且定义了只有第一个是必须的，它是可选实现的。</li><li><code>Characteristic</code> 在 GATT 事务中的最低界别的是 Characteristic，Characteristic 是最小的逻辑数据单元，当然它可能包含一个组关联的数据，例如加速度计的 X/Y/Z 三轴值。<br>与 Service 类似，每个 Characteristic 用 16 bit 或者 128 bit 的 UUID 唯一标识。你可以免费使用 Bluetooth SIG 官方定义的标准 Characteristic，使用官方定义的，可以确保 BLE 的软件和硬件能相互理解。当然，你可以自定义 Characteristic，这样的话，就只有你自己的软件和外设能够相互理解。<br>实际上，和 BLE 外设打交道，主要是通过 Characteristic。你可以从 Characteristic 读取数据，也可以往 Characteristic 写数据。这样就实现了双向的通信。所以你可以自己实现一个类似串口（UART）的 Sevice，这个 Service 中包含两个 Characteristic，一个被配置只读的通道（RX），另一个配置为只写的通道（TX）。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>BLE学习笔记1-Android开发前言</title>
      <link href="/2020/07/05/diary-20200705-1/"/>
      <url>/2020/07/05/diary-20200705-1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、相关介绍"><a href="#一、相关介绍" class="headerlink" title="一、相关介绍"></a>一、相关介绍</h2><h3 id="1-1概述"><a href="#1-1概述" class="headerlink" title="1.1概述"></a>1.1概述</h3><p>本文主要描述Android BLE的一些基础知识及相关操作流程，不牵扯具体的业务实现，其中提供了针对广播包及响应包的解析思路。<br>蓝牙的创始公司是爱立信。1994年爱立信开始对小范围无线通信技术进行研发，在1997年，爱立信的研究激发了其他公司的浓厚兴趣，于是1998年2月，一些跨国大公司包括诺基亚、苹果、三星组成的一个特殊兴趣小组（SIG），他们共同的目标是建立一个全球性的小范围无线通信技术，该项技术就是蓝牙。</p><p>蓝牙无线技术是一种全球通用的短距离无线技术，通过蓝牙技术能够实现多种电子设备间的相互连接，特别是在小型无线电、耗电量低、成本低、安全性、稳定性、易用性以及特别的联网能力等固有的优势上，蓝牙无线技术发展迅速。</p><h3 id="1-2分类"><a href="#1-2分类" class="headerlink" title="1.2分类"></a>1.2分类</h3><p>蓝牙分为三种：Bluetooth Smart Ready、Bluetooth Smart（Smart是低功耗蓝牙的标识）、以及标准 Bluetooth。根据 Bluetooth SIG的说法，这样是为了要分辨装置间的相容性以及标识各版本的传输频率。基本上来说，Bluetooth Smart Ready适用于任何双模蓝牙4.0的电子产品,而Bluetooth Smart是应用在心率监视器或计步器等使用扭扣式电池并传输单一的装置。Bluetooth Smart Ready的相容性最高，可与Bluetooth Smart及标准蓝牙相通。标准蓝牙则无法与Bluetooth Smart相通。</p><h3 id="1-3BLE分类"><a href="#1-3BLE分类" class="headerlink" title="1.3BLE分类"></a>1.3BLE分类</h3><p>BLE是Bluetooth Low Energy的缩写，又叫蓝牙4.0，区别于蓝牙3.0和之前的技术。BLE前身是NOKIA开发的Wibree技术，主要用于实现移动智能终端与周边配件之间的持续连接，是功耗极低的短距离无线通信技术，并且有效传输距离被提升到了100米以上，同时只需要一颗纽扣电池就可以工作数年之久。BLE是在蓝牙技术的基础上发展起来的，既同于蓝牙，又区别于传统蓝牙。BLE设备分单模和双模两种，双模简称BR，商标为Bluetooth Smart Ready，单模简称BLE或者LE,商标为Bluetooth Smart。Android是在4.3后才支持BLE，这说明不是所有蓝牙手机都支持BLE，而且支持BLE的蓝牙手机一般是双模的。双模兼容传统蓝牙，可以和传统蓝牙通信，也可以和BLE通信，常用在手机上，android4.3和IOS4.0之后版本都支持BR，也就是双模设备。单模只能和BR和单模的设备通信，不能和传统蓝牙通信，由于功耗低，待机长，所以常用在手环的智能设备上。</p><h3 id="1-4蓝牙的工作原理"><a href="#1-4蓝牙的工作原理" class="headerlink" title="1.4蓝牙的工作原理"></a>1.4蓝牙的工作原理</h3><h4 id="1-4-1-蓝牙通信的主从关系"><a href="#1-4-1-蓝牙通信的主从关系" class="headerlink" title="1.4.1 蓝牙通信的主从关系"></a>1.4.1 蓝牙通信的主从关系</h4><p>蓝牙技术规定每一对设备之间进行蓝牙通讯时，必须一个为主角色，另一为从角色，才能进行通信，通信时，必须由主端进行查找，发起配对，建链成功后，双方即可收发数据。理论上，一个蓝牙主端设备，可同时与7个蓝牙从端设备进行通讯。一个具备蓝牙通讯功能的设备，可以在两个角色间切换，平时工作在从模式，等待其它主设备来连接，需要时，转换为主模式，向其它设备发起呼叫。一个蓝牙设备以主模式发起呼叫时，需要知道对方的蓝牙地址，配对密码等信息，配对完成后，可直接发起呼叫。这可以解释为什么有时无法连接蓝牙，有可能是连接的蓝牙设备过多。</p><h4 id="1-4-2-蓝牙的呼叫过程"><a href="#1-4-2-蓝牙的呼叫过程" class="headerlink" title="1.4.2 蓝牙的呼叫过程"></a>1.4.2 蓝牙的呼叫过程</h4><p>蓝牙主端设备发起呼叫，首先是查找，找出周围处于可被查找的蓝牙设备。主端设备找到从端蓝牙设备后，与从端蓝牙设备进行配对，此时需要输入从端设备的PIN码，也有设备不需要输入PIN码。配对完成后，从端蓝牙设备会记录主端设备的信任信息，此时主端即可向从端设备发起呼叫，已配对的设备在下次呼叫时，不再需要重新配对。已配对的设备，做为从端的蓝牙耳机也可以发起建链请求，但做数据通讯的蓝牙模块一般不发起呼叫。链路建立成功后，主从两端之间即可进行双向的数据或语音通讯。在通信状态下，主端和从端设备都可以发起断链，断开蓝牙链路。</p><h4 id="1-4-3-蓝牙一对一的串口数据传输应用"><a href="#1-4-3-蓝牙一对一的串口数据传输应用" class="headerlink" title="1.4.3 蓝牙一对一的串口数据传输应用"></a>1.4.3 蓝牙一对一的串口数据传输应用</h4><p>蓝牙数据传输应用中，一对一串口数据通讯是最常见的应用之一，蓝牙设备在出厂前即提前设好两个蓝牙设备之间的配对信息，主端预存有从端设备的PIN码、地址等，两端设备加电即自动建链，透明串口传输，无需外围电路干预。一对一应用中从端设备可以设为两种类型，一是静默状态，即只能与指定的主端通信，不被别的蓝牙设备查找；二是开发状态，既可被指定主端查找，也可以被别的蓝牙设备查找建链。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><h3 id="2-1-Generic-Access-Profile-GAP"><a href="#2-1-Generic-Access-Profile-GAP" class="headerlink" title="2.1 Generic Access Profile(GAP)"></a>2.1 Generic Access Profile(GAP)</h3><p>用来控制设备连接和广播，GAP使你的设备被其他设备可见，并决定了你的设备是否可以或者怎样与合同设备进行交互。    </p><h3 id="2-2-Generic-Attribute-Profile-GATT"><a href="#2-2-Generic-Attribute-Profile-GATT" class="headerlink" title="2.2 Generic Attribute Profile(GATT)"></a>2.2 Generic Attribute Profile(GATT)</h3><p>通过BLE连接，读写属性类数据的Profile通用规范，现在所有的BLE应用Profile都是基于GATT的。     </p><h3 id="2-3-Attribute-Protocol-ATT"><a href="#2-3-Attribute-Protocol-ATT" class="headerlink" title="2.3 Attribute Protocol (ATT)"></a>2.3 Attribute Protocol (ATT)</h3><p>GATT是基于ATTProtocol的，ATT针对BLE设备做了专门的优化，具体就是在传输过程中使用尽量少的数据，每个属性都有一个唯一的UUID，属性将以characteristics and services的形式传输。    </p><h3 id="2-4-Characteristic"><a href="#2-4-Characteristic" class="headerlink" title="2.4 Characteristic"></a>2.4 Characteristic</h3><p>Characteristic可以理解为一个数据类型，它包括一个value和0至多个对次value的描述（Descriptor）。</p><h3 id="2-5-Descriptor"><a href="#2-5-Descriptor" class="headerlink" title="2.5 Descriptor"></a>2.5 Descriptor</h3><p>对Characteristic的描述，例如范围、计量单位等。</p><h3 id="2-6-Service"><a href="#2-6-Service" class="headerlink" title="2.6 Service"></a>2.6 Service</h3><p>Characteristic的集合。例如一个service叫做“Heart Rate Monitor”，它可能包含多个Characteristics，其中可能包含一个叫做“heart ratemeasurement”的Characteristic。 </p><h3 id="2-7-UUID"><a href="#2-7-UUID" class="headerlink" title="2.7 UUID"></a>2.7 UUID</h3><p>唯一标示符，每个Service，Characteristic，Descriptor，都是由一个UUID定义。</p><h3 id="2-8-角色和职责"><a href="#2-8-角色和职责" class="headerlink" title="2.8 角色和职责"></a>2.8 角色和职责</h3><p>Android设备与BLE设备交互有两组角色</p><ul><li>中心设备和外围设备（Central vs. peripheral）</li></ul><p>Central角色负责scan advertisement。而peripheral角色负责make advertisement。<br>这两种角色取决于BLE连接成功后，两个设备间通信的方式。<br>现有一个活动追踪的BLE设备和一个支持BLE的Android设备。Android设备支持Central角色，而BLE设备支持peripheral角色。创建一个BLE连接需要这两个角色都存在，都仅支持Central角色或者都仅支持peripheral角色则无法建立连接。<br>当连接建立后，它们之间就需要传输GATT数据。谁做server，谁做client，则取决于具体数据传输的情况。例如，如果活动追踪的BLE设备需要向 Android设备传输sensor数据，则活动追踪器自然成为了server端；而如果活动追踪器需要从Android设备获取更新信息，则 Android设备作为server端可能更合适。</p><h3 id="2-9-权限及feature"><a href="#2-9-权限及feature" class="headerlink" title="2.9 权限及feature"></a>2.9 权限及feature</h3><p>和经典蓝牙一样，应用使用蓝牙，需要声明BLUETOOTH权限，如果需要扫描设备或者操作蓝牙设置，则还需要BLUETOOTH_ADMIN权限：</p><pre><code>&lt;uses-permissionandroid:name="android.permission.BLUETOOTH"/&gt;&lt;uses-permission android:name="android.permission.BLUETOOTH_ADMIN"/&gt;</code></pre><p>除了蓝牙权限外，如果需要BLE feature则还需要声明uses-feature：</p><pre><code>&lt;uses-featureandroid:name="android.hardware.bluetooth_le"android:required="true"/&gt;</code></pre><p>按时required为true时，则应用只能在支持BLE的Android设备上安装运行；required为false时，Android设备均可正常安装运行，需要在代码运行时判断设备是否支持BLE feature：</p><pre><code>// Use this check to determine whether BLE is supportedon the device. Then// you can selectively disable BLE-related features.if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)){    Toast.makeText(this, R.string.ble_not_supported,Toast.LENGTH_SHORT).show();    finish();}</code></pre><h2 id="三、Android-BLE-API"><a href="#三、Android-BLE-API" class="headerlink" title="三、Android BLE API"></a>三、Android BLE API</h2><h3 id="3-1-BluetoothGatt"><a href="#3-1-BluetoothGatt" class="headerlink" title="3.1 BluetoothGatt"></a>3.1 BluetoothGatt</h3><p>继承BluetoothProfile，通过BluetoothGatt可以连接设备（connect）,发现服务（discoverServices），并把相应地属性返回到BluetoothGattCallback，可以看成蓝牙设备从连接到断开的生命周期。</p><h3 id="3-2-BluetoothGattCharacteristic"><a href="#3-2-BluetoothGattCharacteristic" class="headerlink" title="3.2 BluetoothGattCharacteristic"></a>3.2 BluetoothGattCharacteristic</h3><p>相当于一个数据类型，可以看成一个特征或能力，它包括一个value和0~n个value的描述（BluetoothGattDescriptor）。</p><h3 id="3-3-BluetoothGattDescriptor"><a href="#3-3-BluetoothGattDescriptor" class="headerlink" title="3.3 BluetoothGattDescriptor"></a>3.3 BluetoothGattDescriptor</h3><p>描述符，对Characteristic的描述，包括范围、计量单位等。</p><h3 id="3-4-BluetoothGattService"><a href="#3-4-BluetoothGattService" class="headerlink" title="3.4 BluetoothGattService"></a>3.4 BluetoothGattService</h3><p>服务，Characteristic的集合。</p><h3 id="3-5-BluetoothProfile"><a href="#3-5-BluetoothProfile" class="headerlink" title="3.5 BluetoothProfile"></a>3.5 BluetoothProfile</h3><p>一个通用的规范，按照这个规范来收发数据。 </p><h3 id="3-6-BluetoothManager"><a href="#3-6-BluetoothManager" class="headerlink" title="3.6 BluetoothManager"></a>3.6 BluetoothManager</h3><p>通过BluetoothManager来获取BluetoothAdapter。</p><pre><code>BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);</code></pre><h3 id="3-7-BluetoothAdapter"><a href="#3-7-BluetoothAdapter" class="headerlink" title="3.7 BluetoothAdapter"></a>3.7 BluetoothAdapter</h3><p>代表了移动设备的本地的蓝牙适配器, 通过该蓝牙适配器可以对蓝牙进行基本操作，一个Android系统只有一个BluetoothAdapter，通过BluetoothManager获取。</p><pre><code>BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();</code></pre><h3 id="3-8-BluetoothDevice"><a href="#3-8-BluetoothDevice" class="headerlink" title="3.8 BluetoothDevice"></a>3.8 BluetoothDevice</h3><p>扫描后发现可连接的设备，获取已经连接的设备。 </p><pre><code>BluetoothDevice bluetoothDevice = bluetoothAdapter.getRemoteDevice(address);</code></pre><h3 id="3-9-BluetoothGattCallback"><a href="#3-9-BluetoothGattCallback" class="headerlink" title="3.9 BluetoothGattCallback"></a>3.9 BluetoothGattCallback</h3><p>已经连接上设备，对设备的某些操作后返回的结果。 </p><pre><code>BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback(){    //实现回调方法，根据业务做相应处理};BluetoothGatt bluetoothGatt = bluetoothDevice.connectGatt(this, false, bluetoothGattCallback);</code></pre><h2 id="四、操作流程"><a href="#四、操作流程" class="headerlink" title="四、操作流程"></a>四、操作流程</h2><h3 id="4-1-开启蓝牙"><a href="#4-1-开启蓝牙" class="headerlink" title="4.1 开启蓝牙"></a>4.1 开启蓝牙</h3><p>在使用蓝牙BLE之前，需要确认Android设备是否支持BLE feature(required为false时)，另外要需要确认蓝牙是否打开。如果发现不支持BLE，则不能使用BLE相关的功能；如果支持BLE，但是蓝牙没打开，则需要打开蓝牙。代码示例如下：</p><pre><code>//是否支持蓝牙模块@TargetApi(18)public static boolean isSupportBle(Context context) {    if(context != null &amp;&amp; context.getPackageManager().hasSystemFeature("android.hardware.bluetooth_le")) {        BluetoothManager manager = (BluetoothManager)context.getSystemService("bluetooth");        return manager.getAdapter() != null;    } else {        return false;    }}//是否开启蓝牙@TargetApi(18)public static boolean isBleEnable(Context context) {    if(!isSupportBle(context)) {        return false;    } else {        BluetoothManager manager = (BluetoothManager)context.getSystemService("bluetooth");        return manager.getAdapter().isEnabled();    }}//开启蓝牙public static void enableBle(Activity act, int requestCode) {    Intent mIntent = new Intent("android.bluetooth.adapter.action.REQUEST_ENABLE");    act.startActivityForResult(mIntent, requestCode);}//蓝牙开启过程if(isSupportBle(mContext)){    //支持蓝牙模块    if(!isBleEnable(mContext)){        //没开启蓝牙则开启        enableBle(mSelfActivity, 1);    }} else{    //不支持蓝牙模块处理}//蓝牙开启回调@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) {    //判断requestCode是否为开启蓝牙时传进去的值，再做相应处理    if(requestCode == 1){        //蓝牙开启成功后的处理    }    super.onActivityResult(requestCode, resultCode, data);}</code></pre><h3 id="4-2-设备搜索"><a href="#4-2-设备搜索" class="headerlink" title="4.2 设备搜索"></a>4.2 设备搜索</h3><ul><li><p>BluetoothAdapter.startDiscovery在大多数手机上是可以同时发现经典蓝牙和Ble的，但是startDiscovery的回调无法返回Ble的广播，所以无法通过广播识别设备，且startDiscovery扫描Ble的效率比StartLeScan低很多。所以在实际应用中，还是StartDiscovery和StartLeScan分开扫，前者扫传统蓝牙，后者扫低功耗蓝牙。</p></li><li><p>由于搜索需要尽量减少功耗，因此在实际使用时需要注意：当找到对应的设备后，立即停止扫描；不要循环搜索设备，为每次搜索设置适合的时间限制，避免设备不在可用范围的时候持续不停扫描，消耗电量。 </p></li><li><p>通过调用BluetoothAdapter的 startLeScan() 搜索BLE设备。调用此方法时需要传入 BluetoothAdapter.LeScanCallback 参数。具体代码示例如下：</p><pre><code>BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);BluetoothAdapter bluetoothAdapter = bluetoothManager.getAdapter();bluetoothAdapter.startLeScan(new BluetoothAdapter.LeScanCallback() {  @Override  public void onLeScan(BluetoothDevice device, int rssi, byte[] scanRecord) {      //对扫描到的设备进行处理，可以依据BluetoothDevice中的信息、信号强度rssi以及广播包和响应包组成的scanRecord字节数组进行分析  }});</code></pre><h3 id="4-3-设备通信"><a href="#4-3-设备通信" class="headerlink" title="4.3 设备通信"></a>4.3 设备通信</h3><p>两个设备通过BLE通信，首先需要建立GATT连接，这里我们讲的是Android设备作为client端，连接GATT Server。连接GATT Server，需要调用BluetoothDevice的connectGatt()方法，此函数带三个参数：Context、autoConnect(boolean)和 BluetoothGattCallback 对象。调用后返回BluetoothGatt对象，它是GATT profile的封装，通过这个对象，我们就能进行GATT Client端的相关操作。如断开连接<code>bluetoothGatt.disconnect()</code>，发现服务 <code>bluetoothGatt.discoverServices()</code> 等等。示例代码如下： </p><pre><code>BluetoothDevice bluetoothDevice = bluetoothAdapter.getRemoteDevice(address);BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback(){  @Override  public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {      super.onConnectionStateChange(gatt, status, newState);  }  @Override  public void onServicesDiscovered(BluetoothGatt gatt, int status) {      super.onServicesDiscovered(gatt, status);  }  @Override  public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {      super.onCharacteristicRead(gatt, characteristic, status);  }  @Override  public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {      super.onCharacteristicWrite(gatt, characteristic, status);  }  @Override  public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {      super.onCharacteristicChanged(gatt, characteristic);  }  @Override  public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {      super.onDescriptorRead(gatt, descriptor, status);  }  @Override  public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {      super.onDescriptorWrite(gatt, descriptor, status);  }  @Override  public void onReliableWriteCompleted(BluetoothGatt gatt, int status) {      super.onReliableWriteCompleted(gatt, status);  }  @Override  public void onReadRemoteRssi(BluetoothGatt gatt, int rssi, int status) {      super.onReadRemoteRssi(gatt, rssi, status);  }  @Override  public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) {      super.onMtuChanged(gatt, mtu, status);  }};BluetoothGatt bluetoothGatt = bluetoothDevice.connectGatt(this, false, bluetoothGattCallback);</code></pre></li></ul><p>//以下为获得Gatt后的相关操作对应的响应方法<br>//notification to onCharacteristicChanged；<br>bluetoothGatt.setCharacteristicNotification(characteristic, true);</p><p>//readCharacteristic to onCharacteristicRead；<br>bluetoothGatt.readCharacteristic(characteristic);</p><p>//writeCharacteristic to onCharacteristicWrite；<br>bluetoothGatt.wirteCharacteristic(mCurrentcharacteristic);</p><p>//connect and disconnect to onConnectionStateChange；<br>bluetoothGatt.connect();<br>bluetoothGatt.disconnect();</p><p>//readDescriptor to onDescriptorRead；<br>bluetoothGatt.readDescriptor(descriptor);</p><p>//writeDescriptor to onDescriptorWrite；<br>bluetoothGatt.writeDescriptor(descriptor);</p><p>//readRemoteRssi to onReadRemoteRssi；<br>bluetoothGatt.readRemoteRssi();</p><p>//executeReliableWrite to onReliableWriteCompleted；<br>bluetoothGatt.executeReliableWrite();</p><p>//discoverServices to onServicesDiscovered;<br>bluetoothGatt.discoverServices();</p><pre><code>### 4.4 数据解析 - BLE中有两种角色Central和Peripheral，也就是中心设备和外围设备，中心设备可以主动连接外围设备，外围设备发送广播或者被中心设备连接，外围通过广播被中心设备发现，广播中带有外围设备自身的相关信息。- 数据包有两种：广播包（Advertising Data）和响应包（Scan Response），其中广播包是每个设备必须广播的，而响应包是可选的。![数据包格式](https://gitee.com/seanzs/pic/raw/master/img/data_format.jpg)数据包的格式为每个包都是 31 字节，数据包中分为有效数据（significant）和无效数据（non-significant）两部分。- 有效数据部分：包含若干个广播数据单元，称为AD Structure。如图中所示，AD Structure的组成是：第一个字节是长度值Len，表示接下来的Len个字节是数据部分。数据部分的第一个字节表示数据的类型AD Type，剩下的Len - 1个字节是真正的数据AD data。其中AD type非常关键，决定了AD Data的数据代表的是什么和怎么解析，这个在后面会详细讲；- 无效数据部分：因为广播包的长度必须是31字节，如果有效数据部分不到31字节，剩下的就用0补齐，这部分的数据是无效的，解析的时候，直接忽略即可。- 查看Nordic的SDK中的定义，AD type的定义在程序的“ble_gap.h”头文件中。定义如下：</code></pre><p>#define BLE_GAP_AD_TYPE_FLAGS                               0x01 //&lt; Flags for discoverability.<br>#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_MORE_AVAILABLE   0x02 //&lt; Partial list of 16 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_16BIT_SERVICE_UUID_COMPLETE         0x03 //&lt; Complete list of 16 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_MORE_AVAILABLE   0x04 //&lt; Partial list of 32 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_32BIT_SERVICE_UUID_COMPLETE         0x05 //&lt; Complete list of 32 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_MORE_AVAILABLE  0x06 //&lt; Partial list of 128 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_128BIT_SERVICE_UUID_COMPLETE        0x07 //&lt; Complete list of 128 bit service UUIDs.<br>#define BLE_GAP_AD_TYPE_SHORT_LOCAL_NAME                    0x08 //&lt; Short local device name.<br>#define BLE_GAP_AD_TYPE_COMPLETE_LOCAL_NAME                 0x09 //&lt; Complete local device name.<br>#define BLE_GAP_AD_TYPE_TX_POWER_LEVEL                      0x0A //&lt; Transmit power level.<br>#define BLE_GAP_AD_TYPE_CLASS_OF_DEVICE                     0x0D //&lt; Class of device.<br>#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C               0x0E //&lt; Simple Pairing Hash C.<br>#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R         0x0F //&lt; Simple Pairing Randomizer R.<br>#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_TK_VALUE           0x10 //&lt; Security Manager TK Value.<br>#define BLE_GAP_AD_TYPE_SECURITY_MANAGER_OOB_FLAGS          0x11 //&lt; Security Manager Out Of Band Flags.<br>#define BLE_GAP_AD_TYPE_SLAVE_CONNECTION_INTERVAL_RANGE     0x12 //&lt; Slave Connection Interval Range.<br>#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_16BIT       0x14 //&lt; List of 16-bit Service Solicitation UUIDs.<br>#define BLE_GAP_AD_TYPE_SOLICITED_SERVICE_UUIDS_128BIT      0x15 //&lt; List of 128-bit Service Solicitation UUIDs.<br>#define BLE_GAP_AD_TYPE_SERVICE_DATA                        0x16 //&lt; Service Data - 16-bit UUID.<br>#define BLE_GAP_AD_TYPE_PUBLIC_TARGET_ADDRESS               0x17 //&lt; Public Target Address.<br>#define BLE_GAP_AD_TYPE_RANDOM_TARGET_ADDRESS               0x18 //&lt; Random Target Address.<br>#define BLE_GAP_AD_TYPE_APPEARANCE                          0x19 //&lt; Appearance.<br>#define BLE_GAP_AD_TYPE_ADVERTISING_INTERVAL                0x1A //&lt; Advertising Interval.<br>#define BLE_GAP_AD_TYPE_LE_BLUETOOTH_DEVICE_ADDRESS         0x1B //&lt; LE Bluetooth Device Address.<br>#define BLE_GAP_AD_TYPE_LE_ROLE                             0x1C //&lt; LE Role.<br>#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_HASH_C256            0x1D //&lt; Simple Pairing Hash C-256.<br>#define BLE_GAP_AD_TYPE_SIMPLE_PAIRING_RANDOMIZER_R256      0x1E //&lt; Simple Pairing Randomizer R-256.<br>#define BLE_GAP_AD_TYPE_SERVICE_DATA_32BIT_UUID             0x20 //&lt; Service Data - 32-bit UUID.<br>#define BLE_GAP_AD_TYPE_SERVICE_DATA_128BIT_UUID            0x21 //&lt; Service Data - 128-bit UUID.<br>#define BLE_GAP_AD_TYPE_3D_INFORMATION_DATA                 0x3D //&lt; 3D Information Data.<br>#define BLE_GAP_AD_TYPE_MANUFACTURER_SPECIFIC_DATA          0xFF //&lt; Manufacturer Specific Data.</p><pre><code>- 所有的 AD Type 的定义在文档[Core Specification Supplement](https://www.bluetooth.com/specifications/adopted-specifications)中，根据上面头文件中的定义，AD Type包括如下类型：- `Flags`     1. TYPE = 0x01： 这个数据用来标识设备 LE 物理连接的功能，DATA 是 0 到多个字节的 Flag 值，每个 bit 上用 0 或者 1 来表示是否为 True。如果有任何一个 bit 不为 0，并且广播包是可连接的，就必须包含此数据。各 bit 的定义如下：    ```    bit 0: LE有限发现模式    bit 1: LE普通发现模式    bit 2: 不支持BR/EDR    bit 3: 对Same Device Capable(Controller)同时支持BLE和BR/EDR    bit 4: 对Same Device Capable(Host)同时支持BLE和BR/EDR    bit 5..7: 预留    ```    - `Service UUID`广播数据中一般都会把设备支持的 GATT Service 广播出来，用来告诉外面本设备所支持的 Service。有三种类型的 UUID：16 bit, 32bit, 128 bit。广播中，每种类型类型有有两个类别：完整和非完整的。这样就共有 6 种 AD Type2. TYPE = 0x02：非完整的16 bit UUID列表3. TYPE = 0x03：完整的16 bit UUID列表4. TYPE = 0x04：非完整的32 bit UUID列表5. TYPE = 0x05：完整的32 bit UUID列表6. TYPE = 0x06：非完整的128 bit UUID列表7. TYPE = 0x07：完整的128 bit UUID列表 - `Local Name`设备名字，DATA 是名字的字符串。 Local Name 可以是设备的全名，也可以是设备名字的缩写，其中缩写必须是全名的前面的若干字符。     8. TYPE = 0x08：设备简称     9. TYPE = 0x09：设备全名 - `TX Power Leve`    10. TYPE = 0x0A：表示设备发送广播包的信号强度,DATA部分是一个字节，表示 -127 到 + 127 dBm。- `设备类别`    11. TYPE = 0x0D：设备类别- `设备配对的Hash值`    12. TYPE = 0x0E：设备配对的Hash值 - `设备配对的随机值`        13. TYPE = 0x0F：设备配对的随机值- `TK安全管理`    14. TYPE = 0x10：TK安全管理（Security Manager TK Value）- `带外安全管理`    15. TYPE = 0x11：带外安全管理（Security Manager Out of Band）,DATA 也是 Flag，每个 bit 表示一个功能：，各bit定义如下：    ```    bit 0: OOB Flag，0-表示没有OOB数据，1-表示有    bit 1: 支持LE    bit 2: 对Same Device Capable(Host)同时支持BLE和BR/EDR    bit 3: 地址类型，0-表示公开地址，1-表示随机地址    ```    - `外设（Slave）连接间隔范围`    16. TYPE = 0x12：外设（Slave）连接间隔范围，数据中定义了Slave最大和最小连接间隔，数据包含4个字节：前两字节定义最小连接间隔，取值范围：0x0006 ~ 0x0C80，而0xFFFF表示未定义；后两字节，定义最大连接间隔，取值范围同上，不过需要保证最大连接间隔大于或者等于最小连接间隔。- `服务搜寻` 外围设备可以要请中心设备提供相应的 Service。其数据定义和前面的 Service UUID 类似：    17. TYPE = 0x14：服务搜寻16 bit UUID列表    18. TYPE = 0x15：服务搜寻128 bit UUID列表    19. TYPE = 0x16：16 bit UUID Service，前两个字节是UUID，后面是Service的数据- `公开目标地址`     20. TYPE = 0x17：公开目标地址，表示希望这个广播包被指定的目标设备处理，此设备绑定了公开地址，DATA 是目标地址列表，每个地址 6 字节。- `随机目标地址`    21. TYPE = 0x18：随机目标地址，表示希望这个广播包被指定的目标设备处理，此设备绑定了随机地址，DATA 是目标地址列表，每个地址 6 字节。- `Appearance`    22. TYPE = 0x19：表示设备的外观 - `广播区间`    23. TYPE = 0x1A：广播区间- `LE设备地址`        24. TYPE = 0x1B：LE设备地址 - `LE设备角色`        25. TYPE = 0x1C：LE设备角色 - `256位设备配对的Hash值`        26. TYPE = 0x1D：256位设备配对的Hash值 - `256位设备配对的随机值`        27. TYPE = 0x1E：256位设备配对的随机值- `32bit UUID Service`            28. TYPE = 0x20：32 bit UUID Service，前4个字节是UUID，后面是Service的数据- `128bit UUID Service`        29. TYPE = 0x21：128 bit UUID Service，前16个字节是UUID，后面是Service的数据 - `3D信息数据`    30. TYPE = 0x3D：3D信息数据 - `厂商自定义数据`    31. TYPE = 0xFF：厂商自定义数据，厂商自定义的数据中，前两个字节表示厂商ID，剩下的是厂商自己按照需求添加，里面的数据内容自己定义。### 4.5 举例说明解析的思路搜索设备获取的数据包如下：</code></pre><p>02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35 09 03 E7 FE 12 FF 0F 18 0A 18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p><pre><code>根据解析规则，可分成如下部分：1.  广播数据 </code></pre><p>02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35</p><pre><code>2. 响应数据 </code></pre><p>09 03 E7 FE 12 FF 0F 18 0A 18 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p><pre><code>3. 有效数据 </code></pre><p>02 01 06 14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23 06 08 48 45 54 2D 35 09 03 E7 FE 12 FF 0F 18 0A 18</p><pre><code>4. 无效数据 </code></pre><p>00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</p><pre><code>其中的有效数据又可分为如下几个数据单元：</code></pre><p>02 01 06<br>14 FF 11 22 00 00 00 01 00 1F 09 01 00 00 00 CE DD 5E 5A 5D 23<br>06 08 48 45 54 2D 35<br>09 03 E7 FE 12 FF 0F 18 0A 18</p><pre><code>根据上面定义的AD Type分别解析如下：第一组数据告诉我们该设备属于LE普通发现模式，不支持BR/EDR；第二组数据告诉我们该数据为厂商自定义数据，一般是必须解析的，可根据协议规则进行解析获取对应的所需信息；第三组数据告诉我们该设备的简称为HET-5，其中对应的字符是查找[ASCII表](http://baike.baidu.com/link?url=_TISWJN8T3JSHi5A8OrhuBNyzLLAf006twuPA8wIWtdDG7UbyTfenCFaGWMxJCfXXmZp3SFMTHirjsKx0pTRua)得出；第四组数据告诉我们UUID为E7FE-12FF-0F18-0A18(此处有疑，类型03表示的是16位的UUID，对应的两个字节，而此处有8个字节，估计是设备烧录时把字节位数理解为了字符位数导致的问题).</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>4月以来的两月瘦了20斤</title>
      <link href="/2020/06/16/diary-20200616/"/>
      <url>/2020/06/16/diary-20200616/</url>
      
        <content type="html"><![CDATA[<h3 id="1-空"><a href="#1-空" class="headerlink" title="1.空"></a>1.空</h3><p align="center">不过是大梦一场空</p><p align="center">不过是孤影照惊鸿</p><p align="center">不过是白驹之过一场梦</p><p align="center">梦里有一些相逢</p><p align="center">有道是万物皆虚空</p><p align="center">有道是苦海最无穷</p><p align="center">有道是人生得意须尽欢</p><p align="center">难得最是心从容</p><p align="center">你每天都要求自己拒绝</p><p align="center">碌碌生活的平庸</p><p align="center">人潮挤散你的孤勇</p><p align="center">只留满夜星空</p><p align="center">让所有月色的朦胧</p><p align="center">都遮住现实里破碎的美梦</p><p align="center">而你的快乐正浓</p><p align="center">坠落在晚风</p><div align="center"><img width="500" height="350" src="https://gitee.com/seanzs/pic/raw/master/img/1138516029.jpg"></div><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>近期的工作学习计划</title>
      <link href="/2020/05/21/diary-20200521/"/>
      <url>/2020/05/21/diary-20200521/</url>
      
        <content type="html"><![CDATA[<h3 id="emsp-emsp-近期装修是最重要的事，买东西肉疼。另外近期的学习计划"><a href="#emsp-emsp-近期装修是最重要的事，买东西肉疼。另外近期的学习计划" class="headerlink" title="   近期装修是最重要的事，买东西肉疼。另外近期的学习计划:"></a>   近期装修是最重要的事，买东西肉疼。另外近期的学习计划:</h3><h4 id="1、web前端"><a href="#1、web前端" class="headerlink" title="1、web前端"></a>1、web前端</h4><h4 id="2、基于unity3d的图形学"><a href="#2、基于unity3d的图形学" class="headerlink" title="2、基于unity3d的图形学"></a>2、基于unity3d的图形学</h4><h4 id="3、UE4和UE5"><a href="#3、UE4和UE5" class="headerlink" title="3、UE4和UE5"></a>3、UE4和UE5</h4><h4 id="4、某服务器架构调试"><a href="#4、某服务器架构调试" class="headerlink" title="4、某服务器架构调试"></a>4、某服务器架构调试</h4><h4 id="5、MyBatis-半自动轻量级持久层框架"><a href="#5、MyBatis-半自动轻量级持久层框架" class="headerlink" title="5、MyBatis(半自动轻量级持久层框架)"></a>5、MyBatis(半自动轻量级持久层框架)</h4><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>难搞哦</title>
      <link href="/2020/05/19/diary-20200519/"/>
      <url>/2020/05/19/diary-20200519/</url>
      
        <content type="html"><![CDATA[<p>   难搞哦</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一天</title>
      <link href="/2020/05/17/diary-20200517/"/>
      <url>/2020/05/17/diary-20200517/</url>
      
        <content type="html"><![CDATA[<p>  今天周日，第一次在这里从早上待到晚上，看着这夕阳，才下眉头，却上心头。<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/646328966.jpg" width="80%" align="center"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>下班路上</title>
      <link href="/2020/05/11/diary-20200511/"/>
      <url>/2020/05/11/diary-20200511/</url>
      
        <content type="html"><![CDATA[<p>  下班路上<br><img src="https://cdn.jsdelivr.net/gh/shw2018/cdn@1.0/sakura/img/loader/orange.progress-bar-stripe-loader.svg" data-original="https://gitee.com/seanzs/pic/raw/master/img/1775673119.jpg" width="80%" align="center"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>明天就要去公司上班了</title>
      <link href="/2020/05/10/diary-20200510/"/>
      <url>/2020/05/10/diary-20200510/</url>
      
        <content type="html"><![CDATA[<blockquote><p>人生路漫漫，很多事情都会不知不觉中忘记，但如果你把它记录下来了。等你老了翻开来看看，那是一笔无法用钱来衡量的财富。</p></blockquote><p>  明天结束居家办公去公司上班，今天上午把电脑搬去公司，顺便做个卫生，停车费有点贵呀；<br>  下午有空想去中国银行更新下身份证信息，结果银行今天没开门；<br>  因为泥工不在，装修今天也没有进场，说是要过两天；<br>  人都是站在自己角度看事物，疫情渐缓，样品柜子可能也不太想不挣钱的便宜处理。<br>  前两天风大，短袖出行回来今天晚上感觉有点受凉。喝了两包板蓝根。睡觉。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>江滩拍摄婚纱照</title>
      <link href="/2020/05/07/diary-20200507/"/>
      <url>/2020/05/07/diary-20200507/</url>
      
        <content type="html"><![CDATA[<p>  昨天来江汉路选婚纱照的服装，选了三套：主白纱、彩纱、室外纱。到时候现场拍摄现场再选古装和街拍服装。天气预报今天中雨，但拍摄时间仍预约今天，如果真一直下大雨就只拍室内的，室外的另订时间。</p><p>  今天天公作美，早上九点半到店里，给女士化妆，给我扑了点粉，准时开拍，因疫情原因，原定江夏的外景改成就近的江滩，各个方面也挺合适的，拍摄时一直配合摄影师的要求在摆姿势，“帅哥、美女，往老公这靠点，看着你老婆，太凶了，这是假笑，靠近点，走一步，挺胸，头歪了，闭眼了，好，别动，再来一次，笑的敷衍哦，笑太开了，高点，过来点，侧着点，行，不错，很好”。</p><p>  五套服装连贯拍完一直到了下午五点半左右，期间吃了点自己带的代餐面包和水。确实是体力活，有点累的。</p><p>  晚上微信视频里你葛优躺在床头调侃拍照除了费钱有什么作用，我说可能是为了发朋友圈，呵呵。</p><p>  照片将情感沉淀在今天定格的瞬间，翻阅照片就是品味往事，点点滴滴，从懵懂变清晰。生活也逐渐展开新的篇章。</p><blockquote><p>5月9号挑选精修及入册的照片，5月16号邮箱看效果，估计5月底能拿相册等东西</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/01/diary-0/"/>
      <url>/2020/05/01/diary-0/</url>
      
        <content type="html"><![CDATA[<p>  因疫情原因，从1月23号到4月6号的两个多月一直呆乡里，关注新闻、刷抖音、吃饭、锻炼、了解日落与星空，背单词，做卫生、烧火、买菜、挖蒲公英、犁地之类。。。</p><a id="more"></a><p>  复工一段时间后，5月1号发现过去买的域名今年3月份就过期了，过期时间过长无法续费，只能更高费用的赎回，那域名就不要算了。再加上旧服务器本来就慢。</p><p>  把旧服务器上花里胡哨的文件备份留存以后，就捣鼓了这个博客，重新开始。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
